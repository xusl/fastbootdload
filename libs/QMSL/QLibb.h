/******************************************************************************/
/**
Program: QMSL

	$Id: //depot/HTE/QDART/QMSL/QLib.h#364 $

\code

	- Defines the "C" interface for all Factory Library functions.

	- Table of contents (text search can be done for the following sections)

			- General Information
			- Related Documents
			- Version History
			- Callback function definitions

			- Connection/Disconnection Functions
			- Text Logging
			- LTE Diag
			- HDR Diag
			- GSM Diag
			- Streaming Download Diag
			- Diagnostic commands
			- Phone async Logging
			- Phone sync (command) Logging
			- Keypad Diag
			- Handset Diag
			- MediaFLO Diag
			- CGPS Diag
			- ISDB-T Diag
			- MBP Diag

			- Commands for multiple FTM modes
			- Dual RX Chain FTM RF Commands
			- FTM CDMA RF Calibration API V2
			- GSM FTM
			- GSM Polar Tx Cal FTM
			- GSM Linear Tx FTM
			- PMIC FTM
			- cdma2000 FTM
			- cdma2000 FTM non-signaling
			- EVDO Non-signaling FTM
			- Bluetooth FTM
			- Audio FTM
			- Camera FTM
			- FTM Log

			- WCDMA BER FTM
			- HSDPA BER FTM

			- GSM BER FTM
			- EGPRS BER FTM
			- UMTS SINGLE ENDED BER FTM
			- GSDI Diag
			- AGPS FTM
			- Common RF FTM
			- LTE Non-signaling FTM
			- MediaFLO FTM
			- MediaFLO FTM UBM
			- MediaFLO NS FTM
			- DVB-H Diag Commands
			- WLAN FTM
			- QFUSE FTM
			- GPS FTM
			- FM FTM (FM Broadcast Radio)

			- Software Download
			- EFS Functions

			- Calibration Data Manager
			- NVTool

			- FTM Sequencer
			- Band Class Helper

	------------------------------------------------------


	----------------------
	General Information
	----------------------

	- All data types used in this interface are ANSI C compatible.

	- All returns that indicate "true if succeed, false if fail" are defined
		as:  1 = true = Success , 0 = false = failure

		Functions that are not entirely upper case do not correspond directly to
		an FTM or diagnostic command.

		For example, QLIB_ConnectServer() is not mapped directly to a diagnostic
		command.


	- Variable Names
		Variable names are prefixed in lower case to indicate the data type.
		The following are defined:

			p = Pointer
			i = Integer type, either char, short, or long
			d = Double or floating point
			e = Enumeration (possibly stored as a short, but representing
			                 a fixed list of possibilities)
			b = unsigned char, 0=false, 1=true

	----------------------
	Related Documents
	----------------------

	- The function name convention used in this document is as follows:

		QLIB_ indicates that this function corresponds to library function
		in the QLib project.

		From there, all diagnostic and FTM functions are named exactly as
		the command identifiers are defined in the QLib_Defines.h.

	- For a list of all document numbers referred to by QMSL, please see following section in the QDART Help file:
		1) QDART -> QDART Related Documents
	or  2) QDART -> QMSL -> Getting Started -> References.


\endcode


	-----------------------
	Version History
	-----------------------

 \b QUALCOMM  \b PROPRIETARY

	This document contains propriety information, and except with written
	permission of Qualcomm INC, such information shall not be
	published, or disclosed to others, or used for any purpose, and the
	document shall not be duplicated in whole or in part.


	Copyright (c) 2004-2008 QUALCOMM Incorporated.
	All Rights Reserved.
	Qualcomm Confidential and Proprietary

\version
Version information is stored in the file "QMSL_Release_Notes.txt"

\note
Compiler:  Microsoft Visual C++ v6.0 SP4
*******************************************************************************/

#if !defined(_QLIB_H)
#define _QLIB_H

#if !defined(_WINDOWS_)
	#include "windows.h"
#endif

/**
	Establish whether the library is being compiled into a DLL (exporting),
	or being included from a client (importing)

	When the DLL is built, then QLIB_EXPORTS should be defined
*/
#ifdef QLIB_EXPORTS
#define QLIB_API __declspec(dllexport)
#else
#define QLIB_API __declspec(dllimport)
#endif

#if defined(QLIB_STATIC)
#undef QLIB_API
#define QLIB_API
//#define QLIB_API __cdecl
#endif


#ifdef __cplusplus
extern "C" {
#endif


/******************************************************************************
						Callback function definitions
*******************************************************************************/
#if !defined(DIAG_FS_MAX_FILENAME_LEN)
#define DIAG_FS_MAX_FILENAME_LEN      80 /* Specified by EFS2              */
#define DIAG_FS_MAX_PATHNAME_LEN     128 /* Specified by EFS2              */
#endif
#define QLIB_EFS_MAX_FILENAME_LEN DIAG_FS_MAX_PATHNAME_LEN


//! Call back for an EFS directory element
typedef unsigned char( *EfsDirCB )
(
	char name[QLIB_EFS_MAX_FILENAME_LEN],  //defined in DiagEfsPkt.h
	unsigned char isFile,

	//attributes follow below
	unsigned short iAttributeMask,
	unsigned char iBufferingOption,
	unsigned char iCleanupOption,
	unsigned long iCreateDate,
	unsigned long iFileSize,
	HANDLE hContextID
);

/**
	Call back for EFS functions
*/
typedef unsigned char (*EfsFileTransferCB)
        (
         char srcname[512],
         char dstname[512],
         int oper,
         int suboper,
         unsigned long bytestransferred,
         unsigned long filesize,
		 HANDLE hContextID
);

/**
	Call back for general SW Download event( replaces the other non-EFS call backs)

	Optional for NV backup/restore and normal download.  Must be used for boot loader and
	multimage download
*/
typedef unsigned char( *generalSWDownloadCB )
(
	unsigned char* pEventStructure	// type union generalSwDownloadEvent_union, as defined in SoftwareDownload.h
									// Not declared explicitly here because general users do not need to
									// include the SWDownload.h file.
);

/**
	Call back for receipt of async messages

	Optional for NV backup/restore and normal download.  Must be used for boot loader and
	multimage download

	\param iMessageSize = number of bytes in the message
	\param pMessageBuffer = pointer to a buffer of memory with the message.  This must be copied by the
	                        user because after the call back is called, the buffer can be changed at
							any time
	\param hContextID = the same context ID used for function calls on a certain COM port.


*/
typedef void( *asyncMessageCB )
(
	unsigned short iMessageSize,
	unsigned char* iMessageBuffer,
	HANDLE hContextID
);


/**
	Call back for user-defined send (PC to mobile) function.
	To be used with QLIB_ConnectServer_UserDefinedTransport()


	\param hQMSL_ContextID = the QMSL that is associated with the connection.
	\param hUserContextID = the context ID that was passed to QLIB_ConnectServer_UserDefinedTransport()
	\param iRequestSize = Number of bytes to be sent in the request packet.
	\param piRequestBytes = Pointer to a buffer of request packet contents.
	\param piActualWriteSize = to be updated by the user function, the actual # of bytes that were written

	\return 0 if successful (ERROR_SUCCESS) otherwise, an error code as defined by WINERR.H error codes,
	          usually the value of ::GetLastError

     http://msdn.microsoft.com/library/default.asp?url=/library/en-us/debug/base/system_error_codes__0-499_.asp
*/
typedef unsigned long( *userDefinedSend )
(
	HANDLE hQMSL_ContextID,
	HANDLE hUserContextID,
	unsigned long iRequestSize,
	unsigned char* piRequestBytes,
	unsigned long* piActualWriteSize
);

/**
	Call back for user-defined receive (from mobile to PC) function.
	To be used with QLIB_ConnectServer_UserDefinedTransport()

	\param hQMSL_ContextID = the QMSL that is associated with the connection.
	\param hUserContextID = the context ID that was passed to QLIB_ConnectServer_UserDefinedTransport()
	\param iRequestSize = Number of bytes to be sent in the request packet.
	\param piRequestBytes = Pointer to a buffer of request packet contents.
	\param piResponseSize = Pointer to number of bytes received in the response packet
							NOTE: when calling this function, the value must be equal to the
							maximum size of the receive buffer.  When the function returns, the
							value will be the actual number of bytes filled into the receive buffer.
	\param iResponseBytes = Pointer to a buffer to store the response packet contents.

	\return 0 if successful (ERROR_SUCCESS) otherwise, an error code as defined by WINERR.H error codes,
	          usually the value of ::GetLastError

     http://msdn.microsoft.com/library/default.asp?url=/library/en-us/debug/base/system_error_codes__0-499_.asp

*/
typedef unsigned long( *userDefinedReceive )
(
	HANDLE hQMSL_ContextID,
	HANDLE hUserContextID,
	unsigned long* piResponseSize,
	unsigned char* piResponseBytes
);

/**
	Call back for user-defined function to flush Tx and Rx buffers.

	\param hQMSL_ContextID = the QMSL that is associated with the connection.
	\param hUserContextID = the context ID that was passed to QLIB_ConnectServer_UserDefinedTransport()
	\return 0 if successful (ERROR_SUCCESS) otherwise, an error code as defined by WINERR.H error codes,
	          usually the value of ::GetLastError

     http://msdn.microsoft.com/library/default.asp?url=/library/en-us/debug/base/system_error_codes__0-499_.asp

*/
typedef unsigned long( *userDefinedFlushTxRx )
(
	HANDLE hQMSL_ContextID,
	HANDLE hUserContextID

);

/**
	Call back for NV Tool functions

	\param hQMSLContext = the QMSL context that is associated with the connection.
	\param iNVid		= NV item ID
	\param iSourceFunc	= The NV Tool function call, See QMSL_NVTool_CallBack_Source_Enum in QLib_Defines.h
	\param iEvent       = The status from loading or writing the NV item.  See QMSL_NVTool_CallBack_Event_Enum in QLib_Defines.h
	\param iProgress    = Progress, 0 to 100 percent
*/
typedef void ( *nvToolCB )
(
	HANDLE hQMSLContext,
	unsigned short iNVid,
	unsigned short iSourceFunc,
	unsigned short iEvent,
	unsigned short iProgress
);

/**
	Call back for QLIB_QPHONEMS_UploadSBMultiImage

	\param hQMSLContext = the QMSL context that is associated with the connection.
	\param sMsg			= NULL terminerated character string message
	\param iMsgSize		= The lenght of the sMsg
*/
typedef void ( *swdlQPHONEMSCB )
(
	HANDLE hQMSLContext,
	char	*sMsg,
	unsigned short iMsgSize
);

/******************************************************************************
						Connection/Disconnection Functions
*******************************************************************************/

	/******************************************************************************/
	/**

	Connect the server to a certain COM port number

	\param iComPort = COM port number to use for communication with phone.
						This does not open the COM port at the operating system
						level until a call is made to the embedded target.


						For auto detection, the COM port passed in can be
						QLIB_COM_AUTO_DETECT, and the first attached phone will
						be used automatically.

						For a NULL connection, the COM port passed in should be
						QLIB_COM_NULL.

	\return HANDLE to use for all subsequent QLIB calls that require a handle.
	        If NULL, then no valid phone was found.

	*******************************************************************************/
	QLIB_API HANDLE QLIB_ConnectServer( unsigned int iComPort );

	/******************************************************************************/
	/**

	Connect the server to a certain COM port number

	\param iComPort = COM port number to use for communication with phone.
						This does not open the COM port at the operating system
						level until a call is made to the embedded target.

						For auto detection, the COM port passed in can be
						QLIB_COM_AUTO_DETECT, and the first attached phone will
						be used automatically.

						For a NULL connection, the COM port passed in should be
						QLIB_COM_NULL.


	\param iWait_ms = # of milliseconds to wait before an error is considered.

	\return HANDLE to use for all subsequent QLIB calls that require a handle.
	        If NULL, then no valid phone was found.

	*******************************************************************************/
	QLIB_API HANDLE QLIB_ConnectServerWithWait( unsigned int iComPort, unsigned long iWait_ms );

	/******************************************************************************/
	/**

	Connect to a specified logical port number.  Before this function is called,
	a logical<-->physical mapping must be created using the function: QLIB_AddPortAliasEntry()


	\param iLogicalPort = Logical number to create a connection for.

	\return void

	*******************************************************************************/
	QLIB_API HANDLE QLIB_ConnectServer_LogicalPort( unsigned int iLogicalPort );

	/******************************************************************************/
	/**

	Connect the server to a certain COM port number with diagnostic command ECHO(0x7B)
	as handshake for QPHONEMS mode

	In QPST mode, this function is same as QLIB_ConnectServer

	In QPHONEMS mode, the function will send two diagnostic command, ECHO(0x7B), as handshake during port opening.

	Use this function to connect to a Windows Mobile target booting directly into FTM mode. (NV_FTM_I(453) == 1)

	\param iComPort = COM port number to use for communication with phone.
						This does not open the COM port at the operating system
						level until a call is made to the embedded target.

						For auto detection, the COM port passed in can be
						QLIB_COM_AUTO_DETECT, and the first attached phone will
						be used automatically.

						For a NULL connection, the COM port passed in should be
						QLIB_COM_NULL.

	\return HANDLE to use for all subsequent QLIB calls that require a handle.
	        If NULL, then no valid phone was found.

	*******************************************************************************/
	QLIB_API HANDLE QLIB_ConnectServerWithHandShake( unsigned int iComPort );
	/******************************************************************************/
	/**

	Set the state of a flag which determines whether the DATA 2 DIAG switch
	should be attempted when there is a IsPhoneConnected() failure.

	DATA 2 DIAG is a feature of the "AT" data mode, which allows the "diagnostic"
	and "data" channels to the MSM to be multiplexed on the same serial path.
	This is used only for RS-232 communication, not USB.

	The default setting of the library will be to not have DATA 2 DIAG mode enabled.
	This will make it faster to detect whether or not a phone is connected to a certain
	COM port.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param bSwitchData2Daig = true to attempt AT command to change from data mode to diag mode.

	\return True if the library is not in QPST mode.

	\warning This function does not apply when the library is in QPST mode.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_SetData2DiagSearch( HANDLE hResourceContext, unsigned char bSwitchData2Daig );

	/******************************************************************************/
	/**

	Setup a connection using a user-defined transport layer.  The user defined transport
	consists of three functions--one to send data, another to receive data, and the last
	to flush the Rx buffer.


	These functions	will be called by QMSL when QMSL needs to access the physical layer.

	The user also has the option of having QMSL to handle the HDLC formatting (including CRC)
	seperately for the send and receive packets.

 	Before calling this function, the communication channel should be already established
	so that QMSL can make calls to the user functions immediately.

	Until DisconnectServer() is called, a background thread will be running to continually
	read the COM port and check for received data.

	This function will automatically set the library into 'QPHONEMS' mode by calling
	QLIB_SetLibraryMode() with a parameter of FALSE.  The user-defined mode is a sub
	mode of the the internal engine, QPHONEMS.

	\param hUserHandle = User defined handle, to be passed when the send or receive functions are called.
						This value can be any number except for -1 (0xFFFF).  When QLIB_GetComPortNumber()
						is called, this value will be returned.

	\param pUserDefinedSend = User send function, to be called when QMSL will send data to the mobile

	\param pUserDefinedReceive = User defined receive function, to be called when QMSL will receive data
	                             from the mobile

	\param pUserDefinedFlushRx = user defined function to flush the rx buffer

	\param bQMSL_HandlesTxHDLC = TRUE if QMSL is to handle the HDLC tasks when sending a packet,
	                             including escape sequences, CRC, and trailing flag.

								 This flag should always be set to TRUE because this is the only mode that
								 QMSL is tested in.

                                 If this flag is set to FALSE then only synchronous messages can be recieved.

	\param bQMSL_HandlesRxHDLC = TRUE if QMSL is to handle the HDLC tasks when receiving a packet,
								 including escape sequences, CRC, and trailing flag.

								 This flag should always be set to TRUE because this is the only mode that
								 QMSL is tested in.

								 If this flag is set to FALSE then only synchronous messages can be recieved.

	\return void

	*******************************************************************************/
	QLIB_API HANDLE QLIB_ConnectServer_UserDefinedTransport(
			HANDLE hUserHandle,
			userDefinedSend pUserDefinedSend,
			userDefinedReceive pUserDefinedReceive,
			userDefinedFlushTxRx pUserDefinedFlushRx,
			unsigned char bQMSL_HandlesTxHDLC,
			unsigned char bQMSL_HandlesRxHDLC
			);

	/******************************************************************************/
	/**

	Pause the receive thread for a specific device context.  This can only be used
	when the library is in the QPHONEMS mode, and the sub-mode of user
	defined transport layer mode.

	This function can be used to prevent QMSL from accessing the COM port during the
	time that the operation is paused.

	Call QLIB_ResumeDataReceive() to resume operation

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if failure.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_PauseDataReceive( HANDLE hResourceContext );

	/******************************************************************************/
	/**

	Resumes receive operations that were paused by calling QLIB_PauseDataReceive().

	This can only be used when the library is in the QPHONEMS mode, and the sub-mode,
	of user defined transport layer mode.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if failure.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_ResumeDataReceive( HANDLE hResourceContext );

	/******************************************************************************/
	/**

	Sets the maximum size of how much data will be written to a serial device in one
	call to the Windows serial device call, ::WriteFile().

	In order words, if a packet is larger than this value, then it will be broken
	into smaller sections, with the size of "iSendDataWriteSizeLimit"

	This function is needed for some USB->RS232 converters, which allow only 1k of
	data to be written at a time.  Most USB and PC hardware can allow larger
	transfer sizes.

	This function is only useful for very large packets, such as EFS Write transfers.

	This can only be used when the library is in the QPHONEMS mode. It is ignored
	in the QPST mode and the "user defined transport layer" mode.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSendDataWriteSizeLimit = maximum size of data written to the serial device per call to
	                                 the Windows serial device driver.  Default size is 1000 at
									 the time the library starts

	\return true if successful, false if failure.

	\warning WARNING: If this number is set higher that 1500, then some phones will have diagnostic
	         buffer overflows.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_SetSendDataSerialWriteSizeLimit(
			HANDLE hResourceContext,
			unsigned long iSendDataWriteSizeLimit );

	/******************************************************************************/
	/**

	Disconnect the server and close the COM port associated with the server.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return void

	*******************************************************************************/
	QLIB_API void QLIB_DisconnectServer( HANDLE hResourceContext );

	/******************************************************************************/
	/**

	Disconnects all servers and closes the COM ports associated with those server.

	Normally, this function does not need to be called, because a call to
	QLIB_DisconnectServer() can be done for each reasource that is opened.

	This function is to be used for cases when multiple connections are made to different
	COM ports during the lifetime of the application, or in the case of emergency/exception
	shut down.

	\return void

	\warning All handles will be invalid after this function is called.

	*******************************************************************************/
	QLIB_API void QLIB_DisconnectAllServers( void );

	/******************************************************************************/
	/**

	Uses the port list in the system registry to determine which COM ports are available
	on the PC and returns the information via iNumPorts and pPortList.  This function
	is only tested on Windows XP.

	\param iNumPorts = input/output, The input value is the maximum number of entries that
					   can be added to the pPortList array.  The output value is updated to
					   reflect how many valid ports were found on the system.

	\param pPortList = output, byte array.  Each byte indicates a COM port number that is
	                   available on the system.

	\return true if operation was able to complete successfully and at least one
	        valid port is found.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GetAllPortList( unsigned short* iNumPorts, unsigned short* pPortList  );

	/******************************************************************************/
	/**

	Uses GetAllPortList() to determine which ports have phones available, then uses
	attempts a connection on each of the ports returned.

	\param iNumPorts = input/output, The input value is the maximum number of entries that
					   can be added to the pPortList array.  The output value is updated to
					   reflect how many valid ports were found on the system.

	\param pPortList = output, unsigned char array.  Each unsigned char indicates a COM port number that is
	                   available on the system.

	\param iNumIgnorePorts = # of ports in the "ignore port list."  Zero to check all ports
	\param pIgnorePortList = a list of port numbers that are to be ignored.  This can speed up
	                         the auto detection of ports.

	\return true if operation was able to complete successfully and at least one
	        valid port is found.

	\warning 1) this function will take about 1 second for each port that is on the system

	         2) All connections will be closed before searching begins.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GetAvailablePhonesPortList(
		unsigned short* iNumPorts, unsigned short* pPortList,
		unsigned short iNumIgnorePorts, unsigned short* pIgnorePortList );

	/******************************************************************************/
	/**

	Returns the COM port number associated with a specific resource context.  This
	can be used to determine the COM port number for a phone that was connected
	to automatically.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piPhysicalPort = output, physical port number, such as a 6 for COM6

	\return true if COM port could be determined successfully

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GetComPortNumber(HANDLE hResourceContext , unsigned short* piPhysicalPort );


	/******************************************************************************/
	/**

	Clears the port alias list.

	The port alias list is a method for mapping a logical port number to a physical
	port number.  This allows users to respond to a situation in which USB ports
	are mapped to unique numbers, depending on which devices have been installed in
	the past.

	An example of a port alias list:

	    Logical    Physical
	 	 Port       Port
		-------    --------
		   1         COM7
		   2         COM19
		   3         COM6
		   4         COM30

	The port mapping process can be facilitated by the GetAvailablePhonesPortList()
	function, which returns a list of which ports have a phone installed.  A "calibration"
	procedure could be setup, which tells the user to plug one phone into a port, then
	records which port the phone is in, then instructs them to plug the phone into the
	next USB port, and so on.

	During this procedure, the user software would create a logical list of ports
	(like 1,2,3,4) and remember which physical COM port number is associated with
	each logical port.  It is the user's (user of QLIB) responsibility to store this
	association in a persistant way (such as the registry or INI file), then when
	their software starts up the software would first call ClearPortAliasList(),
	then call AddPortAliasEntry() for each logical/physical port association.

	NOTE: It is not necessary to ClearPortAliasList(), if not alias have been created
	      in the current run-time session.  In other words, the alias list is empty
		  by default, and is only filled in by users of QLIB.

	After that, they could call the QLIB_ConnectServer_LogicalPort() function, to
	connect to a logical port number that has been configured.

	\return true if port alias list is successfully cleared.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_ClearPortAliasList( void );

	/******************************************************************************/
	/**

	Add an entry to the port alias list.  This function should be called once for
	each logical/physical port association.

	See ClearPortAliasList() for more information about port aliasing

	\param iLogicalPort = logical port number, user defined number
	\param iPhysicalPort = physical port number, such as a 6 for COM6

	\return true if port alias is successfully updated.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_AddPortAliasEntry(unsigned short iLogicalPort, unsigned short iPhysicalPort );

	/******************************************************************************/
	/**

	Configures call back functions.

	If one of the pointers is NULL, then the call back will be disabled for
	that call back type.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param pEfsDirCallback   = Callback for the EfsDirectory() operation
		\param pGeneralSwDownloadCB = Callback for download events
		\param pAsyncMessageCB = Callback for filtering async messages

	\return None

	*******************************************************************************/
	QLIB_API void QLIB_ConfigureCallBacks
				(
				HANDLE hResourceContext,
				EfsDirCB pEfsDirCallback,
				generalSWDownloadCB pGeneralSwDownloadCB,
				asyncMessageCB pAsyncMessageCB
				);

	/******************************************************************************/
	/**

	Configures EFS2 call back functions.

	If one of the pointers is NULL, then the call back will be disabled for
	that call back type.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param pEfsCallback = Callback for general EFS2 operations
		\param EfsDirCB = Callback for EFS Directory operations

	\return None

	*******************************************************************************/
	QLIB_API void QLIB_ConfigureEfs2CallBacks
				(
				HANDLE hResourceContext,
				EfsFileTransferCB pEfsCallback,
				EfsDirCB pEfsDirCB
				);


	/******************************************************************************/
	/**

	Configure Library Text Message call back function.

	The library text message call back is called each time a text message is printed
	to the log file.  The call back structure will contain the message level (e.g. LOG_IO
	or LOG_FN), and the NULL-terminated string containing the message text.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param pAsyncMessageCB = Callback for library generated text messages. The "unsigned char*" pointer
		                         will be of the structure type: QMSL_TextLog_struct, defined in QLib_Defines.h
								 Specify a NULL value to disable this callback.

	\return None

	*******************************************************************************/
	QLIB_API void QLIB_ConfigureLibraryTextLogCallBack
				(
				HANDLE hResourceContext,
				asyncMessageCB pAsyncMessageCB
				);

	/******************************************************************************/
	/**

	Configures a specific timeout value.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param eTimeOutId = Identifier index of timeout to change, index defined by
		                    QMSL_TimeOutType_Enum in QLibDefines.h
		\param iNewValue_ms = number of millseconds for timeout value

	\return None

	*******************************************************************************/
	QLIB_API unsigned char QLIB_ConfigureTimeOut
				(
				HANDLE hResourceContext,
				unsigned long eTimeOutId,
				unsigned long iNewValue_ms
				);

	/******************************************************************************/
	/**

	Get a specific timeout value.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param eTimeOutId = Identifier index of timeout to change, index defined by
		                    QMSL_TimeOutType_Enum

		\return timeout value in milliseconds

	\return None

	*******************************************************************************/
	QLIB_API unsigned long QLIB_GetTimeOut( HANDLE hResourceContext, unsigned long eTimeOutId );

	/******************************************************************************/
	/**

	CDMA ICD, 3.4.123 Diagnostic Protocol Loopback Request/Response

	Pings the phone using the diagnostic command DIAG_PROTOCOL_LOOPBACK_F.

	Additionally verifies the connection using the dignostic version command DIAG_VERNO_F.

	This command has a timeout value that can be checked or modified using the identifier
	QMSL_Timeout_IsPhoneConnected when calling QLIB_ConfigureTimeOut() or QLIB_GetTimeOut()

	The default timeout is 200ms, so that as little time as possible will be spent to wait
	for a phone request in the event that a phone is not present.  Other diagnostic functions
	use a longer timeout, so this function is the only one that should be called until a
	phone is verified to be on a certain COM port.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\return Returns true if the phone is connected, false if it is not connected

	*******************************************************************************/
	QLIB_API unsigned char QLIB_IsPhoneConnected(HANDLE hResourceContext );

	/******************************************************************************/
	/**

	CDMA ICD, 2.1.2 Asynchronous data protocol

	Sends a request/response packet.  This allows the user to send any diagnostic
	or FTM command that is available in the protocol documents.

	The request and response packets will be formatted properly for HDLC transmission.

	This function can also be used to send packets to access new FTM functionality
	that is added before the PC library is updated to support that new function
	directly.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iRequestSize = Number of bytes to be sent in the request packet.
		\param piRequestBytes = Pointer to a buffer of request packet contents.
		\param piResponseSize = Pointer to number of bytes received in the response packet
		                        NOTE: when calling this function, the value must be equal to the
								maximum size of the receive buffer.  When the function returns, the
								value will be the actual number of bytes filled into the receive buffer.
		\param iResponseBytes = Pointer to a buffer to store the response packet contents.
		\param iTimeout = Number of milliseconds to wait for a timeout.

	\return Returns true if the first byte of the response packet matches
	        the first byte of the request packet, false if it the phone is
			not connected or the first bytes of request and response packets
			do not match.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_SendSync
				(
				HANDLE hResourceContext,
				short iRequestSize,
				unsigned char* piRequestBytes,
				short* piResponseSize,
				unsigned char* piResponseBytes,
				unsigned long iTimeout
				);

	/******************************************************************************/
	/**

	Sends a asynchronous packet.  Unlike SendSync, this command does not wait for a
	response packet from the phone.

	This command is only usable when the phone is in QPHONEMS mode, not QPST mode

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iRequestSize = Number of bytes to be sent in the request packet.
		\param piRequestBytes = Pointer to a buffer of request packet contents.
		\param iTimeout = Number of milliseconds to wait for a timeout.
		\param bStartFlag = 0 - SendASync will send data as it is, 1 - SendASync will add Start and Stop bytes

	\return Returns true if the send operation completes successfully.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_SendASync
				(
				HANDLE hResourceContext,
				unsigned short iRequestSize,
				unsigned char* piRequestBytes,
				unsigned long iTimeout,
				unsigned char bStartFlag
				);

	/******************************************************************************/
	/**
	Sets mode for Send
	This command is only usable when the phone is in QPHONEMS mode, not QPST mode

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param bStartFlag = 0 - Send will send data as it is, 1 - Send will add Start and Stop bytes

	\return Returns last status of StartFlag

	*******************************************************************************/
	QLIB_API unsigned char QLIB_SetStartFlag
				(
				HANDLE hResourceContext,
				unsigned char bStartFlag
				);

	/******************************************************************************/
	/**

	Sends RAW data.
	This allows the user to send an AT command and check for an "OK" response.

    The only valid response that is checked for is "OK". No other response message
	will work.

	In other words, this command has very limited use and cannot be used
	for general ASCII communication. Instead a separate communications library
	should be used for ACII.

	The message will not be formatted in any way. The user should format message correctly.
	(i.e. AT command finished with "\r" and close string with "\0")

	This command is only usable when the phone is in QPHONEMS mode, not QPST mode.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iRequestSize = Number of bytes to be sent in the request packet.
		\param piRequestBytes = Pointer to a buffer of request packet contents.
		\param piResponseSize = Pointer to number of bytes received in the response packet
		                        NOTE: when calling this function, the value must be equal to the
								maximum size of the receive buffer.  When the function returns, the
								value will be the actual number of bytes filled into the receive buffer.
		\param iResponseBytes = Pointer to a buffer to store the response packet contents.
		\param iTimeout = Number of milliseconds to wait for a timeout.

	\return Returns true response message received, false if it the phone is
			not connected or the time delay has run out.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_SendRAW
				(
				HANDLE hResourceContext,
				short iRequestSize,
				unsigned char* piRequestBytes,
				short* piResponseSize,
				unsigned char* piResponseBytes,
				unsigned long iTimeout
				);

	/******************************************************************************/
	/**
	Sets packet mode for sending Diagnostic, FTM or RAW data.

	This function sets both phone and Qlib to send data either in Diagnostic or RAW mode.

	This command is only usable when the phone is in QPHONEMS mode, not QPST mode

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iPacketMode =	QLIB_PacketMode_BothDiag = 0 - both Qlib and phone in Diagnostic/FTM command mode
									(sending Diagnostic/FTM commands via Diagnostic COM port to phones Diagnostic port),
									used to send diagnostic commands via serial cable or diagnostic COM port on USB cable
								QLIB_PacketMode_BothAT = 1 - both Qlib and phone in Data/AT command mode
									(sending AT commands via Diagnostic COM port to phones Diagnostic port),
									used to send AT comands via serial cable
								QLIB_PacketMode_LibAT = 2 - Qlib in Data/At command mode and phone as it is
									(sending AT commands via Diagnostic COM port to phones modem port)
									used to send AT commands via modem COM port on USB cable
								QLIB_PacketMode_OBEX = 3 - QLib in OBEX protocol mode

	\return Returns true if mode switched, false if phone was not connectedor failed switching modes

	*******************************************************************************/
	QLIB_API unsigned char QLIB_SetPacketMode
				(
				HANDLE hResourceContext,
				unsigned char iPacketMode
				);

	/******************************************************************************/
	/**
	Streaming Download ICD, 3.2.1 19 Hello packet

	This function sends the "hello" packet to the phone, and returns the response
	message, in its entirety, by copying the response packet to a user defined
	buffer.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iVersionNumber = Host shall set this field to indicate the maximum version
	                        of this protocol that the host supports. The value for this
							field is 0x03.

	\param iCompatibleVersion = Host shall set this field to indicate the lowest version
	                            of the protocol that it supports. The value for this field
								is 0x02.

	\param iFeatureBits = Host shall set these bits to indicate the negotiated set
	                      of features requested to be used.

	\param pResponseBuffer = The entire response packet, as defined by section 3.2.2 of
	                         the streaming download ICD.

	\return true if response packet was successfully returned, false if fail for any reason.

	\warning The function must run in QPHONEMS mode

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DOWNLOAD_Hello
		(
			HANDLE hResourceContext,
			unsigned char iVersionNumber,
			unsigned char iCompatibleVersion,
			unsigned char iFeatureBits,
			unsigned char* pResponseBuffer
		);


	/******************************************************************************/
	/**
	Streaming Download ICD, x.x.x QFprom Write

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iRowAddress = Row Address

	\param iAddressType = 0 = Corrected Reads
	                      1 = Raw Reads

	\param iMSBBytes = Most Significant Bytes.

	\param iLSBBytes = Least Significant Bytes

	\param iErrorCode = 0 if the operation is successful
						otherwise, return the error code from error response message (0xD) defined in Streaming Download Protocol ICD

	\return true if response packet was successfully returned, false if fail for any reason.

	\warning
	/******************************************************************************/
	/**
	Streaming Download ICD, x.x.x QFprom Write

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iRowAddress = Row Address

	\param iAddressType = 0 = Corrected Reads
	                      1 = Raw Reads

	\param iMSBBytes = Most Significant Bytes.

	\param iLSBBytes = Least Significant Bytes

	\param iErrorCode = 0 if the operation is successful
						otherwise, return the error code from error response message (0xD) defined in Streaming Download Protocol ICD

	\return true if response packet was successfully returned, false if fail for any reason.

	\warning The function must run in QPHONEMS mode

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DOWNLOAD_QFprom_Write
			(
				HANDLE hResourceContext,
				unsigned long iRowAddress, 
				unsigned long iMSBBytes, 
				unsigned long iLSBBytes, 
				unsigned long *iErrorCode			
			);
	/******************************************************************************/
	/**
	Streaming Download ICD, QEprom Read

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iRowAddress = Row Address

	\param iAddressType = 0 = Corrected Reads
	                      1 = Raw Reads

	\param iMSBBytes = Most Significant Bytes.

	\param iLSBBytes = Least Significant Bytes

	\param iErrorCode = 0 if the operation is successful
						otherwise, return the error code from error response message (0xD) defined in Streaming Download Protocol ICD
						iMSBBytes, and iLSBBytes will be returned as 0

	\return true if response packet was successfully returned, false if fail for any reason.

	\warning The function must run in QPHONEMS mode

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DOWNLOAD_QFprom_Read
			(
				HANDLE hResourceContext,
				unsigned long iRowAddress, 
				unsigned long iAddressType,
				unsigned long *iMSBBytes, 
				unsigned long *iLSBBytes, 
				unsigned long *iErrorCode			
			);

	/******************************************************************************/
	/**

	Set the state of DTR.
	This implementation is only defined with the non-QPST server version of the library

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param bSetDTR_High = true to set DTR High, false to set DTR Low
	\return Returns true if the call succeeded, false if it does not

	*******************************************************************************/
	QLIB_API unsigned char QLIB_SetDTR_State( HANDLE hResourceContext, unsigned char bSetDTR_High);

	/******************************************************************************/
	/**

	Set the state of RTS.
	This implementation is only defined with the non-QPST server version of the library

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param bSetRTS_High = true to set RTS High, false to set RTS Low
	\return Returns true if the call succeeded, false if it does not

	*******************************************************************************/
	QLIB_API unsigned char QLIB_SetRTS_State( HANDLE hResourceContext, unsigned char bSetRTS_High);

	/******************************************************************************/
	/**

	Clears the Rx buffer.

	This implementation is only defined with the non-QPST server version of the library

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return Returns true if the call succeeded, false if it does not

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FlushRxBuffer( HANDLE hResourceContext  );


	/******************************************************************************/
	/**

	Returns a NULL terminated string with the version information in the format:
		"QLIB VXX.yy.xx, <MODE>" where: XX is the major version #, yy is the sub-
		minor version, xx is the minor version number and <MODE> is either QPST or QPHONEMS,
		depending upon the library mode

		Examples:
			"QLIB V04.0.11,QPHONEMS"
			"QLIB V04.0.11,QPST"

	\param psVersion = Buffer to store the version number, 25 bytes should be reserved
	                  for this buffer.
	\return void

	*******************************************************************************/
	QLIB_API void QLIB_GetLibraryVersion( char* psVersion );

	/******************************************************************************/
	/**

	Set the library mode--QPST or QPHONEMS.  The default state of the library is to
	use QPHONEMS.  In order to use QPST, this function must be called with
	bUseQPST set to TRUE.

	\param bUseQPST = true to use QPST, false to use QPHONEMS
	\return void

	*******************************************************************************/
	QLIB_API void QLIB_SetLibraryMode( unsigned char bUseQPST );

	/******************************************************************************/
	/**

	Returns flags indicating the capabilities of the library

	\param pbSupportsDiag         = true if diag/ftm commands are supported
	\param pbSupportsEFS          = true if EFS commands are supported
	\param pbSupportsSwDownload   = true if software download commands are supported
	\param pbUsingQPST            = true if QPST is being used, false if QPHONEMS is used

	\return void

	*******************************************************************************/
	QLIB_API void QLIB_GetLibraryCapabilities(
		unsigned char* pbSupportsDiag,
		unsigned char* pbSupportsEFS,
		unsigned char* pbSupportsSwDownload,
		unsigned char* pbUsingQPST );

	/******************************************************************************/
	/**

	The function checks whether the phone is in FTM mode.

	Depending on the command code ( FTM_COMMAND_59 or FTM_COMMAND75 ),
	this function uses different methods to check for FTM mode.

	Method 1:
	If the command code is set to FTM_COMMAND_59, this function reads the NV_FTM_MODE item to check
	whether the phone is in FTM mode.

	Note that MSM6000/6025/6050 and older MSM targets use FTM_COMMAND_59 command code for FTM mode transcation.

	Method 2:
	If the command code is set to FTM_COMMAND_75, this function issues a CM state info request
	to query the phone state.  The command is CMLOG_STATE_INFO_F (refer 80-V1294-7, 3.2).

	General comment:
	The command code should be set by QLIB_FTM_SET_COMMAND_CODE function before this function is called.
	By default, the command code is FTM_COMMAND_75.

	\param pbIsFTMMode = output, true(1) if the phone is in FTM mode,
					             false(0) if the phone is not in FTM mode

	\return true if the function is successful

	*******************************************************************************/
	QLIB_API unsigned char QLIB_IsFTM_Mode(HANDLE hResourceContext, unsigned char *pbIsFTMMode);

	/******************************************************************************/
	/**

	Returns the current mode of the phone, determined by calling the Call manager status
	command, 80-V1294-7 CMLOG_STATE_INFO_F.  The field returned is OPERATIONAL_MODE

	This function is not available on AMSS which does not support the diagnostic subsystem
	commands (e.g. not available on MSM6000, MSM6025, MSM6050).

	\param piPhoneMode = output, true(1) if the phone is in FTM mode,
					             false(0) if the phone is not in FTM mode
	\code
      SYS_OPRT_MODE_PWROFF        = 0,   //!< ' Phone is powering off
      SYS_OPRT_MODE_FTM           = 1,   //!< ' Phone is in factory test mode
      SYS_OPRT_MODE_OFFLINE       = 2,   //!< ' Phone is offline
      SYS_OPRT_MODE_OFFLINE_AMPS  = 3,   //!< ' Phone is offline analog
      SYS_OPRT_MODE_OFFLINE_CDMA  = 4,   //!< ' Phone is offline cdma
      SYS_OPRT_MODE_ONLINE        = 5,   //!< ' Phone is online
      SYS_OPRT_MODE_LPM           = 6,   //!< ' Phone is in LPM - Low Power Mode
      SYS_OPRT_MODE_RESET         = 7,   //!< ' Phone is resetting - i.e. power-cycling
      SYS_OPRT_MODE_NET_TEST_GW   = 8,   //!< ' Phone is conducting network test for GSM/WCDMA.
      SYS_OPRT_MODE_OFFLINE_IF_NOT_FTM = 9, //!< ' offline request during powerup.
      SYS_OPRT_MODE_PSEUDO_ONLINE = 10, //!< ' Phone is pseudo online, tx disabled
	\endcode

	\return true if the function is successful

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GetPhoneOperatingMode(HANDLE hResourceContext, unsigned long *piPhoneMode);

	/******************************************************************************/
	/**

	Returns the call status the phone, determined by calling the Call manager status
	command, 80-V1294-7 CMLOG_STATE_INFO_F.  The fields returned are
	OVERALL_CALL_STATE and SYSTEM_MODE

	Note 1: This function is not available on AMSS which does not support the diagnostic subsystem
	commands (e.g. not available on MSM6000, MSM6025, MSM6050).


	Note 2: this function will not return meaningful results for GSM and WCDMA.  Use QLIB_DIAG_GSM_STATUS_F()
	for these modes.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piPhoneMode = output, true(1) if the phone is in FTM mode,
					             false(0) if the phone is not in FTM mode
	\code
      CM_CALL_STATE_NONE       = -1,     //!< 'FOR INTERNAL USE OF CM ONLY!
      CM_CALL_STATE_IDLE       = 0,      //!< ' Call is in idle state - i.e. no call
      CM_CALL_STATE_ORIG       = 1,      //!< ' Call is in origination state
      CM_CALL_STATE_INCOM      = 3,      //!< ' Call is in alerting state
      CM_CALL_STATE_CC_IN_PROGRESS = 4,  //!< ' Call is originating but waiting for call control to complete
      CM_CALL_STATE_CONV       = 5,      //!< ' Call is in conversation state
	\endcode

	\param piSystemMode = output, system mode
	\code
       SYS_SYS_MODE_NONE    = -1, //!< ' FOR INTERNAL USE ONLY!
       SYS_SYS_MODE_NO_SRV  = 0, //!< ' No service = NV_MODE_INACTIVE
       SYS_SYS_MODE_AMPS    = 1, //!< ' Analog Mobile Phone System (AMPS) mode
       SYS_SYS_MODE_CDMA    = 2, //!< ' Code Division Multiple Access (CDMA) mode
       SYS_SYS_MODE_GSM     = 3, //!< ' Global System for Mobile communications (GSM) mode
       SYS_SYS_MODE_HDR     = 4, //!< ' High Data Rate (HDR) mode
       SYS_SYS_MODE_WCDMA   = 5, //!< ' Wideband CDMA (WCDMA) mode
       SYS_SYS_MODE_GPS     = 6, //!< ' Global Positioning System (GPS) mode
       SYS_SYS_MODE_GW      = 7, //!< ' GSM and WCDMA mode

	\endcode

	\return true if the function is successful

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GetPhoneCallState(
		HANDLE hResourceContext,
		unsigned long *piCallState,
		unsigned long *piSystemMode);

	/******************************************************************************/
	/**

	Returns the call status the phone, determined by calling the Call manager status
	command, 80-V1294-7 Rev. H CMLOG_STATE_INFO_F2.  The fields returned are
	OVERALL_CALL_STATE and SYSTEM_MODE

	Note 1: This function is not available on AMSS which does not support the diagnostic subsystem
	commands CMLOG_STATE_INFO_F2.

	Note 2: this function will not return meaningful results for GSM and WCDMA.  Use QLIB_DIAG_GSM_STATUS_F()
	for these modes.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param piPhoneMode = output, true(1) if the phone is in FTM mode,
					             false(0) if the phone is not in FTM mode
	\code
      CM_CALL_STATE_NONE       = -1,     //!< 'FOR INTERNAL USE OF CM ONLY!
      CM_CALL_STATE_IDLE       = 0,      //!< ' Call is in idle state - i.e. no call
      CM_CALL_STATE_ORIG       = 1,      //!< ' Call is in origination state
      CM_CALL_STATE_INCOM      = 3,      //!< ' Call is in alerting state
      CM_CALL_STATE_CC_IN_PROGRESS = 4,  //!< ' Call is originating but waiting for call control to complete
      CM_CALL_STATE_CONV       = 5,      //!< ' Call is in conversation state
	\endcode

	\param piSystemMode = output, system mode
	\code
       SYS_SYS_MODE_NONE    = -1, //!< ' FOR INTERNAL USE ONLY!
       SYS_SYS_MODE_NO_SRV  = 0, //!< ' No service = NV_MODE_INACTIVE
       SYS_SYS_MODE_AMPS    = 1, //!< ' Analog Mobile Phone System (AMPS) mode
       SYS_SYS_MODE_CDMA    = 2, //!< ' Code Division Multiple Access (CDMA) mode
       SYS_SYS_MODE_GSM     = 3, //!< ' Global System for Mobile communications (GSM) mode
       SYS_SYS_MODE_HDR     = 4, //!< ' High Data Rate (HDR) mode
       SYS_SYS_MODE_WCDMA   = 5, //!< ' Wideband CDMA (WCDMA) mode
       SYS_SYS_MODE_GPS     = 6, //!< ' Global Positioning System (GPS) mode
       SYS_SYS_MODE_GW      = 7, //!< ' GSM and WCDMA mode
	SYS_SYS_MODE_WLAN	 = 8,		 //!< ' WLAN mode
	SYS_SYS_MODE_LTE	 = 9,		 //!< ' LTE
	SYS_SYS_MODE_GWL		 = 10,	 //!< ' GSM, WCDMA and LTE mode

	\endcode

	\return true if the function is successful

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GetPhoneCallState_V2(
		HANDLE hResourceContext,
		unsigned long *piCallState,
		unsigned long *piSystemMode);

	/******************************************************************************/
	/**

	The function changes phone to FTM or ONLINE mode through NV item NV_FTM_MODE method.

	This function:

	1. Changes phone to offline mode (QLIB_DIAG_CONTROL_F(MODE_OFFLINE_F))
	2. Delays by the timeout value QMSL_Timeout_Delay_OFFLINE, which can be set wiht
	   QLIB_ConfigureTimeout()
	2. Writes bFTMmode value to NV item NV_FTM_MODE (453)

	If (bReset == 1), the function returns immediately after reset command is issued.

	\param bFTMMode = (1 = FTM mode), (0 = ONLINE mode)
	\param bReset = (1 = Reset after NV write), (0 = No reset after NV write)

	\return true if the function is successful

	*******************************************************************************/
	QLIB_API unsigned char QLIB_ChangeFTM_BootMode(HANDLE hResourceContext, unsigned char bFTMmode, unsigned char bReset);

	/******************************************************************************/
	/**

	The function changes the mode to ONLINE or FTM mode using run time method

	The function calls IsFTM_Mode to determines the phone is in FTM mode or not.

	If current mode is not equal to bFTMmode, it will switch mode.

	General comment:
	This function can't be used in MSM6000/6025/6050 and older MSM targets.  As they
	use FTM_COMMAND_59 command code for FTM and DO NOT support runtime swtiching to FTM

	The command code should be set to FTM_COMMAND_75 by QLIB_FTM_SET_COMMAND_CODE function
	before this function is called.

	By default, the command code is FTM_COMMAND_75.

	\param bFTMMode = (1 = FTM mode), (0 = ONLINE mode)

	\return true if the function is successful

	*******************************************************************************/
	QLIB_API unsigned char QLIB_ChangeFTM_ModeRuntime(HANDLE hResourceContext, unsigned char bFTMmode);

	/******************************************************************************/
	/**

	The function stores a 32-bit number that is to be associated with the QMSL resource
	context.  The purpose is so that client software callback functions can identify
	the client context from in the QMSL callback has been generated.

	\param iToken = input, a 32-bit number that is meaningful to the client software.
	                This value is not evaluated by QMSL.

	\return true if the function is successful

	*******************************************************************************/
	QLIB_API unsigned char QLIB_SetClientToken(HANDLE hResourceContext, unsigned long iToken );

	/******************************************************************************/
	/**

	The function returns the token stored by QLIB_GetClientToken().

	The token is a 32-bit number that is to be associated with the QMSL resource
	context.  The purpose is so that client software callback functions can identify
	the client context from in the QMSL callback has been generated.

	\param piToken = output, a pointer to a 32-bit number that is meaningful to the client software.
	                 This value is not evaluated by QMSL.  If QLIB_SetClientToken() has not been
					 called the value will be zero

	\return true if the function is successful.  Returns false if unsuccessful or
	        if the token value==0

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GetClientToken(HANDLE hResourceContext, unsigned long *piToken );

/******************************************************************************
					Text Logging
*******************************************************************************/

	/******************************************************************************/
	/**

	Function to start logging send/receive data information to a text file.  After calling this
	function, the log file will remain open until the ClosePort() or DisconnectServer()
	operations are called.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sLogfile = path to log file that will be created

	\return True if file is opened successfully.


	\warning This function will reset any DLF files that are currently being logged.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_StartLogging( HANDLE hResourceContext, char* sLogFile );

	/******************************************************************************/
	/**

	Function to Stop text logging

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return True if file is opened successfully.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_StopLogging( HANDLE hResourceContext );


	/******************************************************************************/
	/**

	Function to check if text logging is started. Text logging may stop if ClosePort() or DisconnectServer
	is called. Use this function to check the logging status, restart if needed.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return True if logging is started

	*******************************************************************************/
	QLIB_API unsigned char QLIB_IsLoggingStarted( HANDLE hResourceContext  );

	/******************************************************************************/
	/**

	Function to start logging send/receive data information to a DLF file.  After calling this
	function, the log file will remain open until the ClosePort() or DisconnectServer()
	operations are called.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sLogfile = path to log file that will be created.  Extension .DLF should be specified
	\param bAlwaysUsePC_Time = TRUE to always use PC time in the log stamps for the DLF entries.

	                           If FALSE then time will be determined from the mobile's time stamp
							   after an async messasge (log, event, debug message) has been received.
							   Currently this behavior is disabled and DLF entries are always made
							   with the the PC time.

	\return True if file is opened successfully.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_StartDLF_Logging(
			HANDLE hResourceContext,
			char* sLogFile,
			unsigned char bAlwaysUsePC_Time );


	/******************************************************************************/
	/**

	Function to Stop DLF logging

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return True if file is opened successfully.

	\warning Function is not implement

	*******************************************************************************/
	QLIB_API unsigned char QLIB_StopDLF_Logging( HANDLE hResourceContext );


	/******************************************************************************/
	/**

	Function to annotate DLF file, which adds a log entry into the DLF file that
	will show up in the DLF Viewer as an "Annotation". The contents of the
	annotation are a user defined string.  This can be very useful for
	putting algorithm markers into the log file, which can later be compared with the
	mobile messages.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sAnnotation = string to add into the DLF log. This will be added to the DLF as an "ANNOTATION" type of log
	                     and can be filtered by the DLF viewer

	\return True if file is opened successfully.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_AnnotateDLF_Log(
			HANDLE hResourceContext,
			char* sAnnotation
			);

	/******************************************************************************/
	/**

	Load the asynchronous messages from a DLF into the QMSL "Log queue", which holds
	asynchronous messages from the mobile.  After this command is called then other
	functions for managing the async queue can be called, such as QLIB_DIAG_ClearPhoneLogQueue(),
	QLIB_DIAG_GetPhoneLogQueueSize(), and QLIB_DIAG_GetNextPhoneLog().


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sDLF_File = File name of the ".DLF "log file to parse

	\return true if file is found and response data is added to the playback queue

	\warning the async queues should be cleared before this command is called, using QLIB_DIAG_ClearPhoneLogQueue()

	*******************************************************************************/
	QLIB_API unsigned char QLIB_Playback_DLF(
								HANDLE hResourceContext,
								const char* sLogFile
											);

	/******************************************************************************/
	/**

	Function to set log level for text logging (not the same as log records from the phone).

	Log levels are treated as flags and can be added:
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param uiLogFlags = Mask for text log
	\code
	LOG_NOTHING		0x0000	= log nothing

	LOG_IO          0x0001	= data IO (data bytes)
	LOG_FN          0x0002	= function calls with parameters
	LOG_RET         0x0004	= function return data
	LOG_INF         0x0008	= general information (nice to know)
	LOG_ERR         0x0010	= critcial error information

	LOG_C_HIGH_LEVEL_START  0x0200 = High level C function start, indicates the begining of a high level C function, which
	                                 calls other low level C functions internal to the library

	LOG_C_HIGH_LEVEL_STOP   0x4000 = High level C function stop

	LOG_IO_AHDLC    0x0020	= HDLC IO tracing (data bytes)
	LOG_FN_AHDLC    0x0040	= HDLC layer function calls
	LOG_RET_AHDLC   0x0080	= HDLC function return data
	LOG_INF_AHDLC   0x0100	= HDLC general information

	LOG_IO_DEV      0x0400	= device IO tracing (data bytes)
	LOG_FN_DEV      0x0800	= device layer function calls
	LOG_RET_DEV     0x1000	= device function return data
	LOG_INF_DEV     0x2000	= device general information

	LOG_DEFAULT     ( LOG_IO | LOG_ERR | LOG_ERR_AHDLC | LOG_ERR_DEV )

	LOG_ALL			0xFFFF	// everything
	\endcode

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param uiLogFlags = log flags as listed above

	\return True if file is opened successfully.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_SetLogFlags( HANDLE hResourceContext, unsigned int uiLogFlags );

	/******************************************************************************/
	/**

	Function to actvate/deactivate an extended text message category.

	This is used to enable verbose text messages, which can be used for troubleshooting.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param eMessageCategory = enumeration value of the message category to be enabled.
	                           Uses the QMSL_Extended_Text_Message_Category_Enum, in QLib_Defines.h.


	\code
       QMSL_ExtTextMsgCat_MediaFLO_Parse         = 0,  //!< ' MediaFLO Layer one log parsing
       QMSL_ExtTextMsgCat_cdma2000_RDA_Parse     = 1   //!< ' cdma2000 RDA log parsing for SER/FER
	   QMSL_ExtTextMsgCat_NV_Manager_Debug		 = 2,  //!< ' NV Manager Debug Message
	   QMSL_ExtTextMsgCat_NV_Tool_Debug		     = 3,   //!< ' NV Tool Debug Message
	   QMSL_ExtTextMsgCat_QPHONEMS_SW_Download   = 4    //!< ' QPHONEMS Software Download

	\endcode
	\param bEnableCategory = TRUE to enable the message category, FALSE to disable it

	\return True if file is opened successfully.


	*******************************************************************************/
	QLIB_API unsigned char QLIB_ExtendedTextMessage_SetCategoryEnable(
								HANDLE hResourceContext,
								unsigned short eMessageCategory,
								unsigned char bEnableCategory
								);

	/******************************************************************************/
	/**

	Function to get the size of the extended text message category list.  This can be used before
	calling QLIB_GetExtetendedTextMessageCategoryListItem(), in order to determine the
	list size, in case the memory must be allocated in the client.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piListSize = Output, stores the number of extended text message categories

	\return True if file is opened successfully.


	*******************************************************************************/
	QLIB_API unsigned char QLIB_ExtendedTextMessage_GetCategoryListSize(
								HANDLE hResourceContext,
								unsigned short* piListSize
								);

	/******************************************************************************/
	/**

	Function retreive one element in the extended text message category list.
	The element values are a string with the name of the item and an enable/disable status

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param eMessageCategory = Input, enumeration value of the message category to be enabled.
	                           Uses the QMSL_Extended_Text_Message_Category_Enum, in QLib_Defines.h.
	\param sCategoryName = Output, stores the number of extended text message category indexed
	                       by eMessageCategory.  Must be QMSL_EXTENDED_TEXT_MESSAGE_CATEGORY_NAME_SIZE
						   bytes reserved, including NULL termination.

						   If sCategoryName is NULL, then no action is taken and only the
						   bEnabled value will be updated.
	\param pbEnabled = Output, TRUE if the category is enabled, FALSE if it is not.

	\return True if file is opened successfully.


	*******************************************************************************/
	QLIB_API unsigned char QLIB_ExtendedTextMessage_GetCategoryListItem(
								HANDLE hResourceContext,
								unsigned short eMessageCategory,
								char* sCategoryName,
								unsigned char* pbEnabled
								);

	/******************************************************************************
						LTE Diag
	*******************************************************************************/

	/******************************************************************************/
	/**
	Enable/Disable Rx chain for LTE (document pending).

	When this command is called, a particular Rx chain described by iLTERxChainType is enabled/disabled.
	The status are reset upon power cycle.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iLTERxChainType =	Action; possible values are:
							0 = no action;
							1 = Enable Rx0 only
							2 = enable Rx1 only
							3 = enable Rx0 and Rx1
							4 = no action
							5 = disable Rx0 only
							6 = disable Rx1 only
							7 = disable Rx 0 and Rx1.
	\code
		typedef enum
		{
		   _LTE_RX_CHAIN_TYPE_NO_ACTION = 0,
		   _LTE_RX_CHAIN_TYPE_ENABLE_RX0_ONLY = 1,
		   _LTE_RX_CHAIN_TYPE_ENABLE_RX1_ONLY = 2,
		   _LTE_RX_CHAIN_TYPE_ENABLE_RX0_AND_RX1 = 3,
		   _LTE_RX_CHAIN_TYPE_NO_ACTION2 = 4,
		   _LTE_RX_CHAIN_TYPE_DISABLE_RX0_ONLY = 5,
		   _LTE_RX_CHAIN_TYPE_DISABLE_RX1_ONLY = 6,
		   _LTE_RX_CHAIN_TYPE_DISABLE_RX0_AND_RX1 = 7,
		   _LTE_RX_CHAIN_TYPE_END_OF_ENUM
		}lte_rx_chain_type_enum_type;

	\endcode

	\return true if successful, false if fail.

	\warning
		1.	After LTE sends RX tuning request to RF driver, this diag commands can be sent to enable/disable a specific chain.
		2.	Note that the diag command can only be sent when RF driver RX is tuned. This is a requirement from the RF S/W side.;
			in another word, this command should be sent after phone goes to traffic state

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_LTE_RX_TOOL_CHAIN_COMMAND( HANDLE hResourceContext, unsigned char iLTERxChainType);



	/******************************************************************************
						HDR Diag
	*******************************************************************************/

	/******************************************************************************/
	/**
	Set/Get Dip switch for HDR subsystem (80-V1294-2 2.2.3 DIP Switch request/response)

	When the DM sends a DIP switch request message, the DMSS responds by sending a DIP switch
	response message to the DM that contains the current setting of the switches. Each bit is the value
	of a single switch. The DIP switches are reset upon power cycle.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iAction	=	Action; possible values are:
						0 = Reset DIP switch
						1 = Set DIP switch
						2 = Clear all DIP switches
						3 = Read DIP switch mask

	\param  iDipSwitchBit = DIP switch bit to set or reset (only valid if iAction = 0,1)
						   Refer to 80-V1294-2 table 2.2 for a list of implemented DIP switches.

	\param piDipSwitchMask = A pointer to DIP switch mask returned from DIP SWITCH response message

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_HDR_DIAG_DIP_SWITCH( HANDLE hResourceContext, unsigned char iAction, unsigned char iDipSwitchBit, unsigned long * piDipSwitchMask );


	/******************************************************************************/
	/**
	Reset forward statistics counter for HDR subsystem (80-V1294-2 5.3.119)

	Upon reception of the reset packet, the DMSS would reset all forward statistics counters to zero.
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\note this function should be used every time QLIB_FTM_EVDO_NS_EnableMeasurementLogs() is used for throughput statistics:
			Release 0 throughput: EVDO_FORWARD_LINK_STATISTICS_SUMMARY 0x1084
			Revision A throughput: EVDO_REVA_SU_FWDSTATS	0x1192

	\return true if successful, false if fail.
	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_EVDO_RST_FWD_STATS( HANDLE hResourceContext );


/******************************************************************************
					GSM Diag
*******************************************************************************/

	/******************************************************************************/
	/**
	GSM Diagnostic IC, 3.2.2/3 Status Request/Response

	  Get the GSM Call status

		\param aiIMEI[9] = First byte is length (0 to 15), Next 8 bytes are packed BCD
				#define GSM_DIAG_IMEI_SIZE  9

		\param aiIMSI[9] = First byte is length (0 to 15), Next 8 bytes are packed BCD
				#define GSM_DIAG_IMSI_SIZE  9

		\param aiLAI[5] = Location area ID. Format:  3bytes, Public Land Mobile Network Identity, 2bytes Location Area Code
				#define GSM_DIAG_LAI_SIZE   5

		\param piCellID = Cell identity
		\param piCM_CallState = refer to enumeration gsm_call_state_enum:
			\code
              GSM_STATUS_CALL_STATE_NONE           =-1, //!< ' not defined
              GSM_STATUS_CALL_STATE_IDLE           = 0, //!< ' IDLE
              GSM_STATUS_CALL_STATE_ORIG           = 1, //!< ' Originating
              GSM_STATUS_CALL_STATE_WAITING        = 2, //!< ' Waiting
              GSM_STATUS_CALL_STATE_INCOM          = 3, //!< ' Incoming
              GSM_STATUS_CALL_STATE_CC_IN_PROGRESS = 4, //!< ' Concurrent incoming/originating
              GSM_STATUS_CALL_STATE_CONV           = 5  //!< ' Conversation
			\endcode
		\param piCM_OperationalMode = refer to enumeration sys_oprt_mode_enum:
			\code
               SYS_OPRT_MODE_NONE	= -1,				-  FOR INTERNAL USE OF CM ONLY!
               SYS_OPRT_MODE_PWROFF	= 0,				-  Phone is powering off
               SYS_OPRT_MODE_FTM		= 1,			-  Phone is in factory test mode
               SYS_OPRT_MODE_OFFLINE	= 2,			-  Phone is offline
               SYS_OPRT_MODE_OFFLINE_AMPS = 3,			-  Phone is offline analog
               SYS_OPRT_MODE_OFFLINE_CDMA = 4,			-  Phone is offline cdma
               SYS_OPRT_MODE_ONLINE = 5,				-  Phone is online
               SYS_OPRT_MODE_LPM = 6,					-  Phone is in LPM - Low Power Mode
               SYS_OPRT_MODE_RESET = 7,					-  Phone is resetting - i.e. power-cycling
               SYS_OPRT_MODE_NET_TEST_GW = 8,			-  Phone is conducting network test for GSM/WCDMA.
               SYS_OPRT_MODE_OFFLINE_IF_NOT_FTM = 9,	-  offline request during powerup.
               SYS_OPRT_MODE_PSEUDO_ONLINE = 10,		-  Phone is pseudo online, tx disabled

			\endcode
		\param piCM_SystemMode = refer to enumeration for sys_sys_mode_enum:
			\code
               SYS_SYS_MODE_NONE	= -1,		//!< ' FOR INTERNAL USE ONLY!
               SYS_SYS_MODE_NO_SRV	= 0,		//!< ' No service = NV_MODE_INACTIVE
               SYS_SYS_MODE_AMPS	= 1,		//!< ' Analog Mobile Phone System (AMPS) mode
               SYS_SYS_MODE_CDMA	= 2,		//!< ' Code Division Multiple Access (CDMA) mode
               SYS_SYS_MODE_GSM		= 3,		//!< ' Global System for Mobile communications (GSM) mode
               SYS_SYS_MODE_HDR		= 4,		//!< ' High Data Rate (HDR) mode
               SYS_SYS_MODE_WCDMA	= 5,		//!< ' Wideband CDMA (WCDMA) mode
               SYS_SYS_MODE_GPS		= 6,		//!< ' Global Positioning System (GPS) mode
               SYS_SYS_MODE_GW		= 7,		//!< ' GSM and WCDMA mode
               SYS_SYS_MODE_MAX					//!< ' FOR INTERNAL USE ONLY!
			\endcode

	\return true if response packet was successfully returned, false if fail for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GSM_STATUS_F(
					HANDLE hResourceContext,
					unsigned char iIMEI[9], unsigned char aiIMSI[9],
					unsigned char aiLAI[5],  unsigned short* piCellID, unsigned char* piCM_CallState,
					unsigned char* piCM_OperationalMode, unsigned char* piCM_SystemMode );


	/******************************************************************************/
	/**
	GSM Diagnostic IC, 3.2.7/8 Call origination request/response

	  Originate a call from the mobile

		\param iNumDigits = number of digits in the IMSI
		\param aiIMSI = array of IMSI digits to dial
							#define GSM_DIAG_CALL_ORG_IMSI_SIZE 32 = # of digits
						IMSI characters are in the ASCII format, for example 0x35 for '5'

	\return true if response packet was successfully returned, false if fail for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GSM_CALL_ORIG_F( HANDLE hResourceContext, unsigned char iNumDigits, unsigned char aiIMSI[32] );


	/******************************************************************************/
	/**
	GSM Diagnostic IC, 3.2.9/10 Call end request/response

	  End the currently active call

	\return true if response packet was successfully returned, false if fail for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GSM_CALL_END_F( HANDLE hResourceContext );

/******************************************************************************
					Streaming Download Diag
*******************************************************************************/

	/******************************************************************************/
	/**
	Streaming Download ICD, 3.2.1 19 Hello packet, A specialized version of this
	command, to be used as a method to PING a phone in download mode.

	Call DOWNLOAD_Hello with default parameters.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if response packet was successfully returned, false if fail for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DOWNLOAD_Ping( HANDLE hResourceContext );



/******************************************************************************
						Diagnostic commands
*******************************************************************************/


	/******************************************************************************/
	/**
	DMSS Diagnostic ICD, 3.4.38 Mode Change Request/Response
	WCDMA Diagnostic ICD, 3.5.23 Mode Change Request/Response

	Changes the current system state.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param eMode = Defined by mode_enum_type in QLib_Defines.h
	\code
        MODE_OFFLINE_A_F = 0,    //!<' Go to offline analog
        MODE_OFFLINE_D_F = 1,    //!<' Go to offline digital
        MODE_RESET_F = 2,        //!<' Reset. Only exit from offline
        MODE_FTM_F = 3,          //!<' FTM mode
        MODE_ONLINE_F = 4,       //!<' Go to Online
        MODE_LPM_F = 5,          //!<' Low Power Mode (if supported)
        MODE_POWER_OFF_F = 6,    //!<' Power off (if supported)
        MODE_MAX_F = 7           //!<' Last (and invalid) mode enum value

	\endcode

	\return Returns true if the phone mode change executed correctly,
	see below warning for the return value for certain phone modes.

	\warning,  If the new mode is one of the following modes:
		MODE_FTM_F,
		MODE_ONLINE_F,
		MODE_OFFLINE_A_F,
		MODE_OFFLINE_D_F,
	the following actions will be performed after the command is successfully sent to the mobile.

	1. if the delay of the following types (associated with the desired eMode) has a value greater than 0,
		QMSL_Timeout_Delay_ONLINE_FTM
		QMSL_Timeout_Delay_ONLINE
		QMSL_Timeout_Delay_OFFLINE
	the delay for the desired mode will be issued.

	2. if the FTM command code is FTM_COMMAND_75:
	QLIB_GetPhoneOperatingMode() will be called to read the phone mode back.
	If the mode doesn't match with the desired mode, a 100 ms delay will be issued,
	and the status polling will continue until the mode matches,
	or the QMSL_Timeout_Runtime_Mode_Switching timer expires.

	the return value will be true only if the phone mode read back matches with the desired
	phone mode within the timeout of QMSL_Timeout_Runtime_Mode_Switching

	if the FTM command code is FTM_COMMAND_59:
	an extra fixed delay of QMSL_Timeout_Runtime_Mode_Switching will be issued( if it has a value greater than 0).
	the phone mode will not be read back, thus the return value will not be updated based on mode matching.

	The delay and timeout can be controled by QLIB_ConfigureTimeOut() and read by QLIB_GetTimeOut()
	with coresponding timeout ID.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_CONTROL_F(HANDLE hResourceContext, int eMode );


	/******************************************************************************/
	/**

	DMSS ICD, 3.4.35 Nonvolatile Item Read Request/Response
	WCDMA Diagnostic ICD, 3.5.23 Mode Change Request/Response

	Read an NV Item


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  item_id   = Enumeration ID of NV Item
	\param  pItemData = Reference to storage area for data
	\param	iLength   = size of data, in bytes
	\param  iStatus   = Reference to storage area for status
	\code
     NV_DONE_S = 0,      // Request completed okay
     NV_BUSY_S = 1,      // Request is queued
     NV_BADCMD_S = 2,    // Unrecognizable command field
     NV_FULL_S = 3,      // The NVM is full
     NV_FAIL_S = 4,      // Command failed, reason other than NVM was full
     NV_NOTACTIVE_S = 5, // Variable was not active
     NV_BADPARM_S = 6,   // Bad parameter in command block
     NV_READONLY_S = 7,  // Parameter is write-protected and thus read only
     NV_BADTG_S = 8,     // Item not valid for Target
     NV_NOMEM_S = 9,     // free memory exhausted
     NV_NOTALLOC_S = 10  // address is not a valid allocation

	\endcode

	\return true if successful, false if fail.

	\warning None.

	*******************************************************************************/
	QLIB_API unsigned char  QLIB_DIAG_NV_READ_F
		(HANDLE hResourceContext, unsigned short iItemID, unsigned char* pItemData, int iLength, unsigned short* iStatus);

	/******************************************************************************/
	/**

	DMSS ICD, 3.4.35 Nonvolatile Item Read Request/Response
	WCDMA Diagnostic ICD, 3.5.23 Mode Change Request/Response

	Read an NV Item for Dual SIM devices


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  item_id   = Enumeration ID of NV Item
	\param  pItemData = Reference to storage area for data
	\param  iContextID = ID of SIM index NV Item pertains to ( 0 or 1)
	\param	iLength   = size of data, in bytes
	\param  iStatus   = Reference to storage area for status
	\code
     NV_DONE_S = 0,      // Request completed okay
     NV_BUSY_S = 1,      // Request is queued
     NV_BADCMD_S = 2,    // Unrecognizable command field
     NV_FULL_S = 3,      // The NVM is full
     NV_FAIL_S = 4,      // Command failed, reason other than NVM was full
     NV_NOTACTIVE_S = 5, // Variable was not active
     NV_BADPARM_S = 6,   // Bad parameter in command block
     NV_READONLY_S = 7,  // Parameter is write-protected and thus read only
     NV_BADTG_S = 8,     // Item not valid for Target
     NV_NOMEM_S = 9,     // free memory exhausted
     NV_NOTALLOC_S = 10  // address is not a valid allocation

	\endcode

	\return true if successful, false if fail.

	\warning None.

	*******************************************************************************/
	QLIB_API unsigned char  QLIB_DIAG_NV_READ_EXT_F
		(HANDLE hResourceContext, unsigned short iItemID, unsigned char* pItemData, unsigned short iContextID, int iLength, unsigned short* iStatus);

	/******************************************************************************/
	/**

	DMSS ICD, 3.4.35 Nonvolatile Item Read Request/Response
	WCDMA Diagnostic ICD, 3.5.23 Mode Change Request/Response

	Read an NV Item--this version handles NV array items


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  item_id   = Enumeration ID of NV Item
	\param	iArrayIndex =  Index within NV array
	\param  pItemData = Reference to storage area for data
	\param	iLength   = size of data, in bytes
	\param  iStatus   = Reference to storage area for status
	\code
     NV_DONE_S = 0,      // Request completed okay
     NV_BUSY_S = 1,      // Request is queued
     NV_BADCMD_S = 2,    // Unrecognizable command field
     NV_FULL_S = 3,      // The NVM is full
     NV_FAIL_S = 4,      // Command failed, reason other than NVM was full
     NV_NOTACTIVE_S = 5, // Variable was not active
     NV_BADPARM_S = 6,   // Bad parameter in command block
     NV_READONLY_S = 7,  // Parameter is write-protected and thus read only
     NV_BADTG_S = 8,     // Item not valid for Target
     NV_NOMEM_S = 9,     // free memory exhausted
     NV_NOTALLOC_S = 10  // address is not a valid allocation

	\endcode

	\return true if successful, false if fail.

	\warning None.

	*******************************************************************************/
	QLIB_API unsigned char  QLIB_DIAG_NV_READ_ARRAY_F
		(HANDLE hResourceContext, unsigned short iItemID, unsigned char iArrayIndex, unsigned char* pItemData, int iLength, unsigned short* iStatus);

	/******************************************************************************/
	/**

	DMSS ICD, 3.4.36 Nonvolatile Item Write Request/Response
	WCDMA Diagnostic ICD, 3.5.22 Nonvolatile Item Write Request/Response

	Write an NV Item


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iItemID  = ID of NV Item
	\param  pItemData = Reference to storage area for data
	\param	iLength = size of data, in bytes
	\param  iStatus = Reference to storage area for status
	\code
     NV_DONE_S = 0,      // Request completed okay
     NV_BUSY_S = 1,      // Request is queued
     NV_BADCMD_S = 2,    // Unrecognizable command field
     NV_FULL_S = 3,      // The NVM is full
     NV_FAIL_S = 4,      // Command failed, reason other than NVM was full
     NV_NOTACTIVE_S = 5, // Variable was not active
     NV_BADPARM_S = 6,   // Bad parameter in command block
     NV_READONLY_S = 7,  // Parameter is write-protected and thus read only
     NV_BADTG_S = 8,     // Item not valid for Target
     NV_NOMEM_S = 9,     // free memory exhausted
     NV_NOTALLOC_S = 10  // address is not a valid allocation

	\endcode

	\return true if successful, false if fail.

	\warning None.

	*******************************************************************************/
	QLIB_API unsigned char  QLIB_DIAG_NV_WRITE_F
		(HANDLE hResourceContext, unsigned short iItemID, unsigned char* pItemData, int iLength, unsigned short* iStatus);

	/******************************************************************************/
	/**

	DMSS ICD, 3.4.36 Nonvolatile Item Write Request/Response
	WCDMA Diagnostic ICD, 3.5.22 Nonvolatile Item Write Request/Response

	Write an NV Item for Dual DIM devices


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iItemID  = ID of NV Item
	\param  pItemData = Reference to storage area for data
	\param  iContextID = ID of SIM index NV Item pertains to ( 0 or 1)
	\param	iLength = size of data, in bytes
	\param  iStatus = Reference to storage area for status
	\code
     NV_DONE_S = 0,      // Request completed okay
     NV_BUSY_S = 1,      // Request is queued
     NV_BADCMD_S = 2,    // Unrecognizable command field
     NV_FULL_S = 3,      // The NVM is full
     NV_FAIL_S = 4,      // Command failed, reason other than NVM was full
     NV_NOTACTIVE_S = 5, // Variable was not active
     NV_BADPARM_S = 6,   // Bad parameter in command block
     NV_READONLY_S = 7,  // Parameter is write-protected and thus read only
     NV_BADTG_S = 8,     // Item not valid for Target
     NV_NOMEM_S = 9,     // free memory exhausted
     NV_NOTALLOC_S = 10  // address is not a valid allocation

	\endcode

	\return true if successful, false if fail.

	\warning None.

	*******************************************************************************/
	QLIB_API unsigned char  QLIB_DIAG_NV_WRITE_EXT_F
		(HANDLE hResourceContext, unsigned short iItemID, unsigned char* pItemData, unsigned short iContextID, int iLength, unsigned short* iStatus);

	/******************************************************************************/
	/**

	DMSS ICD, 3.4.36 Nonvolatile Item Write Request/Response
	WCDMA Diagnostic ICD, 3.5.22 Nonvolatile Item Write Request/Response

	Write an NV Item--this version handles NV array items

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iItemID  = ID of NV Item
	\param	iArrayIndex =  Index within NV array
	\param  pItemData = Reference to storage area for data
	\param	iLength = size of data, in bytes
	\param  iStatus = Reference to storage area for status
	\code
     NV_DONE_S = 0,      // Request completed okay
     NV_BUSY_S = 1,      // Request is queued
     NV_BADCMD_S = 2,    // Unrecognizable command field
     NV_FULL_S = 3,      // The NVM is full
     NV_FAIL_S = 4,      // Command failed, reason other than NVM was full
     NV_NOTACTIVE_S = 5, // Variable was not active
     NV_BADPARM_S = 6,   // Bad parameter in command block
     NV_READONLY_S = 7,  // Parameter is write-protected and thus read only
     NV_BADTG_S = 8,     // Item not valid for Target
     NV_NOMEM_S = 9,     // free memory exhausted
     NV_NOTALLOC_S = 10  // address is not a valid allocation

	\endcode

	\return true if successful, false if fail.

	\warning None.

	*******************************************************************************/
	QLIB_API unsigned char  QLIB_DIAG_NV_WRITE_ARRAY_F
		(HANDLE hResourceContext, unsigned short iItemID, unsigned char iArrayIndex,
		 unsigned char* pItemData, int iLength, unsigned short* iStatus);

	/******************************************************************************/
	/**

	Activates a batch mode for performing NV Write operations.  In this
	mode each call to QLIB_DIAG_NV_WRITE_F and QLIB_DIAG_NV_WRITE_ARRAY_F will be
	queued in the PC's RAM and will not be written immediately to the phone.  This is
	done in order to take advantage of the multiple-NV write operation, which will
	be invoked when the DIAG_NV_WRITE_FlushBatchQueue() command is called.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param bStartBatchMode = true to activate NV Write batch mode, false to stop it.

	\return true if successful, false if fail.

	\warning After this function is completed, the batch mode will be disabled, and must be
	         restarted with a call to DIAG_NV_WRITE_SetBatchMode.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_NV_WRITE_SetBatchMode( HANDLE hResourceContext, unsigned char bStartBatchMode );

	/******************************************************************************/
	/**

	Allows the user to specify a list of NV items that can be read-only.  When
	the batch queue is flushed, if these NV items fail because the field is
	read-only, then the command will not fail.

	An example of a field that can be read-only is #571, NV_RF_CAL_DATE_I

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param aiNvIdList = Array of NV Item ID numbers.

	\param iListSize = number of items in the NV Item ID list.

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_NV_WRITE_BatchQueue_SetRO_List(
							HANDLE hResourceContext,
							unsigned short* aiNvIdList,
							unsigned short iListSize);

	/******************************************************************************/
	/**

	Flushes all NV write requests that have been queued since the last time that
	QLIB_DIAG_NV_WRITE_SetBatchMode().  Uses the multiple NV Write operation to optimize
	the NV write time.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piLastErrorNvId = the ID of the last NV item that had an error.  If no error,
	                      then it will be a value of NV_WRITE_BATCH_ITEM_NO_ERROR, -1

	\param piLastTotalStatus = return value of the entire write operation, refer to MNVW_Status_Enum
	\param piLastItemStatus = last NV_WRITE status, refer to nv_stat_enum_type

	\return true if successful, false if fail.

	\warning Will reset any open batch session.  If items has been queued up, they
	         must be written using the QLIB_DIAG_NV_WRITE_FlushBatchQueue().

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_NV_WRITE_FlushBatchQueue(
		HANDLE hResourceContext, unsigned short* piLastErrorNvId,
		unsigned short* piLastTotalStatus, unsigned char* piLastItemStatus  );

	/******************************************************************************/
	/**
	DMSS ICD, 3.4.29 Handset Emulation Keypress Request/Response
	WCDMA Diagnostic ICD, 3.5.18 Handset Emulation Keypress Request/Response

	Emulate a key press


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iKey = ID of Key.  Lookup in QLib_Defines.h
	\param  iHold = Key release indicator
	\code
		0 = Selected keypress will be emulated,
		    then a key release will be emulated

		1 = Selected keypress will be emulated,
		    but no key release will be emulated;
		    this is used to simulate the effect of
		    holding down a key, such as CLEAR
		    or END; you should send a second message

	\endcode

	\return true if successful, false if fail.

	\warning None.

	*******************************************************************************/
	QLIB_API unsigned char  QLIB_DIAG_HS_KEY_F(HANDLE hResourceContext, int iKey, unsigned char iHold);


	/******************************************************************************/
	/**
	DMSS ICD, 3.4.1 Version Number Request/Response
	WCDMA Diagnostic ICD, 3.5.15 Diag version request/response

	Return software version information

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param comp_date[ 11] = Compile date Jun 11 1991
		\param comp_time[ 8 ] = Compile time hh:mm:ss
		\param rel_date [ 11] = Release date
		\param rel_time [ 8 ] = Release time
		\param ver_dir  [ 8 ] = Version directory
		\param scm =  Station Class Mark
		\param mob_cai_rev = CAI rev
		\param mob_model = Mobile Model
		\param mob_firm_rev = Firmware Rev
		\param slot_cycle_index = Slot Cycle Index
		\param voc_maj = Vocoder major version
		\param voc_min = Vocoder minor version

	\return true if successful, false if fail.

	\warning None.

	*******************************************************************************/
	QLIB_API unsigned char  QLIB_DIAG_VERNO_F(
										HANDLE hResourceContext,
										char comp_date[ 11 ],
										char comp_time[ 8 ],
										char rel_date [ 11 ],
										char rel_time [ 8 ],
										char ver_dir  [ 8 ],
										unsigned char* scm,
										unsigned char* mob_cai_rev,
										unsigned char* mob_model,
										unsigned short* mob_firm_rev,
										unsigned char* slot_cycle_index,
										unsigned char* voc_maj,
										unsigned char* voc_min
											);

	/******************************************************************************/
	/**
	DMSS ICD, 3.4.3 Memory Peek Request/Response  (8-bit version)
	WCDMA Diagnostic ICD, 3.5.1 Memory peek request/response

	When the DM sends a Memory Peek Request Message to the DMSS, the DMSS responds with a
	Memory Peek Response Message that contains the contents of a block of memory starting at the
	given ADDRESS and consisting of LENGTH items.

	The request may ask for up to 16 BYTES.

	The ADDRESS is specified as a 32-bit flat address.

	This packet is protected by the DMSS Security Plan. The Security Passunsigned short Request Message
	must be sent to the DMSS successfully before this message will be accepted.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iAddress = Address of peek region start; given as a flat address
	\param	iNumItems = number of items to read, must be <= 16 bytes (16 8-bit items)
	\param  pArray = array of items in which data will be stored.  Size must be at least
	                     "<iNumItems> * data size" bytes long
						 For 8-bit items, this is <iNumItems> * 1 (bytes)

	\return true if successful, false if fail.

	\warning None

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_MEMORY_PEEK_F(
		HANDLE hResourceContext, unsigned long iAddress, unsigned short iNumItems, unsigned char* pItemArray );


	/******************************************************************************/
	/**
	DMSS ICD, 3.4.3 Memory Peek Request/Response (16-bit version)
	WCDMA Diagnostic ICD, 3.5.1 Memory peek request/response

	When the DM sends a Memory Peek Request Message to the DMSS, the DMSS responds with a
	Memory Peek Response Message that contains the contents of a block of memory starting at the
	given ADDRESS and consisting of LENGTH items.

	The request may ask for up to 8 16-bit values.

	The ADDRESS is specified as a 32-bit flat address.

	This packet is protected by the DMSS Security Plan. The Security Passunsigned short Request Message
	must be sent to the DMSS successfully before this message will be accepted.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iAddress = Address of peek region start; given as a flat address
	\param	iNumItems = number of items to read, must be <= 16 bytes (8 16-bit items)
	\param  pArray = array of items in which data will be stored.  Size must be at least
	                     "<iNumItems> * data size" bytes long
						 For 16-bit items, this is <iNumItems> * 2 (bytes)

	\return true if successful, false if fail.

	\warning !!! The ICD reports 16-bytes available for transfer, but the source code limits the size to 4 bytes.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_MEMORY_PEEK_WORD_F(
		HANDLE hResourceContext, unsigned long iAddress, unsigned short iNumItems, unsigned short* pItemArray );

	/******************************************************************************/
	/**
	DMSS ICD, 3.4.3 Memory Peek Request/Response (32-bit version)
	WCDMA Diagnostic ICD, 3.5.1 Memory peek request/response

	When the DM sends a Memory Peek Request Message to the DMSS, the DMSS responds with a
	Memory Peek Response Message that contains the contents of a block of memory starting at the
	given ADDRESS and consisting of LENGTH items.

	The request may ask for up to 4 16-bit values.

	The ADDRESS is specified as a 32-bit flat address.

	This packet is protected by the DMSS Security Plan. The Security Passunsigned short Request Message
	must be sent to the DMSS successfully before this message will be accepted.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iAddress = Address of peek region start; given as a flat address
	\param	iNumItems = number of items to read, must be <= 16 bytes (4 32-bit items)
	\param  pArray = array of items in which data will be stored.  Size must be at least
	                     "<iNumItems> * data size" bytes long
						 For 32-bit items, this is <iNumItems> * 4 (bytes)

	\return true if successful, false if fail.

	\warning !!! The ICD reports 16-bytes available for transfer, but the source code limits the size to 8 bytes.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_MEMORY_PEEK_DWORD_F(
		HANDLE hResourceContext, unsigned long iAddress, unsigned short iNumItems, unsigned long* pItemArray );

	/******************************************************************************/
	/**
	DMSS ICD, 3.4.4 Memory Poke Request/Response  (16-bit version)
	WCDMA Diagnostic ICD, 3.5.2 Memory poke request/response

	When the DM sends a Memory Poke Request Message to the DMSS, the DMSS writes the
	data provided into its memory and responds with a Memory Poke Response Message. The
	poke request may request up to 16 BYTES. The response to a correctly formatted Memory Poke Request
	is a copy of the request.

	This packet is protected by the DMSS Security Plan. The Security Passunsigned short Request Message
	must be successfully sent to the DMSS before this message will be accepted.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iAddress = Address of peek region start; given as a flat address
	\param	iNumItems = number of items to read, must be <= 16 bytes (16 8-bit items)
	\param  pArray = array of items in which data will be stored.  Size must be at least
	                     "<iNumItems> * data size" bytes long
						 For 8-bit items, this is <iNumItems> * 1 (bytes)
	                     The size of this array must be at least <iNumBytes> long

	\return true if successful, false if fail.

	\warning !!! The ICD reports 16-bytes available for transfer, but the source code limits the size to 4 bytes.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_MEMORY_POKE_F(
		HANDLE hResourceContext, unsigned long iAddress, unsigned short iNumItems, unsigned char* pItemArray );

	/******************************************************************************/
	/**
	DMSS ICD, 3.4.4 Memory Poke Request/Response  (16-bit version)
	WCDMA Diagnostic ICD, 3.5.2 Memory poke request/response

	When the DM sends a Memory Poke Request Message to the DMSS, the DMSS writes the
	data provided into its memory and responds with a Memory Poke Response Message. The
	poke request may request up to 8 16-bit numbers. The response to a correctly formatted
	Memory Poke Request is a copy of the request.

	This packet is protected by the DMSS Security Plan. The Security Passunsigned short Request Message
	must be successfully sent to the DMSS before this message will be accepted.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iAddress = Address of peek region start; given as a flat address
	\param	iNumItems = number of items to read, must be <= 16 bytes (8 16-bit items)
	\param  pArray = array of items in which data will be stored.  Size must be at least
	                     "<iNumItems> * data size" bytes long
						 For 16-bit items, this is <iNumItems> * 2 (bytes)
	                     The size of this array must be at least <iNumBytes> long

	\warning !!! The ICD reports 16-bytes available for transfer, but the source code limits the size to 4 bytes.

	\warning None.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_MEMORY_POKE_WORD_F(
		HANDLE hResourceContext, unsigned long iAddress, unsigned short iNumItems, unsigned short* pItemArray );

	/******************************************************************************/
	/**
	DMSS ICD, 3.4.4 Memory Poke Request/Response (32-bit version)
	WCDMA Diagnostic ICD, 3.5.2 Memory poke request/response

	When the DM sends a Memory Poke Request Message to the DMSS, the DMSS writes the
	data provided into its memory and responds with a Memory Poke Response Message. The
	poke request may request up to 4 32-bit numbers. The response to a correctly formatted
	Memory Poke Request is a copy of the request.

	This packet is protected by the DMSS Security Plan. The Security Passunsigned short Request Message
	must be successfully sent to the DMSS before this message will be accepted.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iAddress = Address of peek region start; given as a flat address
	\param	iNumItems = number of items to read, must be <= 16 bytes (4 32-bit items)
	\param  pArray = array of items in which data will be stored.  Size must be at least
	                     "<iNumItems> * data size" bytes long
						 For 32-bit items, this is <iNumItems> * 4 (bytes)
	                     The size of this array must be at least <iNumBytes> long

	\warning !!! The ICD reports 16-bytes available for transfer, but the source code limits the size to 8 bytes.

	\warning None.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_MEMORY_POKE_DWORD_F(
		HANDLE hResourceContext, unsigned long iAddress, unsigned short iNumItems, unsigned long* pItemArray );

	/******************************************************************************/
	/**
	DMSS ICD, 3.4.63 Service Programming Code Request/Response
	WCDMA Diagnostic ICD, 3.5.29.3 Service Programming Code Request Message

	Sends the service programming code (SPC) to the phone.

	The SPC is a 6 digit number, which can enable certain operations, according to
	the DMSS Security Plan.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iSPC = array of 6 bytes, which hold the service programming code
					6 bytes of security code, in ASCII format (digits 0..9 only)
	\param	piSPC_Result = Result of the SPC
		\code
			1 = code was correct and Service Programming (SP) is unlocked
			0 = code was incorrect and SP is still locked
		\endcode

	\return true if successful, false if fail.

	\warning if the code was incorrect, the phone will time out for 10 sec
		before responding to any more requests through the serial interface.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_SPC_F(
		HANDLE hResourceContext, unsigned char iSPC[6], unsigned char* piSPC_Result );

	/******************************************************************************/
	/**
	DMSS ICD, 3.4.124.2 Extended Build ID Response Message

	This packet is an extension to the Version Number Request/Response packet (CMD_CODE 0)

	\param piMSM_HW_Version = MSM version.  This is an extension of the MSM_VER
	                         field from the Version Number Request/Response packet (DIAG_VER_NO_F)
	\param piMobModel = Manufacturer's mobile model number.  This is an extension of
	                   MOB_MODEL field from the Version Number Request/Response packet

	\param sMobSwRev = Mobile software revision string. This string is a NULL-terminated
	                   ASCII string. If string is nonexistent, a NULL char indicates an
					   empty string. This field is an extension of the VER_DIR field
					   from the Version Number Request/Response packet

	                   NOTE: Enough memory must be available at this pointer location
					   to store the entire string.  Recommend a buffer of 512 bytes.

	\param sModelStr = Mobile model string.  This string is an ASCII NULL-terminated string.
	                   If string is nonexistent, a NULL char indicates an empty string.

                       NOTE: Enough memory must be available at this pointer location
					   to store the entire string.  Recommend a buffer of 512 bytes.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_EXT_BUILD_ID_F
		( HANDLE hResourceContext, unsigned long* piMSM_HW_Version, unsigned long* piMobModel,
			char* sMobSwRev, char* sModelStr );

	/******************************************************************************/
	/**
	DMSS ICD, 3.4.9 Status Request/response Message

	The Status Request Message asks for current DMSS status information.
	This information is returned in the Status Response Message.

	\param ESN = Electronic serial number. See IS-95-A 2.3.2 or J-STD-008 2.3.2.
	\param RF_mode
		\code
			Current mode of the RF hardware
			0 = Analog
			1 = CDMA cellular
			2 = CDMA PCS
			3 = Sleep mode
			4 = GPS
			5 = HDR
		\endcode
	\param MIN1_Analog = Analog MIN1 for the current NAM (valid only for analog
                         capability phones)
	\param MIN1_CDMA = CDMA MIN1 for the current NAM.
                       For IS-95-A compliance, these are set to the same value.
                       See IS-95-A 2.3.1 or J-STD-008 6.3.1. (MIN1 is equivalent
                       to IMSI_S1.)
	\param MIN2_Analog = Analog MIN2 for the current NAM (valid only for analog
                         capability phones)
	\param MIN2_CDMA = CDMA MIN2 for the current NAM
                         For IS-95-A compliance, these are set to the same value.
                         See IS-95-A 2.3.1, or J-STD-008 6.3.1. (MIN2 is equivalent
                         to IMSI_S2.)
	\param CDMA_RX_State = Current CDMA RX process state
		\code
           - 0 = Entering CDMA state
           - 1 = Sync channel state
           - 2 = Paging channel state
           - 3 = Traffic channel initialization state
           - 4 = Traffic channel state
           - 5 = Exit state
		\endcode
	\param CDMA_Good_Frames = Valid only for Sync and Paging Channel States
		\code
           1 = Good frames received since the last status request
           0 = Five or more bad frames and no good frames
               received since the last status request
           -1 = Unknown - no good or bad frames received for two
                or more status requests
		\endcode
	\param Analog_Bad_Frames = Count of bad frames (Analog only); saturates at 65535
                               This item is only valid for analog capability phones.
	\param Analog_Word_Syncs = Number of word sync sequences received in analog control
                               or voice channel modes; saturates at 65535
                               See IS-95-A 3.7.1.
                               This item is only valid for analog capability phones.
	\param Entry_Reason = Reason call processing entered
                          Use the field RF_MODE to determine which interpretation
                          of the following values to use.
                          CDMA mode (Cellular and PCS)
		\code
           0 = Normal CDMA operation
           1 = Continue previous operation
           2 = Enter offline CDMA mode
           3 = Originate call in CDMA mode

           Analog Mode
           0 = Normal analog operation
           1 = Digital-to-analog handoff
           2 = Originate call in Analog mode
           3 = Page response
           4 = Voice channel assignment
           5 = Continue previous operation
           6 = Enter offline Analog mode
		\endcode
	\param Current_Chan = Current center frequency channel for Analog or CDMA
	\param CDMA_Code_Chan = CDMA code channel (CDMA only).
                            This is invalid after any Handoff Direction Message on the
                            Traffic Channel. See IS-95-A 7.1.3.1 or J-STD-008 3.1.3
	\param Pilot_Base = Pilot PN of current cell (CDMA only)
                        See IS-95-A 7.1.3.2 or J-STD-008 3.1.3.2.
	\param SID = Current system ID
                 See IS-95-A 7.7.1.3 or J-STD-008 3.7.1.3.
	\param NID = Current network ID
                 See IS-95-A 7.7.1.3 or J-STD-008 3.7.1.3.
	\param LocaID = Current location area ID (Analog only)
                    This item is only valid for analog capability phones. See
                    IS-95-A 2.3.4.2.
	\param RSSI = Current RSSI (RF signal strength) level for analog
                  To convert to dBm/30 KHz, use -110 + (RSSI * 62/255). This
                  value is a rather rough estimate. This item is only valid for
                  analog capability phones.
	\param Power = Current mobile output power level index for analog
                  This item is only valid for analog capability phones. See
                  IS-95-A Table 2.1.2-1.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_STATUS_REQUEST_F( HANDLE hResourceContext,
			unsigned long* ESN,
			unsigned short *RF_mode,
			unsigned long *MIN1_Analog,
			unsigned long *MIN1_CDMA,
			unsigned short *MIN2_Analog,
			unsigned short *MIN2_CDMA,
			unsigned short *CDMA_RX_State,
			unsigned char *CDMA_Good_Frames,
			unsigned short *Analog_Bad_Frames,
			unsigned short *Analog_Word_Syncs,
			unsigned short *Entry_Reason,
			unsigned short *Current_Chan,
			unsigned char *CDMA_Code_Chan,
			unsigned short *Pilot_Base,
			unsigned short *SID,
			unsigned short *NID,
			unsigned short *LocaID,
			unsigned short *RSSI,
			unsigned char *Power
			);

	/******************************************************************************/
	/**
	WCDMA ICD, 3.4.9 Status request message (cmd_code 14 of the WCDMA subsystem)

	Returns the phone status--offline, online, other

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piTMC_State = Return value of TMC state:
		\code
        0  = DIAG_STATUS_OFFLINE =  Offline
        1  = DIAG_STATUS_ONLINE  =  Online
        2  = DIAG_STATUS_LPM     =  Low power mode
        99 = DIAG_STATUS_UNKNOWN =  Unknown state
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_STATUS_F( HANDLE hResourceContext, unsigned char* piTMC_State );

	/******************************************************************************/
	/**
	WDMSS ICD, 3.5.24 Error Record Retrieval Request/Response
	CDMA ICD, 3.4.39 Error Record Retrieval Request/Response

	When the DMSS software encounters an error condition, it stores an error record in its
	nonvolatile memory. An error is defined uniquely by its source file and line number. Another
	invocation of an error that has already been recorded does not allocate another error record, it
	increments the count for the existing error. There are dozens of potential errors in the DMSS
	code, however, there is room in NV for 20 different error records, each of which includes the
	number of times the error has occurred, the source file and line of the location of the software
	reporting the error, and whether the error was fatal. Fatal errors cause the DMSS to reset,
	nonfatal errors do not.
	The error number (0 to 19) does not indicate anything about the errors other than the order in
	which they were recorded. It is just a 20-position array, and as a new error needs to be
	recorded, a new error record is used to record it.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pErrorRead = Pointer to a structure (QLIB_DIAG_Err_Read) that will hold the error
	                    read results.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ERR_READ_F( HANDLE hResourceContext, unsigned char *pErrorRead );

	/******************************************************************************/
	/**
	WDMSS ICD, 3.5.25 Error Record Clear Request/Response
	CDMA ICD, 3.4.40.1 Error Record Clear Request Message

	The accumulated error statistics in the DMSS can be cleared by sending an Error Record Clear
	Request Message. A single error record (identified by index, 0 to 19) or all error records
	(identified by index -1) may be cleared with a single Error Record Clear Request Message. After
	clearing the specified error record, the DMSS shall send an Error Record Clear Response
	Message to the DM.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piErrorRec = Index of error record to be cleared.  If ERROR_REC is -1 (0xFF), the DMSS
	                   shall clear all error records. If iErrorRec is between 0 and 19 inclusive,
					   the DMSS shall clear the error record specified by iErrorRec.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ERR_CLEAR_F( HANDLE hResourceContext, unsigned char iErrorRec );

	/******************************************************************************/
	/**
	Sirius custom diag command

	Sends the trigger for the security freeze step to be executed on the mobile

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_SECURITY_FREEZE_F( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	CDMA ICD, 3.4.56 Switch to Downloader Request/Response
	WCDMA ICD, 3.5.29 Switch to Downloader Request/Response

	Sending a Switch to Downloader Request Message will cause a jump to the resident
	downloader. In response, the phone sends a Switch to Downloader Response Message before
	it jumps to the resident downloader. The DMSS must be in an offline state in order to accept
	this command.

    \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning After this command is sent, the phone will respond only to download protocol commands

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DLOAD_F( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Start CNV backup

	If the CNV backup has been triggered by a DIAG command, the response to the DIAG
	command will tell the PC if the backup was successful or not (If it's SWUOTA
	triggered F3 messages are all that can give status of CNV backup).
	There are 2 responses to the DIAG command, first reports on the status if the
	command has been successfully queued in CNV, and the second response reports on
	the status of the backup.

	NV_CNV_DIAG_BACKUP: Command sent from the DM to the DMSS to backup the NV data to CNV.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_NV_CNV_DIAG_BACKUP_F( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	CDMA ICD, 3.4.44 DIP Switch Retrieval Request/Response

	The DM requests the software DIP switch settings by sending a DIP Switch Retrieval Request
	Message to the DMSS. The DMSS responds by sending a DIP Switch Retrieval Response
	Message to the DM that contains the current setting of the software switches. Each bit is the
	value of a single switch. The DIP switches are not true DIP switches but software-only, and
	they reset upon power cycle.

	DIP switches are highly hardware dependent and their meanings are volatile; any permanent
	configuration options will be given NV items or DIAG packets.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piSwitchValues = 16-bit bit mask of switch values

	\return true if successful, false if fail.

	\warning None.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GET_DIPSW_F( HANDLE hResourceContext, unsigned short* piSwitchValues );

	/******************************************************************************/
	/**
	CDMA ICD, 3.4.45 DIP Switch Set Request/Response

	The DM changes the value of one or more of the software DIP switches by sending a DIP
	Switch Set Request Message. The DMSS responds by setting the value of the switch word to
	the value given in the DIP Switch Set Request Message, and sending a DIP Switch Set
	Response Message in return. Note that all the switches are set at once, so it is necessary to read
	the current switch settings and return the current values of all the switches that are not being
	changed.

	DIP switches are highly hardware dependent and their meanings are volatile; any permanent
	configuration switches options will be given NV items or DIAG packets.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSwitchValues = 16-bit bit mask of switch values

	\return true if successful, false if fail.

	\warning None.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_SET_DIPSW_F( HANDLE hResourceContext, unsigned short iSwitchValues );


	/******************************************************************************/
	/**
	Read ESN, special case of DIAG_NV_READ_F

	Returns the value of the NV_ESN_I NV field, item #0.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piESN = Pointer to the location where the ESN will be stored

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_READ_ESN_F( HANDLE hResourceContext, unsigned long* piESN );

	/******************************************************************************/
	/**
	Get certain fields from the IS-2000 status.
	CDMA ICD 3.4.111

	The IS2000 Status Request Message asks for current DMSS status information. This information
	is returned in the IS2000 Status Response Message.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piBandClass = output, Band class number
	\param piCurrChan = output, current channel number
	\param piCDMA_RxState = output, reciever state
		\code
         0 = CDMA_STATE (initialization state)
         1 = SC_STATE (sync channel state)
         2 = PC_STATE (paging channel state)
         3 = TCI_STATE (traffic channel initialization state)
         4 = TC_STATE (traffic channel state)
         5 = EXIT_STATE (exit state)
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_IS2000_STATUS_F(
							HANDLE hResourceContext,
							unsigned char* piBandClass,
							unsigned short* piCurrChan,
							unsigned short* piCDMA_RxState );


    /******************************************************************************/
    /** see Call Manager ICD 3.4.50 Call Origination request
            The DM may cause an origination from the DMSS by sending a Call Origination Request
        message. The message specifies the dialed digits and the desired service option. The DMSS
        originates the call and responds with a Call Origination Response message. A successful
        response message does not guarantee a successful call origination. The phones call processing
        state should be monitored using the Phone State (63 / 0x3F) (Section 3.4.60) and/or the Status
        12 / 0x0C) (Section 3.4.9).

        This command starts a mobile originated call through the call origination request
        \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
        \param num_digit = the number of digits to dial; the maximum limit is 32.
        \param digits = the digits to dial; ASCII chars 0 to 9, #, * only; with NULL termination.
        \param so = service option:
            \code
                typedef enum
                {
                    _DIAG_CALL_ORIGINATION_SO_ID_IS96                           = 1,
                    _DIAG_CALL_ORIGINATION_SO_ID_8K_LOOPBACK                    = 2,
                    _DIAG_CALL_ORIGINATION_SO_ID_MARKOV                         = 3,
                    _DIAG_CALL_ORIGINATION_SO_ID_RESERVED                       = 4,
                    _DIAG_CALL_ORIGINATION_SO_ID_VOICE_IS96A                    = 5,
                    _DIAG_CALL_ORIGINATION_SO_ID_VOICE_13K                      = 6,
                    _DIAG_CALL_ORIGINATION_SO_ID_RATESET2_MARKOV                = 7,
                    _DIAG_CALL_ORIGINATION_SO_ID_RATESET1_MARKOV                = 8,
                    _DIAG_CALL_ORIGINATION_SO_ID_13K_LOOPBACK                   = 9,
                    _DIAG_CALL_ORIGINATION_SO_ID_13K_MARKOV                     = 10,
                    _DIAG_CALL_ORIGINATION_SO_ID_EVRC                           = 11,
                    _DIAG_CALL_ORIGINATION_SO_ID_RATESET2_SMS                   = 14,
                    _DIAG_CALL_ORIGINATION_SO_ID_13K_VOICE                      = 17,
                    _DIAG_CALL_ORIGINATION_SO_ID_MDR_RS1FWD_RS1REV              = 22,
                    _DIAG_CALL_ORIGINATION_SO_ID_MDR_RS1FWD_RS2REV              = 23,
                    _DIAG_CALL_ORIGINATION_SO_ID_MDR_RS2FWD_RS1REV              = 24,
                    _DIAG_CALL_ORIGINATION_SO_ID_MDR_RS2FWD_RS2REV              = 25,
                    _DIAG_CALL_ORIGINATION_SO_ID_MDR_RS1FWD_RS1REV_DATAPATTERN  = 36,
                    _DIAG_CALL_ORIGINATION_SO_ID_MDR_RS2FWD_RS2REV_DATAPATTERN  = 37,
                    _DIAG_CALL_ORIGINATION_SO_ID_IS2000_MARKOV                  = 54,
                    _DIAG_CALL_ORIGINATION_SO_ID_IS2000_LOOPBACK                = 55,
                    _DIAG_CALL_ORIGINATION_SO_ID_4GV_NARROWBAND                 = 68,
                    _DIAG_CALL_ORIGINATION_SO_ID_SMS                            = 65534
                }Diag_call_origination_serice_option_enum_type;
            \endcode

        \return true if the command was successfully sent, false if failed for any reason.

        \warning: A successful response message does not guarantee a successful call origination.
        Callers are responsible to verify the call state from either call processor or phone status logging as explained above.

        **/
        QLIB_API unsigned char QLIB_DIAG_CALL_ORIGINATION_REQUEST
                            (HANDLE hResourceContext,
                            unsigned char num_digit, unsigned char* digits, unsigned short so);




	/******************************************************************************/
	/**
	Send a "GPS Configure test paraemters" message, usuall used for a "GPS Cold start,"
	which is used in the GPS PERL scripts for GPS testing.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iDeleteAlm = 1; # 1 is to delete, 0 =no action
	\param iDeleteEph = 1; # 1 is to delete, 0 =no action
	\param iDeletePos = 1; # 1 is to delete, 0 =no action
	\param iDeleteTime = 1; # 1 is to delete, 0 =no action
	\param iDeleteIono= 1; # 1 is to delete, 0 =no action
	\param iTimeUnc = 0; #Inject Time uncertainity. Only applicable if delete_time value is 0
	\param iPosUnc = 0;  #Inject Position Uncertainity. Only applicable if delete pos is 0
	\param iTimeOffset = 0; #Add a time offset. Only applicable if delete_time value is 0
	\param iPosOffset = 0;  #Add a position offset. Only applicable if delete_pos value is 0


	GPS PERL script being emulated is pd_coldstart.pl, the section:

		# Build a diagnostic request for GPS_SET_TEST_MODE_PARAMETERS
		$req_testparm = new PD_COLDSTART;
		$req_testparm->{"cmd"}          = 75; #Diag Cmd
		$req_testparm->{"id"}           = 13; #Diag ID
		$req_testparm->{"sub_cmd"}      = 18; #Diag Subsystem ID
		$req_testparm->{"delete_alm"}  = 1; # 1 is to delete, 0 =no action
		$req_testparm->{"delete_eph"}  = 1; # 1 is to delete, 0 =no action
		$req_testparm->{"delete_pos"}  = 1; # 1 is to delete, 0 =no action
		$req_testparm->{"delete_time"}  = 1; # 1 is to delete, 0 =no action
		$req_testparm->{"delete_iono"}  = 1; # 1 is to delete, 0 =no action
		$req_testparm->{"time_unc"}  = 0; #Inject Time uncertainity. Only applicable if delete_time value is 0
		$req_testparm->{"pos_unc"}  = 0;  #Inject Position Uncertainity. Only applicable if delete pos is 0
		$req_testparm->{"time_offset"}  = 0; #Add a time offset. Only applicable if delete_time value is 0
		$req_testparm->{"pos_offset"}  = 0;  #Add a position offset. Only applicable if delete_pos value is 0
		$req_testparm->{"client_id"}  = 0; #Not used


	\return true if successful, false if fail.

	\warning None.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GPS_SET_TEST_MODE_PARAMS(
				HANDLE hResourceContext, unsigned char   iDeleteAlm,  unsigned char   iDeleteEph,
				unsigned char   iDeletePos,  unsigned char   iDeleteTime,
				unsigned char   iDeleteIono, unsigned long iTimeUnc,
				unsigned long iPosUnc, unsigned long iTimeOffset, unsigned long iPosOffset
							);


/******************************************************************************
						Phone async Logging
*******************************************************************************/

	/******************************************************************************/
	/**

		Set phone logging on or off

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param bEnableLogging = true to enable logging, false to disable

		\return true if call succeeds, false if it fails

		\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_SetPhoneLoggingState( HANDLE hResourceContext, unsigned char bEnableLogging );


	/******************************************************************************/
	/**

	Waits a specified amount of time for a phone log message and returns the contents to the user.
	NOTE: phone log is different from "text" logs

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param piLogSize = Pointer to number of bytes received in the log message
		\param piLogBytes = Pointer to a buffer to store the log message.
		\param iTimeout = millisecond time out

	\return Returns true if a valid log message was found within the specified time-out.\

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GetNextPhoneLog
				(
				HANDLE hResourceContext,
				unsigned short* piLogSize,
				unsigned char* piLogBytes,
				unsigned long iTimeOut
				);

	/******************************************************************************/
	/**
	  Searches the async queue for a specific exnteded debug message (text message)
	  and returns whether the message is found + the parameters of the message.

	  Extended messages are response message #121, documented in the CDMA and WCDMA
	  ICD's.  They operate like a printf statement with text format string and 4
	  32-bit integer arguments.

	  Example:
	    string = "CEFS extraction completed with status %d"
		arg1 = 1 or 0
		arg2 = 0 always
		arg3 = 0 always
		arg4 = 0 always

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param sSearch string = NULL terminated 8-bit ASCII string to search for

		\param pbFoundMessage = output, true if the text message was found.
		\param piArg1 = output, value of the ARGS_1 field
		\param piArg2 = output, value of the ARGS_2 field
		\param piArg3 = output, value of the ARGS_3 field

	\return true if all commands are successful

	\warning The async queue be cleared as messages are searched for.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_FindDebugMessage
				(
				HANDLE hResourceContext,
				char* sSearchString,
				unsigned char* pbFoundMessage,
				unsigned long* piArg1,
				unsigned long* piArg2,
				unsigned long* piArg3
				);

	/******************************************************************************/
	/**
		Clear log message queue

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if success, false if failed.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ClearPhoneLogQueue( HANDLE hResourceContext );

	/******************************************************************************/
	/**
		Returns the current size of the Phone Log queue

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param piLogQueueSize = Number of entries currently in the log queue

	\return Returns true if a valid log message was in the queue, false if not.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GetPhoneLogQueueSize( HANDLE hResourceContext, unsigned long* iLogQueueSize );

	/******************************************************************************/
	/**

		Sets the phone's log mask, based on an extended log code.  An extended
		log code is one which is a sub-group of an equipment ID.  This function will overwrite
		any existing log code mask that has been setup.

		For example, for "MMGPS report measurement (LOG_CODE 0x7005)"

		The equipment ID is 7 and the item ID is

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iEquipmentID = equipment id, as defined by the ICD documents, e.g. UMTS is code 0x0007
		\param iLogCode = log code as defined by the ICD documents, e.g. MMGPS report measurement is 0x7005
		\param iLastItem = last possible item that can be logged for the given equipment ID

		\return true if call succeeds, false if it fails

		\warning None


	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_SetExtendedLogCode(
				HANDLE hResourceContext, unsigned char iEquipmentID, unsigned short iLogCode, unsigned short iLastItem );


	/******************************************************************************/
	/**

		Sets the phone's log mask, based on an extended log code.  An extended
		log code is one which is a sub-group of an equipment ID.  This function will
		append the requested log code to the phone's exisiting log code mask.

		For example, for "MMGPS report measurement (LOG_CODE 0x7005)"

		The equipment ID is 7 and the item ID is

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iEquipmentID = equipment id, as defined by the ICD documents, e.g. UMTS is code 0x0007
		\param iLogCode = log code as defined by the ICD documents, e.g. MMGPS report measurement is 0x7005

		\return true if call succeeds, false if it fails

		\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_AddExtendedLogCode(
				HANDLE hResourceContext, unsigned char iEquipmentID, unsigned short iLogCode );

	/******************************************************************************/
	/**

		Sets the phone's log mask, based on multiple user-provided log code.  An extended
		log code is one which is a sub-group of an equipment ID.  This function will
		append the requested log code to the phone's exisiting log code mask.

		For example, for "MMGPS report measurement (LOG_CODE 0x7005)"

		The equipment ID is 7 and the item ID is 0x7005

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iEquipmentID = equipment id, as defined by the ICD documents, e.g. UMTS is code 0x0007
		\param aiLogCodeList = log code as defined by the ICD documents, e.g. MMGPS report measurement is 0x7005
		\param iLogCodeListSize = number of items in the aiLogCodeList

		\return true if call succeeds, false if it fails
		\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_AddExtendedLogCodes(
				HANDLE hResourceContext,
				unsigned char iEquipmentID,
				unsigned short* aiLogCodeList,
				unsigned short iLogCodeListSize
				);

	/******************************************************************************/
	/**

		Clear the phone's log mask, based on an extended log code.  An extended
		log code is one which is a sub-group of an equipment ID.  This function will
		clear the requested log code from the phone's exisiting log code mask.

		For example, for "MMGPS report measurement (LOG_CODE 0x7005)"

		The equipment ID is 7 and the item ID is is 0x7005

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iEquipmentID = equipment id, as defined by the ICD documents, e.g. UMTS is code 0x0007
		\param iLogCode = log code as defined by the ICD documents, e.g. MMGPS report measurement is 0x7005

		\return true if call succeeds, false if it fails

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ClearExtendedLogCode(
				HANDLE hResourceContext, unsigned char iEquipmentID, unsigned short iLogCode );

	/******************************************************************************/
	/**

		Clear the phone's log mask, based on multiple user-provided log code.  An extended
		log code is one which is a sub-group of an equipment ID.  This function will
		clear the requested log code from the phone's exisiting log code mask.

		For example, for "MMGPS report measurement (LOG_CODE 0x7005)"

		The equipment ID is 7 and the item ID is 0x7005

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iEquipmentID = equipment id, as defined by the ICD documents, e.g. UMTS is code 0x0007
		\param aiLogCodeList = log code as defined by the ICD documents, e.g. MMGPS report measurement is 0x7005
		\param iLogCodeListSize = number of items in the aiLogCodeList

		\return true if call succeeds, false if it fails

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ClearExtendedLogCodes(
				HANDLE hResourceContext,
				unsigned char iEquipmentID,
				unsigned short* aiLogCodeList,
				unsigned short iLogCodeListSize
				);


	/******************************************************************************/
	/**

		Clear all log codes for a specific equipment ID.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iEquipmentID = equipment id, as defined by the ICD documents, e.g. UMTS is code 0x0007

		\return true if call succeeds, false if it fails

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ClearAllLogCodes(
				HANDLE hResourceContext,
				unsigned char iEquipmentID
				);

	/******************************************************************************/
	/**

		Looks through the existing async queue for a specific log code.  If not found
		then waits (based on the timeout) for a specified log code to be captured.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iEquipmentID = equipment id, as defined by the ICD documents, e.g. UMTS is code 0x0007
		\param iLogCode = log code as defined by the ICD documents, e.g. MMGPS report measurement is 0x7005
		\param iTimeOut_ms = millisecond timeout
		\param pLogData = pointer to a buffer that the log data will be copied into.  All data
		                  received (except CRC) is copied into this buffer.
						  Size of each the storage buffer should be DIAG_MAX_PACKET_SIZE
		\param piLogSize = number of bytes stored in the log structure

		\return true if at least one log code was captured, false if no log was found

		\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GetSingleLog(
				HANDLE hResourceContext,
				unsigned char iEquipmentID,
				unsigned short iLogCode,
				unsigned long iTimeOut_ms,
				void* pLogData,
				unsigned short* aiLogDataSize
				);

	/******************************************************************************/
	/**

		Looks through the existing async queue for a specific log code.  If not found
		then waits (based on the timeout) for a specified log code to be captured.

		Will collect logs until iNumLogs has been captured or the timeout occurs

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iEquipmentID = equipment id, as defined by the ICD documents, e.g. UMTS is code 0x0007
		\param iLogCode = log code as defined by the ICD documents, e.g. MMGPS report measurement is 0x7005
		\param piNumLogs = as an input, it is the number of logs to look for.  as an output
		                   it is the number of logs that were actually found.

		\param iTimeOut_ms = millisecond timeout
		\param apLogData = array of pointers to buffers that the log data will be copied into.
		                   All data received (except CRC) is copied into these buffer.
						   Size of array must be at least iNumLogs.

		\param aiLogDataSizes = output, the size of each log will be stored here

		\return true if at least one log code was captured, false if no log codes were found

		\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GetMultipleLogs(
				HANDLE hResourceContext,
				unsigned char iEquipmentID,
				unsigned short iLogCode,
				unsigned short* piNumLogs,
				unsigned long iTimeOut_ms,
				void* apLogData[],
				unsigned short aiLogDataSizes[]
				);

	/******************************************************************************/
	/**
		CDMA ICD, 3.4.94 Event Report Control Request/Response
		WCDMA ICD, 3.5.35 Event Report Control Request/Response

		When the DM sends an Event Report Control Request Message, the DMSS responds with an
		Event Report Control Response Message. This command is used to configure the service, as
		well as for the service to send information. See Section 3.4.95 for information on the Event
		Report Message.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param bOperationSwitch = Turn scheduling on or off: 0 = Off, 1 = On

		\return true if call succeeds, false if it fails

		\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_EventReportControl( HANDLE hResourceContext, unsigned char bOperationSwitch );

	/******************************************************************************/
	/**
		Sets or clears an individual bit in the Event Mask by calling QLIB_DIAG_SetEventMaskBits()

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iMaskID = bit position in the event mask, which will be turned on or off
		\param bMaskState = 0 = Off-Disabled, 1 = On-Enabled

		\return true if call succeeds, false if it fails

		\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_SetEventMaskBit(
					HANDLE hResourceContext,
					unsigned short iMaskID,
					unsigned char bMaskState);

	/******************************************************************************/
	/**
		Sets or clears the entire Event Mask.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param bMaskState = 0 = Off-Disable all events, 1 = On-Enable all events

		\return true if call succeeds, false if it fails

		\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_SetEntireEventMaskState(
					HANDLE hResourceContext,
					unsigned char bMaskState);

	/******************************************************************************/
	/**

	Returns the next event on the event queue.

	See QLIB_DIAG_GetEventQueueSize() for more information about the Event queue.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param pEvent = Pointer to a structure QMSL_Event_Element_Struct.

	\return Returns true if an event was in the queue, false if not.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GetNextEvent
				(
				HANDLE hResourceContext,
				void* pEvent
				);

	/******************************************************************************/
	/**

	Waits a specified amount of time for a phone event and returns the contents to the user.

	See QLIB_DIAG_GetEventQueueSize() for more information about the Event queue.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iEventID = ID of event to look for.
		                  For a wild card event ID, use QMSL_EVENT_ID_WILDCARD (0xFFFF)

		                  For a full list of events, see the AMSS software header file,
						  services\diag\event_defs.h

		                  While waiting for an event, any other events that are found and do
						  not match the iEventID criteria will be discarded, so it is important
						  to search for events in the correct order or to use the wildcard search
						  that will return each event as it is found.

		                  This function must be called one time for each event that is of interest.


		\param pEvent = Pointer to a structure QMSL_Event_Element_Struct.
		\param iTimeout_ms = millisecond time out

	\return Returns true if a valid log message was found within the specified time-out.\

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_WaitForEvent
				(
				HANDLE hResourceContext,
				unsigned short iEventID,
				void* pEvent,
				unsigned long iTimeOut_ms
				);

	/******************************************************************************/
	/**
		Clear Event queue.

		See QLIB_DIAG_GetEventQueueSize() for more information about the Event queue.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if success, false if failed.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ClearEventQueue( HANDLE hResourceContext );

	/******************************************************************************/
	/**
		Returns the current size of the Event queue.  The an event queue element
		is added for each event received from the mobile phone.  One "event response" packet
		may contain multiple events packets.  QMSL will parse the "event response" packet
		and extract each event, then place each event into the queue.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param piEventQueueSize = Number of entries currently in the Event queue

	\return Returns true if a valid log message was in the queue, false if not.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GetEventQueueSize( HANDLE hResourceContext, unsigned long* piEventQueueSize );

	/******************************************************************************/
	/**
		Sets or clears multiple bits in the Event Mask by calling these functions:

		1) CDMA ICD, 3.4.129 Event Get Mask Request/Response
		2) CDMA ICD, 3.4.130 Event Set Mask Request/Response

		Get Mask:

		The Event Get Mask Request Message is sent by the DM to the DMSS to get the current event
		mask.
		Event Mask is a byte array where each bit denotes an event IDs configuration. A bit value of 1
		specifies that the item is enabled. A bit value of 0 specifies that the item is disabled. The Event
		mask representation is similar to the Log mask representation described in Section 3.4.115.
		EVENT_LAST_ID is the last event ID supported. The Event mask array is of size
		(EVENT_LAST_ID / 8 + 1).

		NOTE The first byte at index zero (i.e., left-most) in the event mask array is the least significant byte;
		last byte (i.e., right-most) is the most significant byte. Within a byte, the right-most bit is the
		least significant bit and the left-most bit is the most significant bit.

		Set Mask:
		The Event Set Mask Request Message is sent by the DM to the DMSS to set the event mask.
		NUM_BITS specifies the mask length of the user. If the number of bits specified in the set mask
		command is smaller than the total number of bits supported, then only the specified bits are set
		starting from the beginning; the remaining bits are not changed.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param aiMaskID_List = array of mask ID's, which are bit position in the event mask.
		\param iMaskID_ListSize = number of mask ID's in aiMaskID_List
		\param bMaskState = 0 = Off-Disabled, 1 = On-Enabled the corresponding bit in the event mask

		\return true if call succeeds, false if it fails

		\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_SetEventMaskBits(
					HANDLE hResourceContext,
					unsigned short* aiMaskID_List,
					unsigned char iMaskID_ListSize,
					unsigned char bMaskState);


	/******************************************************************************/
	/**

	Function to look up a string related to an event id

	\param iEventID is the event ID from the async event packet
	\param sBuffer = text buffer that will be filled out with the string label of the event
	upon the byte buffer. the maximum possible size is 256 characters.
	\return None
	*******************************************************************************/
	QLIB_API void QLIB_GetEventText( unsigned short iEventID, char* sBuffer );

	/******************************************************************************/
	/**
		3.5.45.2 Logging Configuration Response Message, CMD_CODE=115

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iOperation = OPERATION parameter of the 3.5.45.1 Logging Configuration
		                    Request Message

		\param piOperationData = OPERATION_DATA parameter of the 3.5.45.1 Logging
		                         Configuration Request Message

		                         If the operation data is returned from the message, this buffer
								 will be overwritten

		\param piOperationDataSize = number of bytes to be sent in the piOperationData buffer

		                         If the operation data is returned from the message, this number
								 will be updated with the size of the operation data buffer that was
								 returned.

		\param iStatus = STATUS returned in the 3.5.45.2 Logging Configuration
		                 Response Message

	\return Returns true if a valid log message was found within the specified time-out.

		\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_SetExtendedLogMask( HANDLE hResourceContext, unsigned long iOperation, unsigned char* piOperationData,  unsigned short* piOperationDataSize);

	/******************************************************************************/
	/**
		WCDMA ICD, 3.5.17 Message Request/Response, CMD_CODE=31

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iMessageLevel= Minimum message severity level
		\code
           0000 = all messages (MSG_LVL_LOW)
           0001 = medium and above (MSG_LVL_MED)
           0002 = high and above (MSG_LVL_HIGH)
           0003 = error and above (MSG_LVL_ERROR)
           0004 = fatal error only (MSG_LVL_FATAL)
           00FF = no messages (MSG_LVL_NONE)
		\endcode


	\return Returns true if a valid log message was found within the specified time-out.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_SetMessageLevel( HANDLE hResourceContext, unsigned short iMessageLevel );

	/******************************************************************************/
	/**
		CDMA ICD, 3.4.125 Extended Message Configuration Request/Response

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

		\param iSSID
			See section 3.4.125.2 of the CDMA ICD for description of SSID's,
			basically they are unique identifiers assigned to an internal client
			of the debug message service.

			For example, sub system 6000 is a hex value of 0x1770

			Sub systems ID's can be identified as the value on the left side of the message ID
			listed in QXDM.  The right side of the message id is the bit number, which is the
			exponent of 2, used to determine the RT_MASK value.

			For example 0003/04 is a subsystem value of 3 a RT_MASK of 16, which is (2^4)
			Another example 6002/01 is a subsystem value of 0x1772 and a RT mask of 1, which is (2^1)


		\param iRT_MASK = Bit mask to determine what message levels are enabled
			\code
                Bit 1 (0x01) = Low
                Bit 2 (0x02_ = Medium
                Bit 3 (0x04) = High
                Bit 4 (0x08) = Error
                Bit 5 (0x10) = Fatal
                ...
                There can be numerous more sub categories, depending on the SSID

                0xFFFFFFFF = all messaages for the SSID
			\endcode



	\return Returns true if command succeeded, false if failed.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_SetMessageFilter( HANDLE hResourceContext, unsigned short iSSID, unsigned long iRT_MASK );

	/******************************************************************************/
	/**
		CDMA ICD, 3.4.125 Extended Message Configuration Request/Response

		Set All Run-time F3 Message Masks for all SubSystem.

		Implement commmand 0x7D, SubCommand 0x5 in 80-V1294-1

		\param iRT_MASK = Bit mask to determine what message levels are enabled
			\code
                Bit 1 (0x01) = Low
                Bit 2 (0x02_ = Medium
                Bit 3 (0x04) = High
                Bit 4 (0x08) = Error
                Bit 5 (0x10) = Fatal
                ...
                There can be numerous more sub categories, depending on the SSID

                0xFFFFFFFF = all messaages for the SSID
			\endcode

	\return Returns true if command succeeded, false if failed.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_SetAllMessageFilter( HANDLE hResourceContext, unsigned long iRT_MASK );

	/******************************************************************************/
	/**

	  Fills in the ExtendedMessage structure with data from an extended log message
	  buffer.  This function is necessary because the extended messages are not always
	  the same size, depending on how many arguments are passed, and how long the
	  file name and format string fields are.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param pBuffer = byte buffer to be parsed.  The referenced buffer must contain a valid extended message.
		\param pExtendedMessage = pointer to the ExtendedMessage structure that will be filled in based
		                          upon the byte buffer.  This buffer is cast to a unsigned char* so that
								  the ExtendedMessage structure does not need to be defined for all
								  users of the library.

	\return Returns true if a valid extended log message was found in the pBuffer
	        data buffer, and then parsed with no invalid values.


	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ParseExtendedMessage
				(
				HANDLE hResourceContext,
				unsigned char* pBuffer,
				unsigned char* pExtendedMessage
				);

   /******************************************************************************/
	/**
   Documentation for this is still pending as part of the Diag ICD.

   Flushes the diagnostic logpacket/event/message queue. All queued packets/messages are sent regardless of queue size or timer expiry

   \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

   *******************************************************************************/
   QLIB_API unsigned char QLIB_DIAG_FLUSH_BUFFER
            (
            HANDLE hResourceContext
            );

	/******************************************************************************/
	/**

	  Parses all messages the current Async queue and places a summary report on
	  the console and/or the QLIB text log file.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iLogType = Log type bit mask, defined in QLib_Defines.h, for example, LOG_IO
		\param bSendToConsole = true to show data on the console, false to not show on console
		\param bSendToQlibLogFile = true to send report to QLIB text log file, false to not send
		\param bShowBinaryData = true to show the binary data of the async packet, false to not show
		                          upon the byte buffer.
	\return

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DumpAsyncMessageToTextLog
				(
				HANDLE hResourceContext,
				unsigned int iLogType,
				unsigned char bSendToConsole,
				unsigned char bSendToQlibLogFile,
				unsigned char bShowBinaryData
				);

	/******************************************************************************/
	/**

	  Starts a millisecond-resolution timer and returns a handle to the timer so the
	  user can query the timer value later.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return output, the unique ID that will be used to identify the timer later

	*******************************************************************************/
	QLIB_API unsigned long QLIB_StartTimer( HANDLE hResourceContext );

	/******************************************************************************/
	/**

	  Gets the elapsed time of a timer

		\param iTimerHandle = input, the unique ID that was returned from StartTimer()

	\return the elapsed time

	*******************************************************************************/
	QLIB_API unsigned long QLIB_GetTimerElapsed( HANDLE hResourceContext, unsigned long iTimerHandle );

	/******************************************************************************/
	/**

	  Prints  a millisecond-resolution timer to the text log.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iTimerHandle = input, the unique ID that was returned from StartTimer()
		\param sLogText = input, Text printed log file, preceding the the timer value.

	\return the elapsed time

	*******************************************************************************/
	QLIB_API unsigned long QLIB_PrintTimer( HANDLE hResourceContext, unsigned long iTimerHandle, char* sLogText );

	/******************************************************************************/
	/**

	  Stops and deletes the millisecond-resolution timer associated with the user
	  provided timer handle

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iTimerHandle = input, the unique ID that was returned from StartTimer()

	\return the elapsed time

	*******************************************************************************/
	QLIB_API unsigned long QLIB_StopTimer( HANDLE hResourceContext, unsigned long iTimerHandle );

	/******************************************************************************/
	/**

	Adds a user defined message to the text log

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iLogType = Log type bit mask, defined in QLib_Defines.h, for example, LOG_IO
		\param sUserMessage = message to send to the log
		\param bUpdateConsole = true to update the console, false for no update

	\return unsigned, integer value of the hex string

	*******************************************************************************/
	QLIB_API unsigned char QLIB_AddUserMessageToTextLog
		(
		HANDLE hResourceContext,
		unsigned int iLogType,
		char* sUserMessage,
		unsigned char bUpdateConsole
		);

	/******************************************************************************/
	/**

	Adds the text version of user binary async message to the text log

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iLogType = Log type bit mask, defined in QLib_Defines.h, for example, LOG_IO
		\param pMessage = pointer to the binary data containing the message
		\param bUpdateConsole = true to update the console, false for no update

		\return unsigned, integer value of the hex string

	*******************************************************************************/
	QLIB_API unsigned char QLIB_AddUserAsyncLogMessageToTextLog(
		HANDLE hResourceContext, unsigned int iLogType, unsigned char*pMessage,
		unsigned char bSendToQlibLogFile, unsigned char bUpdateConsole   );

	/******************************************************************************/
	/**


	Parse a user defined file and add all of the async and sync response messages to the
	command/async queues.  This will put the library into a "playback" mode.

	When commands are called in the future, they will not actually be sent to the phone,
	instead the responses will be retrieved from the queues that were populated from
	the log files.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sLogFile = File name of the the QLIB log file to parse
	\param bLogIsQpstMode = true to indicate the log was taken in QPST mode.
	                        In this mode, messages do not have CRC's.  If the file is
							not in QPST mode, then CRC's are checked and processed.

	\return true if file is found and response data is added to the playback queue

	\warning the command and async queues will be cleared before messages are added.

	\warning this function behavior is being removed in QMSL 5.2.60 and the function will
	         return FALSE.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_StartLogFilePlaybackMode(
		HANDLE hResourceContext, const char* sLogFile, unsigned char bLogIsQpstMode  );

	/******************************************************************************/
	/**

	Indicates that log file playback should be stopped.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return always true

	\warning the command and async queues will be cleared.

	\warning this function behavior is being removed in QMSL 5.2.60 and the function will
	         return FALSE.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_StopLogFilePlaybackMode( HANDLE hResourceContext   );

/******************************************************************************
						Phone sync (command) Logging
*******************************************************************************/

	/******************************************************************************/
	/**
		Clear command response queue.  This is a queue of all messages that
		are not asynchronous log/debug/event types

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if success, false if failed.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ClearCommandResponseQueue( HANDLE hResourceContext );

	/******************************************************************************/
	/**
		Returns the current size of the Command Responsequeue

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param piCmdRspQueueSize = Number of entries currently in the log queue

	\return Returns true if a valid message was in the Command Response queue, false if not.

	\warning .
	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GetCommandResponseQueueSize(
		HANDLE hResourceContext, unsigned long* piCmdRspQueueSize );

	/******************************************************************************/
	/**

	  Waits a specified amount of time for a command response message and returns the
	  contents to the user directly.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param piSize = Pointer to number of bytes received in the command response message
		\param piBytes = Pointer to a buffer to store the command response message.
		\param iTimeout = millisecond time out

	\return Returns true if a valid log message was found within the specified time-out.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GetNextCommandResponse
				(
				HANDLE hResourceContext,
				unsigned short* piSize,
				unsigned char* piBytes,
				unsigned long iTimeOut
				);

/******************************************************************************
						Keypad Diag
*******************************************************************************/

	/******************************************************************************/
	/**
	Diagnostic Keypad function

		This function starts the capturing of key presses by configuring the
		phone's extended message parameters to look for the "Applicaitons Default-high"
		set of messages.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_KeyPress_StartCapture( HANDLE hResourceContext  );

	/******************************************************************************/
	/**
	Diagnostic Keypad function

		This function stops the capturing of key presses by configuring the
		phone's extended message parameters to ignore the "Applicaitons Default-high"
		and "Legacy/Error" sets of messages.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_KeyPress_StopCapture( HANDLE hResourceContext  );

	/******************************************************************************/
	/**
	Diagnostic Keypad function

		This function clears the "key press" queue, which is a list of log messages
		that have been captured, indicating key press events

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_KeyPress_ClearQueue( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Diagnostic Keypad function

		This function clears the "key press" queue, which is a list of log messages
		that have been captured, indicating key press events

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piKeypressQueueSize = Number of entries currently in the Keypress Queue

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_KeyPress_GetQueueSize ( HANDLE hResourceContext, unsigned long* piKeypressQueueSize);


	/******************************************************************************/
	/**
	Diagnostic Keypad function

		This function returns the next key press event in the KeyPress queue.

		The KeyPress queue us determined by capturing log messages from the
		phone and locating certain key press event messages.

		When this function is called, the first key press event message to be received
		is returned and then that message is removed from the queue.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piKeypressID = Key press identifier, according to the KeyPressID enumeration
	\param piKeyPressEvent = Key press event type, according to the KeyPressEvent enumeration

	\return true if successful, false if fail or if KeyPress queue is empty.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_KeyPress_GetNextKeyEvent
		( HANDLE hResourceContext, unsigned short* piKeyPressID, unsigned char* piKeyPressEvent );

	/******************************************************************************/
	/**
	Diagnostic Keypad function

		This function clears the keypress map, which correlates 16-bit hardware keypress
		ID's to 8-bit software ID's.

		After this function is called, keypress map entries must be specified using
		the DIAG_KeyPress_AddMapEntry() operation, to add the desired mapping entries.

		Before this function is called, a default (hard-coded) set of mapping entries
		will be used in the library.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail or if KeyPress queue is empty.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_KeyPress_ClearMap( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Diagnostic Keypad function

		This function clears the keypress map, which correlates 16-bit hardware keypress
		ID's to 8-bit software ID's.

		After this function is called, keypress map entries must be specified using
		the DIAG_KeyPress_AddMapEntry() operation, to add the desired mapping entries.

		Before this function is called, a default (hard-coded) set of mapping entries
		will be used in the library.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iHW_ID  = Hardware ID of the keypress map entry

	\param iKeypressID = Key press software identifier, according to the KeyPressID enumeration
	                     Normally, these would map into the KeyPressID enumeration, but
						 for flexibility this data type is an unsigned 8-bit number,
						 so that values beyond the enermation list can be used.

	\return true if successful, false if fail or if KeyPress queue is empty.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_KeyPress_AddMapEntry
		( HANDLE hResourceContext, unsigned short iHW_ID, unsigned char iKeyPressSW_ID );

	/******************************************************************************/
	/**
	Diagnostic Keypad function

		This function sets up the strings used to detect a keypress up/down in
		F3 messages

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sKeyUpString = the text string that will be sent when a key is released
	                      (allowed up).  Only the porition of the string that is
						  constant for every key should be shown.

                          For example "AEEKey_RemovePressed: "

						  Following  this string, the F3 messages should have the hex
						  value of the hardware ID for the key press.  For example,
						  "AEEKey_RemovePressed: 0x0327" would indicate key with the
						  HW id of 0x0327.



	\param sKeyDownString = the text string that will be sent when a key is pressed.
	                      Only the porition of the string that is constant for every
						  key should be shown.

                          For example "AEEKey_AddPressed: "

						  Following  this string, the F3 messages should have the hex
						  value of the hardware ID for the key press.  For example,
						  "AEEKey_AddPressed: 0x0327" would indicate key with the
						  HW id of 0x0327.

	\param iSSID  = the sub-system ID of the Message that needs to be activated in order
	                to receive key press messages.  Usually this is a value of 0 for
					the "legacy" category.  See the function DIAG_SetMessageFilter() for
					more information.

	\param iRT_MASK = the real time mask of the subsystem message.  The typical value
	                  is 8, which corresponds to the "Error" catgory of message.  These
					  messsages are not necessarily errors--it is  just a message category.

					  See the function DIAG_SetMessageFilter() for more information.

	\return true if successful, false if failiure.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_KeyPress_ConfigureKeyDetect
		 ( HANDLE hResourceContext, char* sKeyUpString, char* sKeyDownString, unsigned short iSSID, unsigned long iRT_MASK  );

/******************************************************************************
					Handset Diag
*******************************************************************************/

	/******************************************************************************/
	/**
	Handset Diagnostic ICD, 3.1 HS_DISPLAY_GET_PARAMS_CMD Request/Response

	  This command is used to request device-specific information (display).

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iDisplayID = input, the display # to get information for, 0 = primary, 1 = secondary

		\param piDisplayHeight = output, # of veritcal pixels  (description differs from ICD document rev B)
		\param piDisplayWidth = output, # of horizontal pixels (description differs from ICD document rev B)
		\param piPixelDepth = output, bits per pixel
		\param piPanelOrientation = output, 0 - Portrait, 1 - Landscape


	\return true if response packet was successfully returned, false if fail for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_HS_DISPLAY_GET_PARAMS_CMD(
					HANDLE hResourceContext,
					unsigned char iDisplayID, unsigned short* piDisplayHeight, unsigned short* piDisplayWidth,
					unsigned char* piPixelDepth, unsigned char* piPanelOrientation
					);

	/******************************************************************************/
	/**
	Handset Diagnostic ICD, 3.3 HS_DISPLAY_CAPTURE_DELAYED_CMD 2 Request/Response

		This command requests the target to capture the display buffer region specified by
		[(STARTING_ROW, STARTING_COLUMN),(HEIGHT,WIDTH)] coordinates to a file. The
		file is written in Windows BMP 24-bit format to the EFS. Specifying [(0,0),(0xFFFF,0xFFFF)] would
		7 capture the whole display.

		This version uses the Diagnostic subsystem 2, so diag is not blocked while the
		command executes.  On the QLIB side, the function will block, and not return
		until the embedded side has completed.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iDisplayID = input, the display # to get information for, 0 = primary, 1 = secondary

		\param iStartingRow = input, Upper left-hand horizontal coordinate

		\param iStartingCol = input, Upper left-hand vertical coordinate

		\param iHeight = input, Number of rows from the STARTING_ROW; according to BMP format,
		                        this must be a multiple of 4
		\param iWidth = input, Number of columns from the STARTING_COLUMN; according to BMP format,
		                       this must be a multiple of 4

		\param sFileName = input, NULL-terminated name of file to be written to in the EFS;
		                   after the capture is completed successfully, this file will
		                   be in 24-bit Windows BMP format

	\return true if response packet was successfully returned, false if fail for any reason.

	\warning Not Currently Implemented

	*******************************************************************************/
	QLIB_API unsigned char QLIB_HS_DISPLAY_CAPTURE_DELAYED_CMD
					(
					HANDLE hResourceContext,
					unsigned char iDisplayID, unsigned short iStartingRow, unsigned short iStartingCol,
					unsigned short iHeight, unsigned short iWidth, char* sFileName
					);


/******************************************************************************
						Commands for multiple FTM modes
*******************************************************************************/

	/******************************************************************************/
	/**

	Factory Test Mode WCDMA Commands 3.2.1.9, Set mode

	Factory Test Mode GSM Commands 3.5, Set mode

	Factory Test Mode 1x RF Commands 3.2.11 (CL93-V5419-1)Set mode

	Factory Test Mode RF Commands 3.3.1.10 (CL93-V4168-1) Set mode

	This function sets the RF operating mode of the mobile. It initializes all of the necessary
			hardware to place the mobile in the requested RF mode.



	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  _eNewMode  = specifies the mode that the phone is to enter.
	          FTM_RF_Mode_Enum is the definitive list of available modes.

	          The following modes are defined by the enumeration, "ftm_mode_id_type" in the embedded software
			  file services\ftm\ftm.h.
	\code
        PHONE_MODE_FM        = 1      (FM)
        PHONE_MODE_GPS       = 3      (GPS)
        PHONE_MODE_GPS_SINAD = 4      (GPS SINAD)
        PHONE_MODE_CDMA_800  = 5      (CDMA 800)
        PHONE_MODE_CDMA_1900 = 6      (CDMA 1900)
        PHONE_MODE_CDMA_1800 = 8      (CDMA 1800)
        PHONE_MODE_J_CDMA    = 14     (JCDMA)
        PHONE_MODE_CDMA_450  = 17     (CDMA 450)
        PHONE_MODE_CDMA_IMT  = 19     (CDMA IMT)

        PHONE_MODE_WCDMA_IMT   =9      (WCDMA IMT, Band I)
        PHONE_MODE_GSM_900     =10     (GSM 900)
        PHONE_MODE_GSM_1800    =11     (GSM 1800)
        PHONE_MODE_GSM_1900    =12,    (GSM 1900)
        PHONE_MODE_WCDMA_1900A =15,    (WCDMA 1900 A, Band II Add)
        PHONE_MODE_WCDMA_1900B =16,    (WCDMA 1900 B, Band II Gen)
        PHONE_MODE_GSM_850     =18,    (GSM 850)
        PHONE_MODE_WCDMA_800   =22,    (WCDMA 800, Band V Gen)
        PHONE_MODE_WCDMA_800A  =23,    (WCDMA 800, Band V Add)
        PHONE_MODE_WCDMA_1800  =25,    (WCDMA 1800, Band III)
        PHONE_MODE_WCDMA_BC4   =28,    (WCDMA BC4-used for both Band IV Gen and Band IV Add)
        PHONE_MODE_WCDMA_BC8   =29,    (WCDMA BC8, Band VIII)
        PHONE_MODE_MF_700      =30,    (MediaFLO)
        PHONE_MODE_WCDMA_BC9   =31,    (WCDMA BC9 (1750MHz & 1845MHz), Band IX)
        PHONE_MODE_CDMA_BC15   =32     (CDMA Band Class 15)

		PHONE_MODE_LTE_B1	   =34,	    (LTE Band Class 1)
		PHONE_MODE_LTE_B7     =35,		(LTE Band Class 7)
		PHONE_MODE_LTE_B13    =36, 	(LTE Band Class 13)
		PHONE_MODE_LTE_B17    =37,  	(LTE Band Class 17)
		PHONE_MODE_LTE_B38    =38, 	(LTE Band Class 38)
		PHONE_MODE_LTE_B40    =39, 	(LTE Band Class 40)
      PHONE_MODE_WCDMA_1500=40,		//!<' WCDMA BC11 (1500MHz) Band XI

      PHONE_MODE_LTE_B2=43,
      PHONE_MODE_LTE_B3=44,
      PHONE_MODE_LTE_B5=45,
      PHONE_MODE_LTE_B6=46,
      PHONE_MODE_LTE_B8=47,
      PHONE_MODE_LTE_B9=48,
      PHONE_MODE_LTE_B10=49,
      PHONE_MODE_LTE_B12=50,
      PHONE_MODE_LTE_B14=51,
      PHONE_MODE_LTE_B15=52,
      PHONE_MODE_LTE_B16=53,
      PHONE_MODE_LTE_B18=54,
      PHONE_MODE_LTE_B19=55,
      PHONE_MODE_LTE_B20=56,
      PHONE_MODE_LTE_B21=57,
      PHONE_MODE_LTE_B22=58,
      PHONE_MODE_LTE_B23=59,
      PHONE_MODE_LTE_B24=60,
      PHONE_MODE_LTE_B25=61,
      PHONE_MODE_LTE_B26=62,
      PHONE_MODE_LTE_B27=63,
      PHONE_MODE_LTE_B28=64,
      PHONE_MODE_LTE_B29=65,
      PHONE_MODE_LTE_B30=66,
      PHONE_MODE_LTE_B31=67,
      PHONE_MODE_LTE_B32=68,
      PHONE_MODE_LTE_B33=69,
      PHONE_MODE_LTE_B34=70,
      PHONE_MODE_LTE_B35=71,
      PHONE_MODE_LTE_B36=72,
      PHONE_MODE_LTE_B37=73,
      PHONE_MODE_LTE_B39=74,
        PHONE_MODE_MAX         =255    (Last possible value, not a valid mode)

	\endcode

	\return true if successful, false if fail.

	\warning Must be called before any other FTM RF commands.
	\warning,  If the new mode is a GSM RF mode, a delay will be issued after the command
	is successfully sent to the mobile.  The duration of the delay is based on the
	value of delay type "QMSL_Timeout_Delay_GSM_RF_Mode" which can be controled by
	QLIB_ConfigureTimeOut() and read by QLIB_GetTimeOut()


	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_MODE( HANDLE hResourceContext, short eNewMode );

		/******************************************************************************/
	/**

	This function sets the RF sub block mask of the mobile , for the RF mode set in the QLIB_FTM_SET_MODE()
	command

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  _eIndex  = Specifies the block NV or parent NV to be written to.

	\code
      _eIndex = -1 ( Writing to the Parent Band Class NV )
	  _eIndex = 0  ( Pointing to the Band Class and Block mask corresponding to the Block 0 NV )
	  _eIndex = 1  (  Pointing to the Band Class and Block mask corresponding to the Block 1 NV )

	\endcode
	\param  _eBlockMask  = Specifies the block mask to be set for the RF mode set in QLIB_FTM_SET_MODE().
	The block mask should be a mask where Block A = bit 0 , Block B = bit 1 and so on.

	\return true if successful, false if fail.

	\warning QLIB_FTM_SET_MODE should be called before this command.
	\warning This command should be called before any other RF commands.


	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_BLOCK_MASK( HANDLE hResourceContext, short eIndex , unsigned long eBlockMask );

	/******************************************************************************/
	/**

	This function returns the command mode (59, 75 or -1 (invalid));

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iCommandMode     = Detected command mode.  The value can be 59 (used in MSM6000/6025/6050),
														75, or -1 (invalid)

	\return true if successful, false if fail.

	*******************************************************************************/


	QLIB_API unsigned char QLIB_FTM_DETECT_COMMAND_CODE( HANDLE hResourceContext, short* iCommandMode );

	/******************************************************************************/
	/**

	This function sets the command code (59 or 75);

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param eCommandMode	    = Command code (59 or 75)

	Note: The library uses command code 75 by default. MSM6000/6025/6050 uses commmand code 59.
	For MSM6000/6025/6050, this function should be called prior to other FTM functions

	\return true if successful, false otherwise

	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_SET_COMMAND_CODE( HANDLE hResourceContext, short eCommandCode );

	/******************************************************************************/
	/**

	This function gets the command code (59 or 75) used by the handle

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param eCommandMode	    = Command code (59 or 75)

	\return true if successful, false otherwise

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_COMMAND_CODE( HANDLE hResourceContext, short* eCommandCode );

	/******************************************************************************/
	/**

	This function sets the system mode ID;

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param eModeId = Mode ID

	The Mode IDs are from the FTM_Mode_Id_Enum in QLib_Defines.h
	\code
	FTM_MODE_ID_CDMA_1X     = 0,		//!<' RF CDMA 1X mode - RX0
	FTM_MODE_ID_WCDMA       = 1,		//!<' RF WCDMA mode
	FTM_MODE_ID_GSM         = 2,		//!<' RF GSM Mode
	FTM_MODE_ID_CDMA_1X_RX1 = 3,		//!<' RF CDMA 1X mode - RX1
	FTM_MODE_ID_BLUETOOTH   = 4,		//!<' Bluetooth
	FTM_MODE_ID_CDMA_1X_CALL= 7,		//!<' CALL CDMA 1X mode
	FTM_MODE_ID_LOGGING     = 9,		//!<' FTM Logging
	FTM_MODE_ID_AGPS        = 10,		//!<' Async GPS
	FTM_MODE_ID_PMIC        = 11,		//!<' PMIC FTM Command
	FTM_MODE_GSM_BER        = 13,		//!<' GSM BER
	FTM_MODE_ID_AUDIO       = 14,		//!<' Audio FTM
	FTM_MODE_ID_CAMERA      = 15,		//!<' Camera
	FTM_MODE_WCDMA_BER      = 16,		//!<' WCDMA BER
	FTM_MODE_ID_GSM_EXTENDED_C = 17,	//!<' GSM Extended commands
	FTM_MODE_CDMA_API_V2    = 18,		//!<' CDMA RF Cal API v2
	FTM_MODE_ID_MF_C        = 19,		//!<' MediaFLO
	FTM_MODE_RF_COMMON      = 20,		//!<' RF Common
	FTM_MODE_WCDMA_RX1      = 21,		//!<' WCDMA Diversity Rx (RX1)
	FTM_MODE_ID_PRODUCTION  = 0x8000,	//!<' Production FTM
	FTM_MODE_ID_LTM         = 0x8001	//!<' LTM
	\endcode
	Note: This function sets

	\return true if successful, false otherwise

	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_SET_MODE_ID( HANDLE hResourceContext, short eModeId );

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.1 Set PDM

	Factory Test Mode 1x RF Commands 3.2.2 (CL93-V5419-1)Set mode

	Factory Test Mode RF Commands 3.3.1.1 (CL93-V4168-1) Set mode

	This command sets the value of the PDM, based on PDM_ID.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iPDMtype  = represents the PDM to be set.
		\code
            WCDMA mode values
              2 - Tx AGC Adjust PDM
              4 - Trk Lo Adjust PDM

            GSM mode values
              0 - Trk Lo Adjust PDM

            CDMA mode values
              2 - Tx AGC Adjust PDM
              4 - Trk Lo Adjust PDM
		\endcode

	\param	iPDMvalue =
		\code
            For WCDMA mode Tx AGC Adjust PDM:
              PDM values from 0 to 511
                 0   - lowest AGC voltage
                 511 - highest AGC voltage

            For GSM mode values:
               PDM values from 0 to 4096

            For CDMA mode values:
               PDM values from 0 to 511
               0   - highest AGC voltage
               511 - lowest AGC voltage

            For FM mode values:
               PDM values from 0 to 511
               0   - lowest AGC voltage
              511 - highest AGC voltage
		\endcode

	\return true if successful, false if fail.

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_SET_PDM
		( HANDLE hResourceContext, unsigned short iPDMtype, unsigned short iPDMvalue );

	/******************************************************************************/
	/**
	This function is the same as QLIB_FTM_SET_PDM(), except the iPDMvalue is signed
	for this version of the function.  This is applicable to the GSM VCTCXO PDM control.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iPDMtype  = represents the PDM to be set.
		\code
            WCDMA mode values
              2 - Tx AGC Adjust PDM
              4 - Trk Lo Adjust PDM

            GSM mode values
              0 - Trk Lo Adjust PDM

            CDMA mode values
              2 - Tx AGC Adjust PDM
		\endcode

	\param	iPDMvalue =
		\code
            For WCDMA mode Tx AGC Adjust PDM:
              PDM values from 0 to 511
                 0   - lowest AGC voltage
                 511 - highest AGC voltage

            For GSM mode values, the range depends upon the embedded RF software.  The typical ranges are be
                    PDM values from -4096 to 4095  or  PDM values from -2048 to 2047

            For CDMA mode values:
               PDM values from 0 to 511
               0   - highest AGC voltage
               511 - lowest AGC voltage

            For FM mode values:
               PDM values from 0 to 511
               0   - lowest AGC voltage
              511 - highest AGC voltage
		\endcode

	\return true if successful, false if fail.

	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_SET_PDM_signed
		( HANDLE hResourceContext, unsigned short iPDMtype, short iPDMvalue );

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands x.x.x.x

	Set SMPS PA Bias override mode

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iOnOff = Override mode on/off

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_SMPS_PA_BIAS_OVERRIDE
		( HANDLE hResourceContext, unsigned char iOnOff );

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands x.x.x.x

	Set SMPS PA Bias value.  QLIB_SET_SET_SMPS_PA_BIAS_OVERRIDE (on) should be called first

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iPA_Bias_Value = Value of the PA Bias

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_SMPS_PA_BIAS_VAL
		( HANDLE hResourceContext, unsigned short iPA_Bias_Value);


	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.12 Set TX on

	Factory Test Mode GSM Commands 3.3 Set Tx ON

	Factory Test Mode 1x RF Commands 3.2.14 (CL93-V5419-1)Set Tx on

	Factory Test Mode RF Commands 3.3.1.13 (CL93-V4168-1) Set Tx on

		CDMA:  This command turns on the phone.s transmit chain (including the PA) and causes a CDMA
		reverse-link waveform to be generated on the current channel. All necessary encoder hardware
		initialization for transmitting is handled by this function.

		WCDMA: This command turns on the phones transmit chain (including the PA) and causes a WCDMA
		uplink waveform or CW to be generated on the current channel. All necessary encoder hardware
		initialization for transmitting is handled by this function.


		GSM:This command turns on the phones transmit chain (including the PA) and causes a GSM uplink
		burst to be generated on the current channel. The data that is transmitted and other parameters of
		transmission are set up by the Set Transmit Burst API (see Section 3.2.1.10).

		Hence, the Set Transmit Burst API must be called at least once after a mode change (to one
		of the GSM modes) and prior to the execution of the Set TX ON API.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\warning GSM: Set Transmit Burst must be setup before calling this function.


	\return true if successful, false if fail.

	*******************************************************************************/


	QLIB_API unsigned char QLIB_FTM_SET_TX_ON( HANDLE hResourceContext );
	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.11 Set TX off

	Factory Test Mode GSM Commands 3.4 Set Tx OFF

	Factory Test Mode 1x RF Commands 3.2.13 (CL93-V5419-1)Set Tx off

	Factory Test Mode RF Commands 3.3.1.12 (CL93-V4168-1) Set Tx off

	This command turns off the phones transmit chain.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\note This function can be used in QMSL FTM Sequencer operation

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_TX_OFF( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.8 Set LNA range

	Factory Test Mode GSM Commands 3.7 Set LNA range

	Factory Test Mode 1x RF Commands 3.2.10 (CL93-V5419-1)Set LNA range

	Factory Test Mode RF Commands 3.3.1.9 (CL93-V4168-1) Set LNA range

	This command sets the LNA range state machine to the specified state.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iLNArange =

				CDMA: the binary state of the LNA range state machine:
							0 - LNA_R0 - highest gain,
							1 - LNA_R1,
							2 - LNA_R2,
							3 - LNA_R3
							4 - LNA_R4 - lowest gain

				The number of possible gain states varies in different RF chipsets
				Please refer to relevant NV documents for the number of possible gain states.

				WCDMA: the binary state of the LNA range state machine:
							0 - LNA_R0 - highest gain,
							1 - LNA_R1,
							2 - LNA_R2,
							3 - LNA_R3 - lowest gain

				GSM: iLNArange = desired LNA range (0-3), 0 is highest gain, 3 is lowest gain

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_LNA_RANGE( HANDLE hResourceContext, unsigned char iLNArange);

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.6 Set RF channel

	Factory Test Mode GSM Commands 3.6 Set channel

	Factory Test Mode 1x RF Commands 3.2.7 (CL93-V5419-1)Set channel

	Factory Test Mode RF Commands 3.3.1.6 (CL93-V4168-1) Set channel

	 CDMA/WCDMA: This command tunes the RF synthesizers to the frequency defined by the channel parameter,
			which is based on the band class from the Set Mode command. Set Mode must be called first.

			GSM: This command tunes the RF synthesizers to the frequency defined by the ARFCN parameter,
			which is based on the band class from the Set Mode command. Set mode must be called first.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iChannel =
		\code
           CDMA: desired channel that is used
               PHONE_MODE_CDMA_800 : 1-799, 991-1023
               PHONE_MODE_CDMA_1900: 0 - 1199
               PHONE_MODE_CDMA_1800: 0 - 599
               PHONE_MODE_J_CDMA:    1-799, 801-1039, 1041-1199, 1201-1600

           WCDMA: desired channel that is used

           GSM: desired ARFCN that is used:
               PHONE_MODE_GSM_900 : 128 to 251 for GSM 850 MHz,
               PHONE_MODE_GSM_1900 : 0 to 124 and 975 to 1023 for GSM 900 MHz,
               PHONE_MODE_GSM_1800 : 512 to 885 for GSM 1800 MHz,
               PHONE_MODE_GSM_850 : 512 to 810 for GSM 1900 MHz
		\endcode
	\return true if successful, false if fail.

	\warning Set Mode must be called before this.  This function must be called before
			 any Tx or Rx specific functions.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_CHAN( HANDLE hResourceContext, unsigned short iChannel);

	/******************************************************************************/
	/**
        Factory Test Mode WCDMA Commands

        This command is used to set multiple carrier channels in multi carrier operation

        \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

        \param iChannel0 = desired first channel

        \param iChannel1 = desired second channel

	*******************************************************************************/
   QLIB_API unsigned char QLIB_FTM_SET_MULTI_CHAN( HANDLE hResourceContext, unsigned short iChannel0,
                                                   unsigned short iChannel1 );

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.2 Get ADC

	Factory Test Mode 1x RF Commands 3.2.3 (CL93-V5419-1) Get ADC

	Factory Test Mode RF Commands 3.3.1.2 (CL93-V4168-1)  Get ADC

	This command returns the value of the specified analog-to-digital converter (ADC) channels.

	\param  iADC_type  = the ADC channel to be read
	\param  iADC_value = ADC value of the desired channel

	\return true if successful, false if fail.

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_ADC_VAL
		( HANDLE hResourceContext, unsigned short iADC_type, unsigned short* piADC_value );

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.3 Get RX AGC

	Factory Test Mode 1x RF Commands 3.2.4 (CL93-V5419-1) Get Rx AGC

	Factory Test Mode RF Commands 3.3.1.3 (CL93-V4168-1)  Get Rx AGC

	This command returns the 10-bit twos complement output of the RX AGC loop.

	NOTE:  This number is normally represented as a signed number.  In this
	       case, the sign is on the 10th bit, so if a signed number is
		   desired, the user of this function will have to perform the
		   conversion to a 16-bit signed value.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iRX_AGC = For CDMA/WCDMA mode, AGC return value is from -512 to 511

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_RX_AGC( HANDLE hResourceContext, unsigned short* piRX_AGC );

        /******************************************************************************/
        /**
        Factory Test Mode WCDMA Commands

        This command returns the 10-bit twos complement output of the RX AGC loop.
        The output corresponds to carrier 1 in a dual carrier setup.

        NOTE:  This number is normally represented as a signed number.  In this
               case, the sign is on the 10th bit, so if a signed number is
               desired, the user of this function will have to perform the
               conversion to a 16-bit signed value.

        \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

        \param  iRX_AGC = For CDMA/WCDMA mode, AGC return value is from -512 to 511

        \return true if successful, false if fail.

        *******************************************************************************/
        QLIB_API unsigned char QLIB_FTM_GET_CAGC_DUAL_CARRIER_RX_AGC( HANDLE hResourceContext, short* piRX_AGC );

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.4 Get synthesizer lock state

	Factory Test Mode 1x RF Commands 3.2.5 (CL93-V5419-1) Get synthesizer lock state

	Factory Test Mode RF Commands 3.3.1.4 (CL93-V4168-1)  Get synthesizer lock state

	This command returns the combined (ANDed) lock state of the RF synthesizers.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  bLockState = 0 = if one or more is out of lock
                         1 = if the synthesizers are all in lock

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_SYNTH_STATE( HANDLE hResourceContext, unsigned char* pbLockState);

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.5 Set uplink waveform to CW

	Factory Test Mode 1x RF Commands 3.2.6 (CL93-V5419-1) Set  CDMA wave CW

	Factory Test Mode RF Commands 3.3.1.5 (CL93-V4168-1)  Set  CDMA wave CW


		This command turns off the spreading on the uplink in WCDMA mode. The TX chain and all
		clocks are active, but there is no modulating signal applied to the carrier; therefore a CW is
		generated.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  bSelectCW = 0 - OFF/LO/FALSE deselect CW
						1 - ON/HI/TRUE select CW

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA_CW_WAVEFORM( HANDLE hResourceContext, unsigned char bSelectCW);

   	/******************************************************************************/
	/**
	!! Document Reference TBD


		This command sets an offset tone at the given frequency offset in WCDMA mode.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iOffsetFreq = The offset frequency at which to generate the tone in Hz.

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_OFFSET_CW( HANDLE hResourceContext, int iOffsetFreq);


	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.7 Set LNA offset

	Factory Test Mode 1x RF Commands 3.2.9 (CL93-V5419-1) Set LNA offset

	Factory Test Mode RF Commands 3.3.1.8 (CL93-V4168-1)  Set LNA offset

	This command sets the LNA offset for a given index value.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iLNAindex  = LNA offset index ID (0 is highest gain)

	The number of possible LNA offset varies with RF chipsets
			Please refer to applicable RF NV documents for the number of possible gain state

	\param iLNAoffset = LNA offset value in 1/12 dB resolution for the index ID

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_LNA_OFFSET
		( HANDLE hResourceContext, unsigned short iLNAindex, unsigned short iLNAoffset);


	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.10 Set PA range

	Factory Test Mode 1x RF Commands 3.2.12 (CL93-V5419-1) Set PA range

	Factory Test Mode RF Commands 3.3.1.11 (CL93-V4168-1)  Set PA range

	This command sets the PA range state machine to the specified state.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iPArange = the binary state of the PA range state:
	\code
       0 - R0 = 0, R1 = 0,
       1 - R0 = 1, R1 = 0,
       2 - R0 = 0, R1 = 1,
       3 - R0 = 1, R1 = 1
	\endcode
	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_PA_RANGE( HANDLE hResourceContext, unsigned short iPArange );



	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.13 Get WCDMA IM2

	Factory Test Mode 1x RF Commands 3.2.15 (CL93-V5419-1) Get CDMA IM2

	Factory Test Mode RF Commands (cdma2000) 3.3.1.14 (CL93-V4168-1)  Get CDMA IM2

	FTM GSM RF Commands 3.8(CL93-V5370-1)  Get CDMA IM2

			This command returns the optimum IM2 value for the current mode and channel of the mobile.
			RX signal inputs are required to be set before issuing this command or the results will not be
			accurate.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iI_Value = The I value
	\param  iQ_Value = The Q value
	\param  iTransConductance_Value = The transconductance value.

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_CDMA_IM2
		(
			HANDLE hResourceContext, unsigned char* piI_Value, unsigned char* piQ_Value,
			unsigned char* piTransConductance_Value
		);

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.14 Set DVGA offset

	Factory Test Mode 1x RF Commands 3.2.16 (CL93-V5419-1) Set DVGA offset

	Factory Test Mode RF Commands 3.3.1.15 (CL93-V4168-1)  Set DVGA offset

	This function sets the DVGA offset register for WCDMA mode.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iDVGAoffset = offset value, in 1/120ths of dB

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_DVGA_OFFSET( HANDLE hResourceContext, unsigned short iDVGAoffset );

   /******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands (FTM document details)

	This function sets the carrier 1 DVGA offset register for dual carrier WCDMA mode.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iDVGAoffset = offset value, in 1/10th dB resolution

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_DUAL_CARRIER_DVGA_OFFSET( HANDLE hResourceContext, short iDVGAoffset );

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.15 TX calibration sweep

	Factory Test Mode 1x RF Commands 3.2.18 (CL93-V5419-1) Tx Sweep Cal

	Factory Test Mode RF Commands 3.3.1.17 (CL93-V4168-1)  Tx Sweep Cal

	This command sets up one or more complete TX sweeps from high power to low power with
	a predefined TX adjust PDM step size. Figure 2 illustrates one TX sweep.
	The start power is determined by the last TX adjust PDM value set by the user before the
	sweep. To prevent users from setting the TX power too high, the start power is also limited by
	TX_SWEEP_CAL_MAX.

	NOTE By default, TX_SWEEP_CAL_MAX is 450, while TX_SWEEP_CAL_MIN is 100. The
	TX_SWEEP_CAL_ STEP is set to 10.

	The stop power is governed by TX_SWEEP_CAL_MIN. The current implementation has two full
	sweeps to ensure a spectrum analyzer will catch at least one full sweep with the video trigger
	option. It could be reduced to one sweep for an automated test.

	This command sets up one or more complete TX sweeps from high power to low power with
			a predefined TX adjust PDM step size.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  bOnOff = 0 - no effect, 1 - to trigger TX calibration sweep

	\return true if successful, false if fail.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_TX_SWEEP_CAL( HANDLE hResourceContext, unsigned char bOnOff );

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.16 Get DVGA offset

	Factory Test Mode 1x RF Commands 3.2.18 (CL93-V5419-1) Get DVGA offset

	Factory Test Mode RF Commands 3.3.1.17 (CL93-V4168-1)  Get DVGA offset


	For MSM6000/6025/6050 targets, iExpectedRX_AGC is ignored.

	For MSM6100 (DMSS version: ??), iExpectedRX_AGC is ignored.
	For	MSM6300 (DMSS version: ??), iExpectedRX_AGC is ignored.
	For	MSM6500 (DMSS version: ??), iExpectedRX_AGC is ignored.

	For MSM6550 (DMSS version: ??), iExpectedRX_AGC is used.
	For MSM6500 (DMSS version: ??), iExpectedRX_AGC is used.

	For MSM6200 targets, this command assumes the user is inputting a mobile RX signal at the
	level equivalent to the NV item WCDMA_LNA_RANGE_FALL_I (all external losses, including
	fixture must be accounted for). The return value is in 1/12 dB resolution.

	For MSM6250 phase II targets, this command takes DVGA gain offset as an input instead of
	reading RFNV WCDMA_LNA_RANGE_FALL_I value. The input value needs to be converted from
	dBm to an RX AGC value.

	This command calibrates and returns the DVGA offset for the current channel of operation.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iExpectedRX_AGC = power level in RX AGC units, at the input to the phone
	\param  iDVGAoffset = return value of the measured DVGA offset

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_DVGA_OFFSET( HANDLE hResourceContext, short iExpectedRX_AGC, short* piDVGAoffset );

        /******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands (FTM document details)

	This command calibrates and returns the WCDMA dual carrier DVGA offset for the current channels of operation.
        The offset returned corresponds to carrier 1 in a dual carrier setup.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iExpectedRX_AGC = power level in RX AGC units, at the input to the phone
	\param  iDVGAoffset = return value of the measured DVGA offset

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_DUAL_CARRIER_DVGA_OFFSET( HANDLE hResourceContext, short iExpectedRX_AGC, short* piDVGAoffset );

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 3.2.1.17 Get LNA offset

	Factory Test Mode 1x RF Commands 3.2.20 (CL93-V5419-1) Get LNA offset

	Factory Test Mode RF Commands 3.3.1.19 (CL93-V4168-1)  Get LNA offset


		This command calculates and returns the LNA offset value for the input ID parameter. The
		function assumes the user has set up the RX signal into the mobile at an appropriate level. This
		function controls the AGC state for the purpose of calculating the LNA offset of interest. This
		function was designed to be called with the following sequence in mind:

		1. Set the power level into the mobile RX appropriate for id=1.
		2. Call the function Get LNA Offset with id=1.
		3. Set the power level into the mobile RX appropriate for id=2.
		4. Call the function Get LNA Offset with id=2.
		5. Set the power level into the mobile RX appropriate for id=3.
		6. Call the function Get LNA Offset with id=3.

		NOTE Since the DVGA dynamic range is limited, all indexes feed on the previous index being
		calculated (with the exception of id=1). If the above sequence is not followed, the returned
		values may be meaningless.

	This command calculates and returns the LNA offset value for the input ID parameter.

	For all MSM6000/6025/6050 targets, iExpectedRX_AGC is ignored.

	For MSM6100 (DMSS version: ??), iExpectedRX_AGC is ignored.
	For	MSM6300 (DMSS version: ??), iExpectedRX_AGC is ignored.
	For	MSM6500 (DMSS version: ??), iExpectedRX_AGC is ignored.

	For MSM6550 (DMSS version: ??), iExpectedRX_AGC is used.
	For MSM6500 (DMSS version: ??), iExpectedRX_AGC is used.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iLNAindex = LNA offset index, 1-3, zero is the highest gain state, but is not a
					   valid option for this function.
	\param  iExpectedRX_AGC = power level in RX AGC units, at the input to the phone
	\param iLNAoffsetValue = measured value of the LNA offset, in 1/12dB resolution

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_LNA_OFFSET
		( HANDLE hResourceContext, unsigned short iLNAindex , short iExpectedRX_AGC, short* piLNAoffsetValue );

	/******************************************************************************/
	/**
	\code
	Factory Test Mode WCDMA Commands 3.2.2 Get HDET from Tx Sweep Cal
	Factory Test Mode RF Commands 3.3.1.20 (CL93-V4168-1) Get HDET from Tx Sweep Cal
	\endcode

		While the TX is ON, data is collected after the complete execution of the TX Sweep CAL subcommand.
		Each entry is bound to a tx_agc_pdm value taken during TX Sweep CAL. If the user wishes to read
		HDET values unrelated to TX Sweep CAL, the FTM_GET_ADC_VAL API should be used.

	This command returns a value from the HDET TX Sweep Cal array.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iIndex = HDET array index, the 0 index corresponds to the first step
					 of the TX Sweep.

	\param  iHDETvalue = value of the HDET at the iIndex position

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_HDET_FROM_TX_SWEEP_CAL
				( HANDLE hResourceContext, unsigned short iIndex, unsigned short* piHDETvalue );

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 4.19 Get HDET from Tx Sweep Cal

	Factory Test Mode 1x RF Commands 3.2.26 (CL93-V5419-1) Get ALL HDET from Tx Sweep Cal

		While the TX is ON, data is collected after the complete execution of the TX Sweep CAL subcommand.
		Each entry is bound to a tx_agc_pdm value taken during TX Sweep CAL. If the user wishes to read
		HDET values unrelated to TX Sweep CAL, the FTM_GET_ADC_VAL API should be used.

		This command returns a value from the HDET TX Sweep Cal array.

  \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  piHDETvalues = Array of 32 (defined by QLIB_FTM_GET_ALL_HDET_FROM_TX_SWEEP_CAL_ARRAY_SIZE) bytes,
							to store the average HDET for the first 32 steps of the Tx Sweep

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_ALL_HDET_FROM_TX_SWEEP_CAL
		( HANDLE hResourceContext, unsigned char * piHDETvalues );
	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 4.19 Get HDET from Tx Sweep Cal

	Factory Test Mode 1x RF Commands 3.2.26 (CL93-V5419-1) Get ALL HDET from Tx Sweep Cal

		While the TX is ON, data is collected after the complete execution of the TX Sweep CAL subcommand.
		Each entry is bound to a tx_agc_pdm value taken during TX Sweep CAL. If the user wishes to read
		HDET values unrelated to TX Sweep CAL, the FTM_GET_ADC_VAL API should be used.

		This command returns a value from the HDET TX Sweep Cal array.

  \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  piHDETvalues = Array of 32 (defined by QLIB_FTM_GET_ALL_HDET_FROM_TX_SWEEP_CAL_ARRAY_SIZE) bytes,
							to store the average HDET for the first 32 steps of the Tx Sweep

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LTE_GET_ALL_HDET_FROM_TX_SWEEP_CAL
		( HANDLE hResourceContext, unsigned short* piHDETvalues );

	/******************************************************************************/
	/**
	\code
	Factory Test Mode WCDMA Commands 3.2.2 Get HDET from Tx Sweep Cal
	Factory Test Mode RF Commands 3.3.1.20 (CL93-V4168-1) Get HDET from Tx Sweep Cal
	\endcode

		While the TX is ON, data is collected after the complete execution of the TX Sweep CAL subcommand.
		Each entry is bound to a tx_agc_pdm value taken during TX Sweep CAL. If the user wishes to read
		HDET values unrelated to TX Sweep CAL, the FTM_GET_ADC_VAL API should be used.

	This command returns a value from the HDET TX Sweep Cal array.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iIndex = HDET array index, the 0 index corresponds to the first step
					 of the TX Sweep.

	\param  iHDETvalue = value of the HDET at the iIndex position

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_LPM_HDET_FROM_TX_SWEEP_CAL
				( HANDLE hResourceContext, unsigned short iIndex, unsigned short* piHDETvalue );

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 4.19 Get HDET from Tx Sweep Cal

	Factory Test Mode 1x RF Commands 3.2.26 (CL93-V5419-1) Get ALL HDET from Tx Sweep Cal

		While the TX is ON, data is collected after the complete execution of the TX Sweep CAL subcommand.
		Each entry is bound to a tx_agc_pdm value taken during TX Sweep CAL. If the user wishes to read
		HDET values unrelated to TX Sweep CAL, the FTM_GET_ADC_VAL API should be used.

		This command returns a value from the HDET TX Sweep Cal array.

  \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  piHDETvalues = Array of 32 (defined by QLIB_FTM_GET_ALL_HDET_FROM_TX_SWEEP_CAL_ARRAY_SIZE) bytes,
							to store the average HDET for the first 32 steps of the Tx Sweep

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_ALL_LPM_HDET_FROM_TX_SWEEP_CAL
		( HANDLE hResourceContext, unsigned short * piHDETvalues );

	/******************************************************************************/
	/**
	This command enables the LPM HDET.

    \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  ienableHdetLPM = Enable\Disable LPM HDET

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_ENABLE_LPM_HDET( HANDLE hResourceContext, unsigned char ienableHdetLPM  );


	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 4.19 Get HDET from Tx Sweep Cal (V2)

	Factory Test Mode 1x RF Commands 3.2.26 (CL93-V5419-1) Get ALL HDET from Tx Sweep Cal

		While the TX is ON, data is collected after the complete execution of the TX Sweep CAL subcommand.
		Each entry is bound to a tx_agc_pdm value taken during TX Sweep CAL. If the user wishes to read
		HDET values unrelated to TX Sweep CAL, the FTM_GET_ADC_VAL API should be used.

		This command returns a value from the HDET TX Sweep Cal array.

  \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  piHDETvalues = Array of 32 (defined by QLIB_FTM_GET_ALL_HDET_FROM_TX_SWEEP_CAL_ARRAY_SIZE) word,
							to store the average HDET for the first 32 steps of the Tx Sweep

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_ALL_HDET_FROM_TX_SWEEP_CAL_V2
		( HANDLE hResourceContext, unsigned short * piHDETvalues );


	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands Switch Tx Antenna

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

       \param tx_antenna The Tx Antenna to switch to 0 indicates Primary Tx Antenna and 1 indicates Diversityy Tx Antenna

	\return true if successful, false if fail.

	  *******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_SWITCH_TX_ANT
	    (HANDLE hResourceContext, unsigned short tx_antenna);


	/******************************************************************************/
	/**
	Factory Test Mode Common Commands GET Rx AGC Resolution

	Returns AGC to power constants for Rx

  \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  pdMinPower = RF Min Power
	\param  pdAGCRange = AGC Range
	\param  pdRFDynamicRange = RF Dynamic Range

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_AGC_RESOLUTION_RX
		( HANDLE hResourceContext, double * pdMinPower, double * pdAGCRange, double * pdRFDynamicRange );

	/******************************************************************************/
	/**
	Factory Test Mode Common Commands GET Tx AGC Resolution

	Returns AGC to power constants for Tx

  \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  pdMinPower = RF Min Power
	\param  pdAGCRange = AGC Range
	\param  pdRFDynamicRange = RF Dynamic Range

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_AGC_RESOLUTION_TX
		( HANDLE hResourceContext, double * pdMinPower, double * pdAGCRange, double * pdRFDynamicRange );

		/******************************************************************************/
	/**
	Factory Test Mode 1x RF Commands 3.2.28 (CL93-V5419-1) Set RF Power Mode

		This command overrides the automatic IntelliCeiver Power mode decision.
		This setting will be lost when changing the channel with the FTM_SET_CHAN API,
		or when the phone is returned to Online mode.

	\param  iMode = Power mode to force the IntelliCeiver to:
					0 = High Power mode
					1 = Mid Power mode
					2 = Low Power mode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_RF_POWER_MODE( HANDLE hResourceContext, unsigned char iMode );


	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands 4.20 Set HDET Tracking

		This command enables/disables the HDET tracking. When the HDET tracking is enabled, the
		software will periodically read the HDET value and adjust the uplink power to meet a desired
		level based on a given HDET value.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iOnOff =
		\code
           0 = disable HDET tracking
           1 = enable HDET tracking
		\endcode

	\param  iHDETvalue = desired HDET value for setpoint

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_HDET_TRACKING
		( HANDLE hResourceContext, unsigned short iOnOff, unsigned short iHDETvalue );


	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands, 4.21 Configure Tx Calibration Sweep

	Factory Test Mode CDMA Commands, 3.4.17  Set Tx Cal Sweep

	This command sets the time interval of each step in the Tx calibration sweep
	and the number of HDET readings averaged per step.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  iTimeInterval = For CDMA radio, the unit is expressed in terms of ms
							The value of 20 correponds to 20ms

							For WCDMA radio, the unit is expressed in terms on 1/32.768 kHz
							The value of 655 corresponds to 20 ms

							1/32.768 kHz = 0.0305 ms per count.
							The minimum value is 66, which is about 2 ms. Any number less
							than 66 will be forced to 66.

                            The time interval is how long the step is (in time).  We found that a 2ms
							step time is ideal and anything below that is not repeatable.  We also
							tested the CMU-200's and the FSP measurement capabilities for 2ms and
							found them to be acceptable.  For these reasons, we suggest a value of
							66 (2ms) to be used for the time interval.



	\param  iNumofHDETReadingsPerStep= Number of HDET reads for averaging (from 1 to 255)
                                       During the top 32 power steps, the HDET will be measured.
									   During the measurement of the HDET, each value is averaged
									   with other HDET readings at the same power level.   This
									   setting controls how many HDET averages are taken during
									   each power step.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CONFIGURE_TX_SWEEP_CAL
		( HANDLE hResourceContext, unsigned short iTimeInterval, unsigned short iNumofHDETReadingsPerStep);



	/******************************************************************************/
	/**
	Factory Test Mode LTE Commands(80-VR832-1), configure and execute LTE Tx Calibration Sweep

	This command sets the time interval of each step in the Tx calibration sweep
	and the number of HDET readings averaged per step.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iRsvd = Reserved. Use 0
	\param  iTimeInterval = 2,20,40,60,80 ms

                            The time interval is how long the step is (in time).  We found that a 2ms
							step time is ideal and anything below that is not repeatable.

	\param iGainIndexStepSize =  Gain Index step delta between adjacent steps.


	\param  iNumofHDETReadingsPerStep= Number of HDET reads for averaging (from 1 to 255)
                                       During the top 32 power steps, the HDET will be measured.
									   During the measurement of the HDET, each value is averaged
									   with other HDET readings at the same power level.   This
									   setting controls how many HDET averages are taken during
									   each power step.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LTE_CONFIGURE_TX_SWEEP_CAL
		( HANDLE hResourceContext, unsigned short iRsvd, unsigned short iTimeInterval, unsigned char iGainIndexStepSize, unsigned char iNumofHDETReadingsPerStep);

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands, 4.24 Set Tx sweep step size

	This command sets the PDM step size used for the Tx calibration sweep. For each step of the
	sweep, the PDM will be reduced by the specified step size. If this command is not used, then the
	step size will default to 10.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iStepSize = PDM step size to use for the Tx calibration sweep

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_TX_SWEEP_STEP_SIZE
		( HANDLE hResourceContext, unsigned char iStepSize );

	/******************************************************************************/
	/**
	Factory Test Mode 1x RF Commands 3.1.3.14 (CL93-V5864-1)Select receiver antenna source

	This command selects the antenna source for the second receiver. This command is intended for
	radio testing and factory calibration of designs implementing Full-Time SHDR. The
	command allows the second receiver to be switched between the primary antenna and the
	secondary antenna, depending on the input parameter passed to the command. The RF driver
	must have been correctly configured for antenna selection via the RF card file, and the feature
	FEATURE_FULL_TIME_SHDR_3 must be defined.

	The implementation of this command has the side effect of reconnecting Rx0 to the primary
    antenna when the antenna select parameter is 1. This command was designed to support FTS-3
    phone designs, but given the preceeding side effect, it also behaves correctly on FTS-4 designs
    that do not have a true CDMA secondary antenna

	\param  iAntennaSel =   0  Connect Rx1 to primary antenna
							1  Connect Rx1 to secondary antenna

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SELECT_RX_ANTENNA(HANDLE hResourceContext, unsigned char iAntennaSel);

	/******************************************************************************/
	/**
	Factory Test Mode 1x RF Commands 3.2.23 (CL93-V5419-1)Get CtoN

	 This command returns the carrier-to-noise ratio as calculated at the Rx front end of the Rx chain.
	 The value returned is 10 * (C/N) dB. This value was chosen to provide the result with one
	 decimal place of precision.

	 see also: Factory Test Mode Get C-to-N, CL93-V6487-1

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iCtoN = Returns the C/N ratio value with one decimal place = 10 * (C/N) dB

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_CTON( HANDLE hResourceContext, long* iCtoN);

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands, 4.27 Do DC calibration

	This command performs DC calibration. The Set mode and Set RF Channel commands should
	be called first. The results of the calibration will be written to NV directly.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_DO_DC_CAL(	HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands, FTM_DO_IQ_MISMATCH_CAL

	This command performs Rx IQ Mismatch calibration. The Set mode and Set RF Channel commands should
	be called first. The results of the calibration will be written to NV directly by the embedded side.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param ftm_error_code = ftm_error_code returned by embedded side

	\param	iAmpComp = Amplitude mismatch compensation

	\param  iPhaseComp = Phase mismatch compensation

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_DO_IQ_MISMATCH_CAL( HANDLE hResourceContext, unsigned short* iFtm_error_code, unsigned short* iAmpComp, unsigned short* iPhaseComp );

	/******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands, ICI calibration

	This command performs ICI calibration and collects INO data returned via FTM log.

	QLIB_FTM_SET_MODE, QLIB_FTM_SET_CHAN, QLIB_FTM_SET_SECONDARY_CHAIN and QLIB_FTM_SET_LNA_RANGE should be called first.

	Call QLIB_ConfigureTimeout( hResourceContext, QMSL_Timeout_ICI_IQ_Data, TimeOut) to configure the timeout value for getting IQ data
	from asynchronus FTM log

        \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

        \param multi_carrier = conveys whether multicarrier mode is enabled

        \param carrier_id = the carrier for which IQ data has to be obtained (0 or 1)

        \param ftm_error_code = ftm_error_code returned by embedded side

        \param ino_array = buffer for storing IQ data. Length needs to be 25600 bytes.
                      IQ data is returned as interleaved I and Q bytes ex. I0, Q0, I1, Q1, I2, Q2 ... 12800 pairs of IQ data

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_ICI_CAL_DATA( HANDLE hResourceContext, unsigned char multi_carrier,
                              unsigned char carrier_id, unsigned short *iFtm_error_code, char* ino_array );

        /******************************************************************************/
	/**
	Factory Test Mode WCDMA Commands

	This command triggers IQ data collection on the phone and returns such data in an array

	QLIB_FTM_SET_MODE, QLIB_FTM_SET_CHAN, QLIB_FTM_SET_SECONDARY_CHAIN should be called first.

	Call QLIB_ConfigureTimeout( hResourceContext, QMSL_Timeout_ICI_IQ_Data, TimeOut) to configure the timeout value for getting IQ data
	from asynchronus FTM log

        \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

        \param ftm_error_code = ftm_error_code returned by embedded side

        \param ino_array = buffer for storing IQ data. Length needs to be 25600 bytes.
                      IQ data is returned as interleaved I and Q bytes ex. I0, Q0, I1, Q1, I2, Q2 ... 12800 pairs of IQ data

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_DO_WCDMA_IQ_LOGGING( HANDLE hResourceContext, unsigned short carrier_mode,
                                 unsigned short carrier_id, unsigned short* iFtm_error_code, char* ino_array );


   /******************************************************************************/
   /**
   Factory Test Mode WCDMA Commands, x.x.x.xx(CL93-V5368-1) Config EUL Waveform

   FTM_CONFIG_EUL_WAVEFORM API computes and configures all the necessary MDSP
   and hardware registers for EUL waveform generation.  The request packet
   contains all the EUL waveform configuration information.
   It also enables the EUL Waveform
   Users can also use this API to achieve R99 and HSDPA waveforms with the following conditions:
      * For R99 - Set the iDeltaHS, iDeltaEc and iDeltaEd params to -1 (disable) and bHSDPCCHEnable = False
      * For HSDPA - Set the iDeltaEc, iDeltaEd to -1 (disable)

   This API has the following runtime dependencies.
   *	QLIB_FTM_SET_MODE
   *	QLIB_FTM_SET_CHAN
   *	QLIB_FTM_SET_TX_ON
   *	QLIB_FTM_WCDMA_CW_WAVEFORM
   *	QLIB_FTM_SET_PA_RANGE
   *	QLIB_FTM_SET_PDM (optional)

   \param hResourceContext = Resource context that was returned from the call
                             to QLIB_ConnectServer()
   \param iBetaC = Gain factor for DPCCH.  Range: 0-15
   \param iBetaD = Gain factor for DPDCH.  Range: 0-15
   \param iDeltaHS = Gain factor for HS-DPCCH (ACK/NACK/CQI).  Range -1 & 0-8
   \param iDeltaEc = EUL delta Ec fain factor.  Range -1 & 0-8
   \param iDeltaEd = EUL delta Ed fain factor.  Range -1 & 0-29
   \param iBetaEDSF2val = Beta ED SF2 values depends on Delta ED value selected
   \param iMu = Mu factor.  Range 0,1,2,4,6
   \param bDPDCHEnable = DPDCH enable flag.   Range: 0 or 1.
   \param bHSDPCCHEnable = HS-DPCCH enable flag.   Range: 0 or 1.
   \param iModScheme = Modulation: 0 for QPSK, 1 for 16QAM (if supported)
   \param iMPR = output - MPR backoff in dBx2 ex: '3'=>1.5dB.

   \return true if successful, false if fail.

   \warning

   *******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CONFIG_EUL_WAVEFORM( HANDLE hResourceContext,
                             unsigned char iBetaC, unsigned char iBetaD, char iDeltaHS,
                             char iDeltaEc, char iDeltaEd, char iBetaEDSF2val,
                             unsigned char iMu, unsigned char bDPDCHEnable,
                             unsigned char bHSDPCCHEnable, unsigned char iModScheme, unsigned char* iMPR );

   /******************************************************************************/
   /**
   Factory Test Mode WCDMA Commands, x.x.x.xx(CL93-V5368-1) Disable EUL Waveform

   FTM_DISABLE_EUL_WAVEFORM API reverts back to WCDMA R99 waveform and
   all the EUL related register settings are erased.

   \param hResourceContext = Resource context that was returned from the call
                             to QLIB_ConnectServer()

   \return true if successful, false if fail.

   \warning

   *******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_DISABLE_EUL_WAVEFORM( HANDLE hResourceContext );

   /******************************************************************************/
   /**
   Factory Test Mode WCDMA Commands, x.x.x.xx(CL93-V5368-1) WCDMA Set TxAGC

   FTM_WCDMA_SET_TXAGC API  programs the PA range, RF Gain and Digital Gain to reach the programmed TxAGC.
   User can override the PA range lookup in this API by setting the PA_Override input to TRUE and provide a custom PA range.


   This API has the following runtime dependencies.
   *	QLIB_FTM_SET_MODE
   *	QLIB_FTM_SET_CHAN
   *	QLIB_FTM_SET_TX_ON
   *	QLIB_FTM_WCDMA_CW_WAVEFORM or QLIB_FTM_EUL_CONFIG_WAVEFORM

   \param hResourceContext = Resource context that was returned from the call
                             to QLIB_ConnectServer()

   \param iTxAGC = TxAGC power to be set.  Range: 0 to 1023
                   AGC resolution is target-dependent
                       TxAGC(dB10) = (TxPower(dBm)+70)/10
                       TxAGC(dB12) = (TxPower(dBm)+57)/12

   \param iPAOverride = TRUE  = Override PA range and use iPARange field always for PA range
                        FALSE = Use iTxAGC and NV PA switchpoints to determine PA range

   \param iPARange = Sets PA range when iPAOverride is TRUE.  PA R0/R1 settings are determined through
                     the NV PA Range Map.

   \return true if successful, false if fail.

   \warning

   *******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_SET_TXAGC( HANDLE hResourceContext,
                                                    short iTxAGC, unsigned char iPAOverride, unsigned char iPARange );

   /******************************************************************************/
   /**
   Factory Test Mode WCDMA Commands, x.x.x.xx(CL93-V5368-1) WCDMA Set TxAGC Sweep

   FTM_WCDMA_TXAGC_SWEEP API performs TxAGC sweep from start to stop TxAGC in step provided.
   User can override the PA range lookup in this API by setting the PA_Override input to TRUE and provide a custom PA range


   This API has the following runtime dependencies.
   *	QLIB_FTM_SET_MODE
   *	QLIB_FTM_SET_CHAN
   *	QLIB_FTM_SET_TX_ON
   *	QLIB_FTM_WCDMA_CW_WAVEFORM or QLIB_FTM_EUL_CONFIG_WAVEFORM

   Resolution of Start/Stop/Step AGC values are target-dependent:
          TxAGC(dB10) = (TxPower(dBm)+70)/10
          TxAGC(dB12) = (TxPower(dBm)+57)/12

   \param hResourceContext = Resource context that was returned from the call
                             to QLIB_ConnectServer()
   \param iStart = Start TxAGC  Range: 0 to 1023
   \param iStop = Stop TxAGC  Range: 0 to 1023
   \param iStep = Steps in AGC counts (can be positive or negative)
   \param iDelay = Step width in milliseconds (20000 => 20 ms)
   \param iPAOverride = TRUE  = Override PA range and use iPARange field always for PA range
                        FALSE = Use current tx agc value and NV PA switchpoints to determine PA range
   \param iPARange = Sets PA range when iPAOverride is TRUE.  PA R0/R1 settings are determined through
                     the NV PA Range Map.

   \return true if successful, false if fail.

   \warning

   *******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_TXAGC_SWEEP( HANDLE hResourceContext,
                                                      short iStart, short iStop, short iStep,
                                                      short iDelay, unsigned char iPAOverride, unsigned char iPARange );


	/******************************************************************************/
	/**
   Factory Test Mode WCDMA Commands, x.x.x.xx FTM IRAT MEAS GTOW TEST WCDMA

   FTM_MEAS_GTOW_TEST_WCDMA API is used as G2W Setup mode where the phone(RTR) is faked to GSM mode (from WCDMA mode) and brought back
   to WCDMA mode so that we can make measurements in WCDMA mode for G TO W InterRAT case going from G to W mode.
   This is done purely in FTM mode where only the RTR settings are changed to provide this scenario.
   This is useful in FTM InterRAT measurements to verify the RF part (not involving upper layers).

   \param hResourceContext = Resource context that was returned from the call
                             to QLIB_ConnectServer()

   \return true if successful, false if fail.

   \warning

   *******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MEAS_GTOW_TEST_WCDMA( HANDLE hResourceContext,
                                                         unsigned short gsmBand, unsigned short gsmChan,
                                                         unsigned short wcdmaBand, unsigned short wcdmaChan);

   /******************************************************************************/
   /**
   Factory Test Mode WCDMA Commands, x.x.x.xx FTM IRAT MEAS GTOW TEST GSM

   FTM_MEAS_GTOW_TEST_GSM API is used as G2W Cleanup mode where the phone(RTR) is faked to WCDMA mode (from GSM mode) and brought back
   to GSM mode so that we can make measurements in GSM mode for G TO W InterRAT case going back to G from W mode.
   This is done purely in FTM mode where only the RTR settings are changed to provide this scenario.
   This is useful in FTM InterRAT measurements to verify the RF part (not involving upper layers).

   \param hResourceContext = Resource context that was returned from the call
                             to QLIB_ConnectServer()

   \return true if successful, false if fail.

   \warning

   *******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MEAS_GTOW_TEST_GSM( HANDLE hResourceContext,
                                                       unsigned short gsmBand, unsigned short gsmChan,
                                                       unsigned short wcdmaBand, unsigned short wcdmaChan);

   /******************************************************************************/
   /**
   Factory Test Mode WCDMA Commands, x.x.x.xx FTM IRAT MEAS WTOG TEST GSM

   FTM_MEAS_WTOG_TEST_GSM API is used as W2G Setup mode where the phone(RTR) is faked to WCDMA mode (from GSM mode) and brought back
   to GSM mode so that we can make measurements in GSM mode for G TO W InterRAT case going to G from W mode.
   This is done purely in FTM mode where only the RTR settings are changed to provide this scenario.
   This is useful in FTM InterRAT measurements to verify the RF part (not involving upper layers).

   \param hResourceContext = Resource context that was returned from the call
                             to QLIB_ConnectServer()

   \return true if successful, false if fail.

   \warning

   *******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MEAS_WTOG_TEST_GSM( HANDLE hResourceContext,
                                                       unsigned short gsmBand, unsigned short gsmChan,
                                                       unsigned short wcdmaBand, unsigned short wcdmaChan);

   /******************************************************************************/
   /**
   Factory Test Mode WCDMA Commands, x.x.x.xx FTM IRAT MEAS WTOG TEST WCDMA

   FTM_MEAS_WTOG_TEST_WCDMA API is used as W2G Setup mode where the phone(RTR) is faked to GSM mode (from WCDMA mode) and brought back
   to WCDMA mode so that we can make measurements in WCDMA mode for G TO W InterRAT case going back to W from G mode.
   This is done purely in FTM mode where only the RTR settings are changed to provide this scenario.
   This is useful in FTM InterRAT measurements to verify the RF part (not involving upper layers).

   \param hResourceContext = Resource context that was returned from the call
                             to QLIB_ConnectServer()

   \return true if successful, false if fail.

   \warning

   *******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MEAS_WTOG_TEST_WCDMA( HANDLE hResourceContext,
                                                         unsigned short gsmBand, unsigned short gsmChan,
                                                         unsigned short wcdmaBand, unsigned short wcdmaChan);

	/******************************************************************************/
	/**
	Factory Test Mode 1x RF Commands 3.2.25 (CL93-V5419-1)Get CDMA IM2 with suppression

	This command returns the suppression achieved as well as the I, Q, and transconductance (gM)
	optimum IM2 values for the current mode and channel of the mobile. It is intended to augment the original Get CDMA IM2.

	Rx signal inputs are required to be set before issuing this command or results will not be accurate.

	The suppression level is given in units of dB.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iI_Value = I value
	\param	iQ_Value = Q value
	\param	iTransConductance_Value = Transconductance Value
	\param	iSuppression = Suppression

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_CDMA_IM2_WITH_SUPPRESSSION(	HANDLE hResourceContext,
																	unsigned char* iI_Value,
																	unsigned char* iQ_Value,
																	unsigned char* iTransConductance_Value,
																	unsigned short* iSuppression);



	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, 3.3.1.16(CL93-V4168-1) Set frequency sense gain

	This command sets the frequency sense gain register to set the DFM modulation index..

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iModulationIndex =
											Range of data is from 0 to 63 (6 LSBits of input byte):
											0 = lowest
											63 = highest.

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_FREQ_SENSE_GAIN(	HANDLE hResourceContext,
							unsigned char iModulationIndex );

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, 3.3.1.21(CL93-V4168-1) Get FM IQ

	This command returns the A and B compensation values for the FM RF Mode. This command
	assumes that the user is adding a Rx CW on channel center at -75 dBm. This function will lock
	the trk-lo tune of the radio off one channel, calculate the A and B values, retune the radio back to
	the original channel, and return the A and B values as a packed double word.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iFmIQValue =
											Most significant 16 bits = B values
											Least significant 16 bits = A values.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_FM_IQ(	HANDLE hResourceContext,
												unsigned long* iFmIQValue );


	/******************************************************************************/
	/**
	Used for cdma2000, 1xEV-DO and WCDMA

	Waits until a certain number of a specified metric has been completed.
	The metric can be:
	\code
         - cdma2000 primary or secondonary AGC
		 - 1xEV-DO primary or secondonary AGC
		 - 1xEV-DO primary or secondary C/I
		 - WCDMA primary or secondonary AGC
	\endcode

	The algorithm will wait until a certain number number of metrics has been recieved.  Two different types of
	metrics can be specified and the code will not return until both conditions are satisfied (e.g. a certain
	number of C2I and a certain number of AGC records)

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param eMetric1Type = input, specification of the type of metric (mode | agc/c2i / antenna ), defined by QMSL_WaitForMetric_Types
		\code
        QMSL_WaitForMetric_cdma2000_AGC_C0,      //!<' cdma2000 AGC C0
        QMSL_WaitForMetric_cdma2000_AGC_C1,     //!<' cdma2000 AGC C1
        QMSL_WaitForMetric_evdo2000_AGC_C0,     //!<' 1xEV-DO AGC C0
        QMSL_WaitForMetric_evdo2000_AGC_C0,     //!<' 1xEV-DO AGC C1
        QMSL_WaitForMetric_evdo2000_C2I_C0,     //!<' 1xEV-DO C/I C0
        QMSL_WaitForMetric_evdo2000_C2I_C1,     //!<' 1xEV-DO C/I C1
        QMSL_WaitForMetric_evdo2000_C2I_Both_C0_C1,  //!<' 1xEV-DO C/I, both C0 and C1
		QMSL_WaitForMetric_Max                  //!<' Maximum number
		\endcode


	\param eMetric2Type = input, specification of the type of metric (mode | agc/c2i / antenna ), defined by QMSL_WaitForMetric_Types
							Use QMSL_WaitForMetric_Max to specify no check for the 2nd metric type

	\param iMetric1MinimumCount = input, minimum number of records to capture for eMetric1Type.
	\param iMetric2MinimumCount = input, minimum number of records to capture for eMetric2Type,
									disregarded if eMetric2Type == QMSL_WaitForMetric_Max
	\param iInterLogTimeOut_ms = input, number of milliseconds to wait between the receipt of each log.
									Separate timeout counters are maintained for each metric type.

	\return true if all operations succeeded and the total number of records is found for both conditions.

	\warning After this function is called, the data structured must be retrieved from QMSL using the

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WaitForMetric(
							HANDLE hResourceContext,
							unsigned long eMetric1Type,
							unsigned long eMetric2Type,
							unsigned long iMetric1MinimumCount,
							unsigned long iMetric2MinimumCount,
							unsigned long iInterLogTimeOut_ms
							);

/******************************************************************************
						Dual RX Chain FTM RF Commands
*******************************************************************************/
	/******************************************************************************/
	/**
	Dual Rx Chain FTM Command 3.3.10 (CL93-V5864-1) Set secondary chain

	This command sets the secondary chain in one of three modes, DISABLED, RECEIVE DIVERSITY and OFF FREQUENCY SEARCH

	\param  mode
		\code
           0 = Disabled - puts the secondary chain ZIFRIC and ZIFLNA in disabled mode via SBI
           1 = Receive Diversity - enables the secondary chain ZIFRIC and ZIFLN via SBI and switches the RX_VCO_SEL MUX
                                   to the primary chain PLL; this means that both the primary
                                   and secondary chain are set to the same band class and
                                   channel.

           2 = Off frequency search (OFS) = allows you to set the secondary chain to a band class and channel that is
               independent of the primary chain settings
		\endcode
	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_SECONDARY_CHAIN( HANDLE hResourceContext, unsigned short iMode );

	/******************************************************************************/
	/**
	Dual Rx Chain FTM Command 3.3.12 (CL93-V5864-1) Set second chain test call mode

	This function forces the AMSS to use the second chain for all CDMA 1x RX processing in online
	mode. This test mode is intended for production testing of the second receive chain functionality.
	To use the second chain test mode, first place the phone in FTM mode. Then issue the Second
	Chain Test Call Mode command, with the mode parameter set to Enable. Issue a runtime switch
	back to online mode. The phone will now only respond to forward link signals on the second
	antenna. All transmit functions continue to use the primary antenna port. The phone will return to
	normal operation after a reset, or a Second Chain Test Call Mode command with the mode set to
	Disable.

	See also: CL93-V6408-1, App Note : FTM, Set Up MSM for Call Process on Second Rx Chain

	\param  Byte mode  = enables and disables the second chain test call mode:
	\code
       0 = Primary chain only
       1 = Secondary chain only
       2 = Primary and secondary chain
	\endcode

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SECOND_CHAIN_TEST_CALL( HANDLE hResourceContext, unsigned char iMode );



/******************************************************************************
						FTM CDMA RF Calibration API V2
*******************************************************************************/

	/******************************************************************************/
	/**
	FTM CDMA RF Cal API v2 3.1 (80-V2376-1) Commit RF Calibration to NV

	The Commit RF Cal command is used to store the current state of the RF calibration into NV.
	The Version 2 RF calibration APIs maintain states internally, temporarily recording any receiver
	calibration updates. When calibration is complete, all values can be written once to NV with a
	single command, eliminating the need to externally compute Rx calibration NV and resend the
	values to the mobile. In platforms that support Rx diversity, Rx calibration for both Rx chains are
	written to NV with a single execution of this command.
	The Commit API is optional and need not be used. Rx calibration may still be written to NV with
	individual NV write requests, as per the old API. NV remains unchanged until the command is
	issued, so the Version 2 calibration APIs may be used safely for testing, without concern of
	corrupting existing calibration data. All uncommitted changes will be lost when the mobile
	reboots or executes a runtime switch into Online mode.


	\param  iBandClass,
				Band to be written to NV
				0 = band class 0
				1 = band class 1
				3 = band class 3
				4 = band class 4
				5 = band class 5
				6 = band class 6
			Values 2 and 7 through 20 are reserved for future CDMA use

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA_API2_COMMIT_RF_TO_NV( HANDLE hResourceContext, unsigned short iBandClass );


	/******************************************************************************/
	/**
	FTM CDMA RF Cal API v2 3.2 (80-V2376-1) Calibrate DVGA

	This command calculates and returns the DVGA offset for the current channel of operation. This
	is a frequency-dependent API, and the DVGA offset returned will be automatically associated
	with the correct bin in the channel list.
	The input parameters are the receiver path the user wants to calibrate (path 1 is only supported on
	platforms that implement Rx diversity) and the input power at the antenna. This input power is in
	AGC units. To convert input power in dBm to AGC units in a 102.4-dB dynamic range platform
	with a minimum RSSI of -115 dBm, use the equation:
		-512 + 10*(InputPower(dBM) + 115)

	The input power should be selected such that the baseband input to the MSM is sufficiently
	strong but will not saturate the baseband ADC. This is a target-dependent value and should be
	selected based on the expected RF gain for a given gain lineup with margin for part-to-part
	variation.

	IntelliCeiver platforms may return more than one DVGA offset calibration value. The number of
	calibration values that are returned will be indicated in the Calibration Count field of the response
	packet

	\param	iPath,	0 - Primary Rx path
					1 - diversity Rx path
	\param	iInputPower	Input power at the antenna, in AGC units (1/10th dB)
	\param  iCount[in/out]		[in] Size of iDVGAarray Buffer
								[out] Calibration Count (N)
	\param  iDVGAArray DVGA value array { DVGA_0, ... DVGA_N }

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA_API2_CALIBRATE_DVGA( HANDLE hResourceContext,
															  unsigned char iPath,
															  short iInputPower,
															  unsigned char* iCount,
															  unsigned short* iDVGAarray );


	/******************************************************************************/
	/**
	FTM CDMA RF Cal API v2 3.3 (80-V2376-1) Calibrate LNA

	This command calculates and returns the LNA offset for a particular gain state for the current
	channel of operation. This is a frequency-dependent API, and the LNA offset returned will be
	automatically associated with the correct bin in the channel list.
	The input parameters are the receiver path the user wants to calibrate (path 1 is only supported on
	platforms that implement Rx diversity), the LNA gain step to calibrate, and the input power at the
	antenna. This input power is in AGC units. To convert input power in dBm to AGC units, use the
	equation described in Section 3.2.

	 IntelliCeiver platforms may return more than one LNA offset calibration value. The number of
	calibration values that are returned will be indicated in the Calibration Count field of the response
	packet.


	\param	iPath,	0 - Primary Rx path
					1 - diversity Rx path
	\param  iLNAstep LNA step
					.. 0 = first LNA gain step (G0-G1)
					.. 1 = second LNA gain step (G1-G2)
					.. 2 = third LNA gain step (G2-G3)
					.. 3 = fourth LNA gain step (G3-G4)
	 \param	iInputPower	Input power at the antenna, in AGC units (1/10th dB)
	\param  iCount[in/out]		[in] Size of iLNAarray Buffer
								[out] Calibration Count (N)
	\param  iLNAarray LNA value array { LNA<iLNAstep>0, ... LNA<iLNAstep>N }

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_CDMA_API2_CALIBRATE_LNA(	HANDLE hResourceContext,
																unsigned char	iPath,
																short  iInputPower,
																unsigned char	iLNAstep,
																unsigned char*	iCount,
																unsigned short* iLNAarray );

	/******************************************************************************/
	/**
	FTM CDMA RF Cal API v2 3.4 (80-V2376-1) Calibrate IM2

	This command returns the optimum IM2 value for the current band. This is a
	frequency-independent calibration item. The input parameter is the receiver path the user
	wants to calibrate (path 1 is only supported on platforms that implement Rx diversity).
	IntelliCeiver platforms may return more than one IM2 value. The number of calibration values
	that are returned will be indicated in the Calibration Count field of the response packet.
	The Suppression field returns a measure of the IM2 performance improvement. Suppression will
	vary from part-to-part and is described in the IM2 calibration with suppression section of [Q4].


	\param	iPath,	0 - Primary Rx path
					1 - diversity Rx path

	\param  iSuppression Characteristic IM2 performance vs. uncalibrated (dB)
	\param  iCount[in/out]		[in] Size of aiIM2result Buffer
								[out] Calibration Count (N)
	\param  aiIM2result			IM2 result array { I 0, Q 0, Transconductance 0, ...  I N, Q N, Transconductance N}

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA_API2_CALIBRATE_IM2(	HANDLE hResourceContext,
																unsigned char iPath,
																unsigned short* iSuppression,
																unsigned char* iCount,
																unsigned char* iIM2result );

	/******************************************************************************/
	/**
	FTM CDMA RF Cal API v2 3.5 (80-V2376-1) Calibrate  IntelliCeiver

	This command calibrates the internal circuitry of IntelliCeiver chips. This is a
	frequency-independent calibration item. The parameters are a receive path, for which only
	path 0 is supported, and the power level of the input signal, in AGC units, as described in

	Section 3.2.
	The calibration input waveform must be an unmodulated carrier 1-MHz positive offset from
	the center of the channel where the calibration is performed. The calibration channel is not
	significant, though it should be selected such that the input waveform will not be affected by any
	rolloff in band selection filters. It is recommended that this calibration be performed on the same
	channel on which the IM2 calibration is performed, but it is not necessary.
	The response packet contains a Success field, indicating if the calibration was successful. A zero
	returned in this field indicates a problem was detected during calibration. Check the levels and
	setup of the test equipment and repeat the calibration. The remaining data is an opaque BLOB
	containing the IntelliCeiver calibration. The Response Length field will be used to indicate the
	number of valid data bytes in the packet. The calibration BLOB data are the bytes following the
	packet header and success field, to the end of the packet indicated by the Response Length.


	\param	iPath,	0 - Primary Rx path
					1 - diversity Rx path

	\param  iInputPower	Input power at the antenna, in AGC units (1/10th dB)
	\param  iSizeOfBLOB [in/out]		[in] Size of iCalibtrationBLOB input buffer
										[out] Actual size of calibration BLOB returned from embedded side
	\param  iCalibrationBLOB			Opaque calibration value that must be written to the
										IntelliCeiver calibration NV item exactly as returned

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA_API2_CALIBRATE_INTELLICEIVER(	HANDLE hResourceContext,
																		unsigned char iPath,
																		short iInputPower,
																		unsigned char* iSizeOfBLOB,
																		unsigned char* iCalibrationBLOC );


	/******************************************************************************/
	/**
	FTM CDMA RF Cal API v2 3.6 (80-V2376-1) Calibrate IntelliCeiver RC Tune

	This API triggers a R/C search to find the optiomal Tx Notch location that results in Jammer Detector not tripping while in the prescense of a CDMA jammer

	\param	iPath,	0 - Primary Rx path
					1 - Diversity Rx path

	\param  iStatus [out]	Status returned from embedded side
							0 - Always tripped (Errors)
							1 - No errors

	\param  iResistance [out]	Resistence value returned

	\param  iCapacitance [out]	Capacitance value returned

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA_API2_CALIBRATE_INTELLICEIVER_RC_TUNE(	HANDLE hResourceContext,
																				unsigned char iPath,
																				unsigned char* iStatus,
																				unsigned short* iResistance,
																				unsigned short* iCapacitance );



/******************************************************************************
						GSM FTM
*******************************************************************************/

	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.9 Set PA profile

			1) Downloads the user-defined PA (power amplifier) ramp-up and ramp-down profile to the
			   embedded platform and stores it in the PA LUT (look-up table) for use in subsequent
			   transmits.

			2) Updates the four PA ramp offset tables for GSM 850 and GSM 900 RF operating mode and
			   two PA ramp offset tables for GSM 1800 and GSM 1900 RF operating mode, such that they
			   all have the same shape as the input PA ramp profile. GSM 850 and GSM 900 share the same
			   PA ramp offset tables, as do GSM 1800 and GSM 1900. The first offset table is shared
			   between both RF operating modes. The algorithm used to compute the PA ramp offset tables
			   from the input PA ramp profile is explained below.


			The input data will be concatonated into the pa_lut_type structure,
			as summarized below:
		\code
            #define PA_LUT_MAX_SIZE      64	// Number of entries in the PA LUT

            struct pa_lut_cfg_type
            {
               unsigned char ramp_step_size;
               unsigned char pa_lut_size;
            } ;

            struct pa_lut_type
            {
               unsigned short ramp_up[PA_LUT_MAX_SIZE];
               unsigned short ramp_down[PA_LUT_MAX_SIZE];
            };
		\endcode

			See GSM FTM document for more detailed information.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  pRampUp   = pointer to memory buffer of 64 ramp up values
	\param  pRampDown = pointer to memory buffer of 64 ramp down values
	\param  iRampSize = Number of elements in the ramp size.  This is a maximum of 64. Normally this value is <TBD>
	\param  iPaLookupTableSize = Number of elements in the PA look up table.  Normally this value is <TBD>.

	\return true if successful, false if fail.

	\warning This operation has not been tested yet in the factory library!

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_PA_PROFILE
		( HANDLE hResourceContext, unsigned short* pRampUp, unsigned short* pRampDown,
									  unsigned char iRampSize, unsigned char iPaLookupTableSize );

	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.11 Set transmit continuous

	This function configures transmit parameters to perform a continuous transmit operation.

		NOTE: A continuous transmit operation is one in which the transmitter, modulator, and related RF
		circuitry are left on and not allowed to burst. The actual transmit begins when the subsequent
		Set Tx ON function is issued, then the succeeding call to Set Tx OFF function will turn off the
		transmitter, modulator, and related circuitry.


		The data will be packed into this structure, which is referenced in the document

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotNum    = slot number
	\param iDataSource = Modulation data source:
		\code
            0 - FTM_GSM_TX_DATA_SOURCE_PSDRND
            1 - FTM_GSM_TX_DATA_SOURCE_TONE,
            2 - FTM_GSM_TX_DATA_SOURCE_BUFFER
            3 - FTM_GSM_TX_DATA_SOURCE_TWOTONE
		\endcode
	\param iTSCindex			= TSC Index number
	\param iNumBursts			= # of bursts, if not infinate
	\param bIsInfiniteDuration	=
		\code
            1 - Infinate
            0 - Count bursts
		\endcode

	\return true if successful, false if fail.

	\warning When the Tx hardware is turned on, the receiver must be turned off;
	         therefore, this API cannot be used simultaneously with the Set Rx Burst
			 or the Set Rx Continuous API.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_TRANSMIT_CONT
		( HANDLE hResourceContext, unsigned char iSlotNum, short iDataSource, unsigned char iTSCindex,
										unsigned long iNumBursts, unsigned char bIsInfiniteDuration );


	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.12 Set transmit burst

	This function configures parameters associated with a Tx burst.

			NOTE The bursts will start when the Set Tx ON API is issued and will last for the number of TDMA
			frames specified as one of the tx_burst parameters. If this parameter lists infinite burst
			transmission, the phone will keep issuing transmit bursts until the Set Tx OFF API is issued.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotNum    = slot number
	\param iDataSource = Modulation data source:
	\code
			0 - TX_DATA_SOURCE_PSDRND
			1 - TX_DATA_SOURCE_TONE,
			2 - TX_DATA_SOURCE_BUFFER

	\endcode
	\param iTSCindex			= TSC Index number
	\param iNumBursts			= # of bursts, if not infinate
	\param bIsInfiniteDuration	= 1 - Infinate, 0 - Count bursts

	\return true if successful, false if fail.

	\warning When the Tx hardware is turned on, the receiver must be turned off;
	         therefore, this API cannot be used simultaneously with the Set Rx Burst
			 or the Set Rx Continuous API.
	*/
	QLIB_API unsigned char QLIB_FTM_SET_TRANSMIT_BURST
		( HANDLE hResourceContext, unsigned char iSlotNum, short iDataSource, unsigned char iTSCindex,
										unsigned long iNumBursts, unsigned char bIsInfiniteDuration );

	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.13 Set Rx burst

			This function configures parameters to either start (RX_FUNCTION_GET_RSSI or
			RX_FUNCTION_GET_DC_OFFSETS) or stop sending Rx burst commands to the MDSP
			(RX_FUNCTION_STOP_CONTINOUS_RX), as specified by the enum_rx_function_type parameter.

			The document refers to the rx_burst_type structure, which is defined here:
	\code
             struct rx_burst_type
             {
                 unsigned char slot_num;	// 1 byte, unsigned 8-bit = slot number
                 short rx_funct;			// 2 bytes, signed 16-bit, rx function ID
             };
	\endcode

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotNum = Slot number to receive
	\param iRxFunction =  Type of function for DSP to perform
	\code
			0  - RX_FUNCTION_GET_RSSI
			1  - RX_FUNCTION_GET_DC_OFFSETS
			2  - RX_FUNCTION_STOP_CONTINOUS_RX

	\endcode
	\return true if successful, false if fail.

	\warning Cannot be used while FTM_SET_TRANSMIT_BURST is active

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_RX_BURST( HANDLE hResourceContext, unsigned char iSlotNum, short iRxFunction);

	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.14 Set Rx continuous

			This function configures the RF hardware such that the receiver is ON continuously and is not
			bursting. The enum_rx_function_type parameter specifies whether the receiver is to be turned
			ON (RX_FUNCTION_RF_RX_HW_ON) or OFF (RX_FUNCTION_RF_RX_HW_ON). This mode is used for
			performing hardware test and measurements.

			The document refers to the rx_burst_type structure, which is defined here:
				struct rx_burst_type
				{
					unsigned char slot_num;	// 1 byte, unsigned 8-bit = slot number
					short rx_funct;			// 2 bytes, signed 16-bit, rx function ID
				};

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotNum	 = Slot number to receive
	\param iRxFunction = Type of function for DSP to perform
		\code
           0  - RX_FUNCTION_GET_RSSI
           1  - RX_FUNCTION_GET_DC_OFFSETS
           2  - RX_FUNCTION_STOP_CONTINOUS_RX
		\endcode

	\return true if successful, false if fail.

	\warning Cannot be used while QLIB_FTM_SET_TRANSMIT_BURST is active
	\warning When RX Continuous is used the RSSI will not update.  This command mode is used for troubleshooting purposes only.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_RX_CONTINUOUS( HANDLE hResourceContext, unsigned char iSlotNum, short iRxFunction );

	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.15 Set Tx power level

			This function reads PA ramp profiles from NV or if NV is not loaded, it reads the default PA
			ramp profile from software, and then sets the corresponding Tx power level.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iPowerLevelID = Power level number to set,
	\code
			0 to 14 = 5 dBm to 33 dBm in GSM 850 and GSM 900 mode,
			0 to 15 = 0 dBm to 30 dBm in GSM 1800 and GSM1900 mode

	\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_TX_POWER_LEVEL( HANDLE hResourceContext, unsigned char iPowerLevelID );

	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.16 Get RSSI

			This function returns a 32-bit unsigned raw receiver signal strength indicator (RSSI) value. This
			number is averaged over multiple bursts--currently over 10 bursts.

		A couple of points about this function, from questions asked:
			1. 10 bursts are just our default implementation on embedded side.  The PC
			side (QMSL) doesn't do any averaging.  If customer wants to change/define
			the number of averaging, they need to 1) change the embedded side FTM
			behavior and 2) change the PC side (by extending QMSL).  To extend the PC
			side, they can use SendSync function.  Keep in mind that QMSL is just a PC
			wrapper to all FTM functions.  In this case, it is just a wrapper of
			functions documented in CL93-V5370-1 (GSM FTM).

			2. Since QMSL is just a PC side wrapper on FTM function, you can look up the
			embedded side implementation to see how RSSI value is defined/derived.  You
			should be able to trace through the FTM dispatch table on embedded side.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iRssiValue = Return value of the RSSI value

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_RSSI( HANDLE hResourceContext, unsigned long* piRssiValue );

   /******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.16 Get RSSI in dB

			This function returns a 32-bit unsigned receiver signal strength indicator (RSSI) value in dBm.

		A couple of points about this function, from questions asked:
			1. 10 bursts are just our default implementation on embedded side.  The PC
			side (QMSL) doesn't do any averaging.  If customer wants to change/define
			the number of averaging, they need to 1) change the embedded side FTM
			behavior and 2) change the PC side (by extending QMSL).  To extend the PC
			side, they can use SendSync function.  Keep in mind that QMSL is just a PC
			wrapper to all FTM functions.

			2. Since QMSL is just a PC side wrapper on FTM function, you can look up the
			embedded side implementation to see how RSSI value is defined/derived.  You
			should be able to trace through the FTM dispatch table on embedded side.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iRssiValue = Return value of the RSSI value

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_RSSI_TO_DB( HANDLE hResourceContext, unsigned long* piRssiValue );


	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.17 Set PA start delta

		This function offsets the PA ramp start time by the specified amount. A positive value for
		3 startDelta causes the ramp to start later than it does, and a negative value causes the PA ramp to
		4 start earlier. The unit assumed for startDelta is quarter symbols.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iPA_StartDelta = Value (1/4 symbol) to adjust PA ramp start time

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_PA_START_DELTA( HANDLE hResourceContext, unsigned short iPA_StartDelta );

	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.18 Set PA stop delta

		This function offsets the PA ramp stop time by the specified amount. A positive value for
		9 stopDelta causes the ramp to stop later than it does, and a negative value causes the PA ramp to
		10 stop earlier. The unit assumed for stopDelta is quarter symbols.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iPA_StopDelta = Value to adjust PA ramp stop time (1/4 symbols)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_PA_STOP_DELTA( HANDLE hResourceContext, unsigned short iPA_StopDelta );


	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.2.19 Set PA DAC input

			The Set PA DAC input API uses the PA ramp offset table and the specified dacInput value to
			generate a PA ramp profile.

			This profile is such that it has the shape specified in the offset table,
			and the flat portion of the profile has a power corresponding to the dacInput specified. This
			generated PA profile is then copied to the PA LUT for use in the subsequent transmits (burst or
			continuous).

			In GSM 850 and GSM 900 RF operating mode, there are four PA ramp offset tables and in GSM
			1800 and GSM 1900 RF operating mode, there are two PA ramp offset tables to choose from.
			GSM 850 and GSM900 shared the same PA ramp offset tables, as does GSM 1800 and GSM
			1900. One of these offset tables will used to generate a PA ramp profile based on the dacInput
			value and RF operating mode.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iDACinput = DAC value that is used for the maximum level of the burst.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_PA_DAC_INPUT( HANDLE hResourceContext, unsigned short iDACinput );

	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.x.xx Set AMAM Table DC

		Shifts the AMAM Table by a constant DC shift.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iDACinput = DC shift applied to the waveform.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_AMAM_TABLE_DC( HANDLE hResourceContext, short iDcOffset );

	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.20 Set Tx Cal Sweep

			This function takes 3 parameters, a dac_start value, a dac_stop value and a dac_step value. It then
			turns the transmit burst on and varies the power from dac_start to dac_stop incrementing the
			power in steps of dac_steps. It uses the SET PA DAC input API to set the power for each burst. It
			has been introduced to make characterization of the GSM power amplifier easier and faster. Note
			the dac_step has to be positive.



	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iDAC_Start	= DAC value for the first burst step
	\param	iDAC_Stop	= DAC value for the last burst step
	\param	iDAC_Step	= Number of DAC values to increment between each burst (positive number)

	\return true if successful, false if fail.

	\warning The SET_TX_OFF command must be called before executing this command. Otherwise, results
			 can be unpredictable.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_TX_CAL_SWEEP
		( HANDLE hResourceContext, unsigned short iDAC_Start, unsigned short iDAC_Stop, unsigned short iDAC_Step);


	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.21 Set Tx frame matrix

	This function configures the Tx slots. It needs to be called seven times to configure all seven 3 slots.

	\param  iSlotNum	= Slot number to be configured, 0 to 7
	\param	iTurnSlotOn	= Turn the slot on or off, 0=OFF, 1=ON
	\param	iPwrLevel	= Power level for this slot; should be in dB*100
	\param  iModScheme = Modulation Code Scheme; 0=MCS1, 1=MCS2, to 8=MCS9

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_TX_FRAME_MATRIX ( HANDLE hResourceContext,
		unsigned char iSlotNum, unsigned char iTurnSlotOn, unsigned short iPwrLevel, unsigned char iModScheme);

	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.22 Rx gain range cal

	This command combines a number of steps required to perform Rx gain range calibration across frequencies.

	The traditional method of performing gain range calibration involved the following steps:
	\code
       1. Set Mode.
       2. Set Channel 1.
       3. Turn RX on.
       4. Set gain range 0.
       5. Get RSSI.
       6. Repeat steps 4 and 5 through all gain ranges.
       7. Set Channel 2.
       8. Repeat steps 4 through 6, etc.
	\endcode

	This API now accepts a bit mask to specify which gain ranges are being calibrated and returns the
	RSSI for all those gain ranges in a single command, i.e., it combines steps 5 and 6 above into a
	single command. In addition, it also turns the receiver on/off based on input from the user.
	18 The modified method of performing the gain range calibration is now:
	\code
       1. Set Mode.
       2. Set Channel 1.
       3. Call Rx gain range cal command with:
          a. gain_range_bitmask = 0xF (for 4 gain ranges) or 0x1F (for 5 gain ranges)
          b. Number of Burst to Average set to some number greater than 1
          c. Toggle RX on/off set to TRUE (this will cause the phone to turn on the receiver)
       4. Read the response of Rx gain range cal with the result in the RSSI Result field.
       5. Set Channel 2.
       6. Call Rx gain range cal command as in step 3, but set Toggle RX on/off field to FALSE.
       7. Read the response of the command.
       8. Continue for the remaining channels.
       9. Set the last channel number.
       10. Call Rx gain range cal 1 command as in step 3, i.e., set Toggle RX on/off field to TRUE.
           This should cause the phone to turn off the receiver after making measurements for the last
           channel number.
       11. Read the results.
	\endcode

	\param  iRxRangeBitMask  = input, When a bit position is set, the gain range corresponding
						to that bit position is calibrated, e.g., 0b00001111 will
						give RSSI measurements for gain range 0,1,2,3
		Refer to FTM_GSM_RX_GainRange_Enum for definitions
		\code
          FTM_GSM_RX_GAIN_RANGE_0	= 0x01,	//!<' Gain range 0
          FTM_GSM_RX_GAIN_RANGE_1	= 0x02,	//!<' Gain range 1
          FTM_GSM_RX_GAIN_RANGE_2	= 0x03,	//!<' Gain range 2
          FTM_GSM_RX_GAIN_RANGE_3	= 0x04,	//!<' Gain range 3
          FTM_GSM_RX_GAIN_RANGE_4	= 0x05	//!<' Gain range 4
		\endcode

	\param iNumAverages = Each RSSI measurement is obtained by averaging RSSI
	                      over a number of bursts; this parameter allows the
	                      number of bursts to be configured.

	\param bToggleRx = input, Possible values are:
		\code
          TRUE = If RX was on, turn it off, If RX was off, turn it on
          FALSE = Do not alter the state of the receiver
		\endcode

	\param aiRSSI_Result = output, Array of the results:
                             uint32 rssi[8]

			For example, if gain range bitmask = 0b00011101,
			rssi[0] = RSSI for gain range 0, rssi[1] = 0, rssi[2] = RSSI
			for gain range 2, rssi[3] = RSSI for gain range 3, rssi[4]
			= RSSI for gain range 4, etc.
			Note: Current targets have either 4 or 5 gain ranges.
			Setting bit positions that have no corresponding gain
			range will result in erroneous results.

			The size of the array is defined by FTM_GSM_RX_GAIN_RANGE_CAL_NUM_RETURN_VALUES in QLib_Defines.h

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_RX_GAIN_RANGE_CAL(
			HANDLE hResourceContext,
			unsigned char iRxRangeBitMask,
			unsigned char iNumAverages,
			unsigned char bToggleRx,
			unsigned long aiRSSI_Result[8]
			);

	/******************************************************************************/
	/**
	FTM RF GSM, CL93-V5370-1 section 3.1.23, FTM_GSM_RX_FREQ_CAL_SWEEP

	This command instructs the mobile to perform the GSM RX Frequency measurement.
	It will setup the appropriate mobile logging so that the resulting log message will be captured.

	The FTM command ID is FTM_GSM_RX_SWEEP_CAL (311)

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pFTM_GSM_Rx_Freq_Cal_Sweep_Request_Response = structure to hold input and output values,
	       of type "FTM_GSM_Rx_Freq_Cal_Sweep_Request_Response," as defined in QLIB_Defines.h

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_RX_FREQ_CAL_SWEEP(
		HANDLE hResourceContext, void* pFTM_GSM_Rx_Freq_Cal_Sweep_Request_Response);

/******************************************************************************
						GSM Polar Tx Cal FTM
*******************************************************************************/

	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.2 Do Autocal

	The FTM_DO_AUTOCAL command is used to measure the amplitude and phase nonlinearity of the GSM power amplifier.
	The function returns two tables. One of them is a measure of the DAC input to the power
	amplifier versus the output power of the power amplifier.
	The other is a table of the DAC input to the power amplifier versus the output-phase
	distortion caused by the PA. These tables are then interpolated, as required,
	and loaded into the MSM. The transmit data is then predistorted to compensate for the measured nonlinearity.
	The inputs to the Autocal function are:

	1. An external power measurement point.
	2. The dynamic range of the measurement.
	3. A flag to specify if the measured data is to be stored in NV.
	4. The RSB-correction parameters.

	This function will start the FTM2 logging, which will capture the GSM AUTOCAL log packet results.

	Call QLIB_FTM_DO_GSM_AUTOCAL_GetResults() to get the results returned from the phone.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iPower	= The transmitter output power at PA-DAC value; to allow for added resolution,
	the power is read in units of (dBm/100); hence, the user inputs a number that is dBm value measured x 100.

	\param	iPA_DAC_Value	= The DAC value in the external reference measurement that yielded the power in the next parameter.

	\param	iMax_Power	= The maximum power to which the Autocal curves need to be measured and stored;
		to allow for added resolution, the power is read in units of (dBm/100);
		hence, the user inputs a number that is dBm value measured x 100.
	\param  iMin_Power  = The minimum power to which the Autocal curves need to be measured and stored;
		to allow for added resolution, the power is read in units of (dBm/100);
		hence, the user inputs a number that is dBm value measured x 100.

	\param  iWriteNVFlag = Flag that specifies whether to write the curves and associated parameters to NV, and
			also specifies to the frequency with which to associate the measured curve.
			 0 = Do not write NV
			 1 = Write curves and parameters to NV associated with frequency F1 of current band
			 2 = Write curves and parameters to NV associated with frequency F1 of current band

	\param  iRSB_Cor_A_R0 = A measure of the receiver phase imbalance in gain range 0;
		it is used by the system to correct the curves for this imbalance.
		Currently, RSB parameters are not being measured. The default value to use is 0

	\param  iRSB_Cor_A_R1	= A measure of the receiver phase imbalance in gain range 1;
		it is used by the system to correct the curves for this imbalance.
		Currently, RSB parameters are not being measured. The default value to use is 0.

	\param  iRSB_Cor_B_R0 = A measure of the receiver phase and amplitude imbalance in gain range 0;
		it is used by the system to correct the curves for this imbalance.
		Currently, RSB parameters are not being measured. The default value to use is 10000.

	\param  iRSB_Cor_B_R1 = A measure of the receiver phase and amplitude imbalance in gain range 1;
		it is used by the system to correct the curves for this imbalance.
		Currently, RSB parameters are not being measured. The default value to use is 10000.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_DO_GSM_AUTOCAL(
								HANDLE hResourceContext,
								short iPower,
								unsigned short iPA_DAC_Value,
								long iMax_Power,
								long iMin_Power,
								unsigned char iWriteNVFlag,
								unsigned short iRSB_Cor_A_R0,
								unsigned short iRSB_Cor_A_R1,
								unsigned short iRSB_Cor_B_R0,
								unsigned short iRSB_Cor_B_R1);

	/******************************************************************************/
	/**
	Gets the logged results from QLIB_FTM_DO_GSM_AUTOCAL.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param piNumPoints = number of measured points.  The maximum size will be 500, as set
	                    by QMSL, so all arrays below should be at least 500 elements.


	\param aiDAC_Values = Array of DAC values used for the sweep.
	                       Number of elements filled in is the same as iNumPoints

	\param afAMAM_Values = Array of AMAM values. Number of elements filled in is the same as iNumPoints .
	\param afAMPM_Values = Array of AMpm values. Number of elements filled in is the same as iNumPoints .

	\return true if successful, false if fail.

	\warning  QLIB_FTM_DO_GSM_AUTOCAL must be called first otherwise the FTM2 logs will not be properly configured.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_DO_GSM_AUTOCAL_GetResults(
								HANDLE hResourceContext,
								unsigned short* piNumPoints,
								unsigned short aiDAC_Values[],
								float afAMAM_Values[],
								float afAMPM_Values[]
								);

	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.3 Set path delay

	This API is used to introduce delays into the phase or envelope paths in the MSM to ensure that
	the waveform does not become distorted. If the delay is a positive number the envelope path is delayed.
	When the delay is negative, the phase path is delayed. The delay is in units of 1/416 us ~ 2.403 ns.
	This API returns the delay in a packet format that can then be stored in NV memory.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  piDelay	= input/output, Positive delay -> envelope path delayed
										Negative delay -> phase path delayed

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_PATH_DELAY( HANDLE hResourceContext, short *piDelay);

	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.3 Set path delay

	This function is the same as QLIB_FTM_SET_PATH_DELAY(), except the input
	and output delay values are separated into 2 variables instead of one.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  iDelay_input	= input, Positive delay -> envelope path delayed
										Negative delay -> phase path delayed

  	\param  piDelay_output	= output, Measured value returned from FTM operation
	                                    Positive delay -> envelope path delayed
										Negative delay -> phase path delayed

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_PATH_DELAY_V2(
				HANDLE hResourceContext,
				short iDelay_input,
				short *piDelay_output );

	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.4 Enable Polar Ref Cal

	This API is used by the SetPADAC API in Polar targets (MSM6275). When issued with the enable parameter set to
	true, it allows the user to populate the entire AMAM table with the same DAC value. This has the same effect
	as writing directly to the PA DAC. In order to return to regular transmit operation, and use the
	measured AMAM curves, this API must be called with the enable parameter set to false.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  iEnable	=  1--enable , 0--disable

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_ENABLE_POLAR_REF_CAL( HANDLE hResourceContext,unsigned char iEnable);

	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.5 Set Two-tone Freq Offset

	This API is used in conjunction with the Set OPLL bandwidth API and the tx.? API in GSM to calibrate the
	Tx bandwidth. The tx.? API can be used to transmit a two-tone waveform that has one tone at center frequency
	and another tone offset from the center. The offset in frequency of the second tone from the first is set
	by this API. The difference in amplitude between the two tones is dependent on the frequency response of the OPLL.
	This can be measured and the Set OPLL Bandwidth API can be programmed to achieve the required response.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  iFreqOffsetSecTone	= Frequency offset of second tone specified in kHz, e.g., 5 MHz, will be specified as 5000

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_TWOTONE_FREQ_OFFSET( HANDLE hResourceContext, unsigned short iFreqOffsetSecTone);

	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.6 Do Calpath RSB

	This API is used to measure the phase and amplitude imbalance, i.e., RSB or residual side band, in the calibration
	path receiver. This API accepts two input parameters and returns two output parameters. The first parameter is a
	subcommand ID, the second is a flag that should be set when the RSB measurement is completed, and the last two
	parameters contain the results of the RSB measurement. The RSB measurement procedure involves multiple steps.
	Each step is specified by the RSB subcommand ID.

	The procedure used to measure the imbalances is as follows:

	1.	Turn off input to the receiver and call the API with subcommand ID 0. Clear the RSB done flag.
			This step ensures that the receiver DC is calibrated out (in gain range 0)
			before the imbalances are measured.

	2.	Input a strong tone (>0 dBm), offset from the carrier by about 30 to 40 kHz, to the receiver.
			Call the API with subcommand ID 4 with the RSB done flag cleared. This measures the RSB and returns
			the correction values A and B. These parameters should be written to NV for use during Autocal measurements.

	3.	Turn off input to the receiver and call the API with subcommand ID 1 with the RSB done flag cleared.
			This step ensures that the receiver DC is calibrated out (in gain range 1) before the imbalances are measured.

	4.	Repeat Step 2 but set the RSB done flag. This indicates that the measurement is completed and the
			internal variables can be reset. If this flag is not set, the phone will be in an invalid state and
			other APIs might not function.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  iRSB_Subcmd_ID	=	0 = Do dc calibration in gain range 0
														1 = Do dc calibration in gain range 1
														2,3 = Unused
														4 = Measure RSB
	\param iDone_RSG = Done measuring RSB (Used to reset internal state)
	\param piRSB_A = Measured RSB correction value - A
	\param piRSB_B = Measured RSB correction value - B

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_DO_CALPATH_RSB(HANDLE hResourceContext,unsigned char iRSB_Subcmd_ID, unsigned char iDone_RSG, unsigned short* piRSB_A, unsigned short* piRSB_B);

	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.7 Set OPLL bandwidth

	This API is used to adjust the OPLL bandwidth. It is used in conjunction with the tx.? API and the Set
	two-tone frequency offset API to adjust the 3-dB bandwidth of the OPLL. It accepts a parameter that takes values
	between 1 and 9. The bandwidth increases with increasing values of this parameter.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  iBandwidth_Num	= Number used to adjust OPLL bandwidth options are 1 to 9

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_OPLL_BW(HANDLE hResourceContext,unsigned char iBandwidth_Num);

	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.8 Baseband bandwidth Cal

	This API allows for calibration of the RF-baseband bandwidth. The bandwidth of the RF baseband can be set by
	issuing this API with a parameter between 0 and 15. The number that results in the best transmit spectrum is
	then written to NV for use by software.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  iBandwidth_Num = Number used to increase the RF-baseband bandwidth

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BASEBAND_BW_CAL(HANDLE hResourceContext,unsigned char iBandwidth_Num);


	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.9 Polar Tx Sweep Cal

	This API allows for AMAM and AMPM calibration of the PA. A sequence of DAC and Duration are the inputs.
	The transmitter transmits the sequence of given DAC values for the durations specified.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  numDac   : size of  dacList

	\param  dacList  : Array of DACs to be transmitted

	\param  dacDuration : Array of dacDurations.

	\return true if successful, false if fail.

	\warning  none

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_POLAR_TX_SWEEP_CAL(HANDLE hResourceContext,unsigned long numDac, unsigned long * dacList, unsigned long * dacDuration );


	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.10 TX_RSB_DC_SWEEP

	This API turns on the transmitter and sweeps through the specified RSB and DC correction
	parameters. Each set of correction parameters are programmed for the specified duration (in units
	of 1 symbol period or 3.692 us). The resulting waveform can be used in conjunction with external
	measurements to find the correction values that result in the lowest Tx RSB and Tx DC values.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iListSize = Number of steps that will be in the sweep.  For each step, there is an element
	                   in the other input arrays (Alpha, Beta, IDC, QDC, Segement length)

	\param aiAlpha = input, Array of Alpha value set during first segment (one of the two Tx RSB correction parameters)
	\param aiBeta = input, Array of Beta value set during first segment (one of the two Tx RSB correction parameters)
	\param aiI_DC_Correction = input, Array of DC corrections on I channel
	\param aiQ_DC_Correction = input, Array of DC corrections on Q channel
	\param aiSegmentLength = input, Array of segment length values, units are 3.692 us (microseconds)
	\param piStatus = output, 0 - Success, 1 - Failure

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_TX_RSB_DC_SWEEP(
				HANDLE hResourceContext,
				unsigned char iListSize,
				short* aiAlpha,
				short* aiBeta,
				char* aiI_DC_Correction,
				char* aiQ_DC_Correction,
				unsigned short* aiSegmentLength,
				unsigned short* piStatus
				);

	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.11 GSM_DETECTOR_CAL

	This API is used to calibrate the transmit RF chipset's output power to expected levels.

	This is required to ensure that process variations do not cause variation in output power across different phones.

	This must be done prior to FTM_GSM_POLAR_TX_SWEEP_CAL, which is used to calibrate the PA's non-linearity.


	In order to calibrate the RF chip's output power, the RF gain setting is varied and an internal power
	detector is read. This command then searches through different gain settings until a required power detector
	reading is obtained.

	The inputs to this command are the required power detector setting (in units of unsigned 8-bits)
	and a tolerance value. The command then settles to a power detector setting in the range -
	Required detector settings - tolerance <= final reading <= Required detector settings + tolerance

	Once this calibration is completed, the resulting value is programmed to hardware.

	In addition, the command computes the gain settings required for cold temperature and
	hot temperature conditions.  These values are optionally stored in NV for future use during
	temperature compensation. The command also accepts a flag specifying whether the resulting
	gain settings (at cold, room and hot temperature) should be stored to NV.

	When the flag is true, the results are stored to NV.
	The NV item names used are:
	\code
       NV_<band>_PA_TEMP_COMP_INDEX_10_I.
          - Each NV item has an array of numbers where the results are stored. The order in which
            the results are stored is illustrated below:

               - NV_<band>_PA_TEMP_COMP_INDEX_10_I.value[0] = cold temp setting
			                  -                             = max( room temp setting - 20, 0)

               - NV_<band>_PA_TEMP_COMP_INDEX_10_I.value[1] = room temp setting.
               - NV_<band>_PA_TEMP_COMP_INDEX_10_I.value[2] =  high temp setting.
                                                            = min( room temp setting + 60, 255)
	\endcode
	\param iDetVal	= Input, This is the target power detector code to be achieved
	\param iTol		= Input, This is the tolerance allowed when searching for the target value.
	\param iStoreRes	= Input,
		\code
            0-	Do not write the results to NV.
            1-	Write the results to NV.
		\endcode

	\param piVgaOut	= Output, Gain setting that causes the target power detector setting. This
	              Output, is the "room temp setting" value that is written to NV.
	\param piDetOut	= Output, Final power detector setting that was achieved. This should be within +/-
	              tolerance of required target, unless the search could not converge within
				  the required limit.
	\param piStatus	=  Output,
	    \code
            0 - Success
            0xFFFF - Failure. The required target could not be achieved within the given tolerance.
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_DO_TX_DETECTOR_CAL(
										HANDLE hResourceContext,
										unsigned char iDetVal,
										unsigned char iTol,
										unsigned char iStoreRes,
										unsigned char* piVgaOut,
										unsigned char* piDetOut,
										unsigned short* piStatus
										);

	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.xx GSM_KVCO_CAL

	This API is used to calibrate the VCO of the GSM Tx.

	This must be done prior to FTM_GSM_POLAR_TX_SWEEP_CAL, which is used to calibrate the PA's non-linearity.

	\param iLowChan	= Input, First channel. (Low edge of the band)
	\param iHiChan	= Input, Second channel. (High edge of the band)
	\param piLowChanKvco	= Output, First channel Kvco Value
	\param piHiChanKvco 	= Output, Second channel Kvco Value

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_DO_TX_KV_CAL(
										HANDLE hResourceContext,
										unsigned short iLowChan,
										unsigned short iHiChan,
										unsigned short *piLowChanKvco,
										unsigned short *piHiChanKvco
										);

	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.xx GSM_KVCO_CAL_V2

	This API is used to calibrate the VCO of the GSM Tx - multiple bands/channels in one command

	This must be done prior to FTM_GSM_POLAR_TX_SWEEP_CAL, which is used to calibrate the PA's non-linearity.

	\param iNumBands	= Input, Number of Bands
	\param iNumTxCycles	= Input, Number of Tx Cycles
	\param iNumMeas	= Input, Number of measurements / cycle
	\param piRfModeList 	= Input, List of RF Modes
	\param piKvChanCode 	= Input/Output. Input : Channel List, 2 per band, one low and one high.
                                        Output: Kv Code List, 2 per band, per channel


	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_DO_TX_KV_CAL_V2(
                                                      HANDLE hResourceContext,
                                                      unsigned short iNumBands,
                                                      unsigned short iNumTxCycles,
                                                      unsigned short iNumMeas,
                                                      unsigned short *piRfModeList,
                                                      unsigned short *piKvChanCode
                                                      );
	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.12 TX_4xFMOD_SWEEP

	This API is used to measure the RF setting that yields the lowest spur at the 4xfMod frequency.
	The 4xfMod frequency is offset from the modulating frequency by 4 times the modulating frequency.

	The modulating frequency used in this command is 13/192 MHz or 67.7kHz. Therefore this spur
	would be at 67.7+4*67.7 = 5*67.7 kHz or at 67.7-4*67.7 = -3*67.7kHz.

	Each possible set of RF settings that can affect this spur is identified by a unique index.

	This command turns on the transmitter and steps through all possible indices.

	The first step is considered a trigger and the RF setting for this step should be ignored.
	In order to trigger the measurement instrument on the first step, the user must first call the
	FTM_SET_TWOTONE_FREQ_OFFSET api to set the frequency offset to the 4xfMod frequency.
	This will generate a tone at the 4xfmod frequency for the first step.

	Following this, the remainder of the steps will each be programmed at one of the possible
	RF indices. Thus steps 2 - N of the sweep will cycle through RF settings 1 to (N-1).
	The command accepts the following 2 inputs:

		1.	The duration of each step in units of symbols (i.e 3.692us). The duration must not
		    be set very low, or else the measuring instrument will not be able to distinguish
			between steps. This number may be chosen based on the measurement resolution.

		2.	The trigger level (in units of DAC level). This turns on the transmitter to the
		    specified DAC level. In the first step this transmit power will be at the frequency
			offset specified by FTM_SET_TWOTONE_FREQ_OFFSET. Following the first step, this
			transmit power will move to 67.7 kHz.

	The measurement box (spectrum analyzer) must be setup to measure the spur at the specified
	4xfmod frequencies to capture this sweep. The user (or program that calls this API) may then
	gather results of this sweep and write the best index to NV item name - NV_<band>_PA_TEMP_COMP_INDEX_11_I.

	Note - This command will not write to NV. The user is responsible for measuring the sweep,
	       finding the best index and writing that index to the above mentioned NV item.

	\param iSegLength		= Duration of each step in units of symbols per step
	\param iDACLevel		= DAC level of trigger step.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_TX_4X_FMOD_SWEEP(
									HANDLE hResourceContext,
									unsigned short iSegLength,
									unsigned short iDACLevel
									);


	/******************************************************************************/
	/**
	Factory Test Mode GSM Polar Command 2.xx TX_CS_SWEEP

	This API turns on the transmitter and sweeps through the specified DC correction
	parameters. Each set of correction parameters are programmed for the specified duration (in units
	of 1 symbol period or 3.692 us). The resulting waveform can be used in conjunction with external
	measurements to find the correction values that result in the lowest Tx DC (Carrier Suppression) values.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iListSize = Number of steps that will be in the sweep.  For each step, there is an element
	                   in the other input arrays (IDC, QDC, Segement length)

	\param aiI_DC_Correction = input, Array of DC corrections on I channel
	\param aiQ_DC_Correction = input, Array of DC corrections on Q channel
	\param aiSegmentLength = input, Array of segment length values, units are 3.692 us (microseconds)
	\param piStatus = output, 0 - Success, 1 - Failure

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_TX_CS_SWEEP(
				HANDLE hResourceContext,
				unsigned char iListSize,
				short* aiI_DC_Correction,
				short* aiQ_DC_Correction,
				unsigned short* aiSegmentLength,
				unsigned short* piStatus
				);

	/******************************************************************************/
	/**
	Factory Test Mode GSM Set SMPS PDM Command

	This API is used in QE2 Targets for PAC DAC Calibration and PA DC DC PDM calibration.

	\param  iPdm   : SMPS PDM value.

	\return true if successful, false if fail.

	\warning  none

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_SET_SMPS_PDM(HANDLE hResourceContext,unsigned short iPdm);

/******************************************************************************
						GSM Linear Tx FTM
*******************************************************************************/

	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.x.xx Tx Set PA Range

		Sets up Linear PA Range

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotNum = input, Specifies the slot for which the PA range is set
	\param iPaRange = input, Specifies the PA Range to be set.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_GSM_LINEAR_PA_RANGE(HANDLE hResourceContext, unsigned short iSlotNum,
    unsigned short iPaRange );

	/******************************************************************************/
	/**
	Factory Test Mode GSM Commands 3.x.xx DA Calibration

		GSM Tx DA Calibration

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iListSize = input, Number of segments
	\param aiSegLength = input, array, Duration of each segment. Unit 3.692uS
	\param aiRgi = input, array, Rgi of each segment
	\param abGsmMode = input, array, Mode of each segment. GSM mode - 1, EDGE Mode - 0
	\param aiPaRange = input, array, PA Range of each segment

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_DA_CAL(HANDLE hResourceContext,
				unsigned short iListSize,
				unsigned short*  aiSegLength,
				unsigned char *  aiRgi,
				unsigned char *  aiGsmMode,
				unsigned char *  aiPaRange
				);

   /******************************************************************************/
   /**
   Factory Test Mode GSM Polar Command x.x Polar Tx PreDistortion Cal

   This API allows for AMAM and AMPM calibration of the PA. The inputs are the preceding DC duration,
   the edge duration and the following DC duration

   \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

   \param  iPreDcDuration  : Duration of the preceding DC waveform (Units : Quarter Symbols)

   \param  iEdgeDuration   : Duration of the calibrated EDGE waveform (Units : Quarter Symbols)

   \param  iCalRgi : Calibration RGI (Units : None)

   \param  piDigScale : Return Scaling Factor (Units : None)

   \return true if successful, false if fail.

   \warning  none

   *******************************************************************************/
   QLIB_API unsigned char QLIB_FTM_TX_CFG2_AMAM_SWEEP(HANDLE hResourceContext,
      unsigned long iPreDcDuration, unsigned long iEdgeDuration,
      unsigned long iCalRgi, unsigned long * piDigScale );

   /******************************************************************************/
   /**
   Factory Test Mode GSM Polar Command x.x Polar Tx PreDistortion Cal

   This API allows for AMAM and AMPM calibration of the PA. The inputs are the
   the edge duration and the following DC duration

   \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

   \param  iDcDuration  : Duration of the DC waveform (Units : Quarter Symbols)

   \param  iEdgeDuration   : Duration of the calibrated EDGE waveform (Units : Quarter Symbols)

   \param  iCalRgi : Calibration RGI (Units : None)

   \param  iWaveformType : Waveform Type to be used. Default 0.

   \param  piDigScale : Return Scaling Factor (Units : None)

   \return true if successful, false if fail.

   \warning  none

   *******************************************************************************/
   QLIB_API unsigned char QLIB_FTM_TX_CFG2_AMAM_SWEEP_V2(HANDLE hResourceContext,
      unsigned long iDcDuration, unsigned long iEdgeDuration,
      unsigned long iCalRgi, unsigned long iWaveformType, unsigned long * piDigScale );

	/******************************************************************************/
	/**
	Factory Test Mode GSM Command API Doc CL93-V5370-1 section 3.1.xx Cmd Id 247 FTM_GSM_SET_LINEAR_RGI Set Linear RF Gain Index

	This API forces the transmitter to use the specified RF gain index. When this API is used the
	baseband (TX gain) setting will be switched to default (i.e. the value in the NV item
	-NV_GSM_LINEAR_TX_GAIN_PARAM_I for GMSK transmit or to NV_EDGE_LINEAR_TX_GAIN_PARAM_I for 8PSK transmit).
	The pa range is held at that current setting.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iSlotNum = input, Slot number to which this setting should be applied. The slot number should correspond
						to the slot number in the TX frame matrix and the Tx Frame matrix should reflect this
						slot as being on , else this API has no effect
	\param  iRgiIndex = input, The RF gain index to use
	\param  iModType = input, Flag specifying if the modulation type is GSM/EDGE . 1- refers to GSM and 0 - EDGE

	\return true if successful, false if fail.

	\warning  none

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_SET_LINEAR_RGI( HANDLE hResourceContext,
														unsigned short iSlotNum,
														unsigned short iRgiIndex,
														unsigned char iModType
														);


	/******************************************************************************/
	/**
	Factory Test Mode GSM Command API Doc CL93-V5370-1 section 3.1.xx Cmd Id 308 FTM_GSM_TX_ENVDC_CS_SWEEP Envelope DC Carrier Suppression Sweep

	This API is only used for targets with Linear PAs. This API is very similar to the carrier suppression
	sweep that is performed by applying a IQ DC offset on the IQ lines. The only difference here is that
	the offset is applied to the Envelope path, in a linear target. On Linear targets, the RF impairment
	that causes carrier leakage can be modeled as a DC offset on the envelope path. To counteract this
	impairment, an equal and opposite DC offset can be applied to the Envelope path at baseband.
	This command turns programs a CW tone and turns on the transmitter to transmit at an offset of about
	200Khz from center frequency. It then sweeps through a number of DC offset values. The call box should
	be set to measure the carrier leakage at center frequency. The call box returns the amplitude of the
	carrier leakage across all the steps to the PC tools , which then determines the DC offset value
	corresponding to the lowest carrier leakage.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iNumSteps = input, Number of steps
	\param  aiStepDuration = input, array, duration of step in units of quarter symbols (i.e., 0.923 us)
	\param  aiDcValue = input, array, DC values

	\return true if successful, false if fail.

	\warning  none

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_TX_ENVDC_CS_SWEEP( HANDLE hResourceContext,
														   unsigned short iNumSteps,
														   unsigned short* aiStepDuration,
														   unsigned short* aiDcValue
														   );

/******************************************************************************
						PMIC FTM
*******************************************************************************/


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 2.1  RTC Set or Get Time Command

	Sets or gets the phone's real time clock.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param	iReadWrite = 0 - Set Time, 1 - Get Time
	\param	iTimeMode = 0 - 12 hour format (AM), 1 - 12 hour format (PM), 2 - 24 hour format
	\param	iMonth = Month to set/get (1...12), 1 - January...12 - December
	\param	iDay = Day of Month.  Valid range is [0,31]
	\param	iYear = Year to set/get.  Valid range is [1980,2116]
 	\param	iHour = Hour field of RTC time to set/get.  Valid range depends on time_mode field.
						For time_mode = 0 or 1, valid range is [1,12].  For time_mode = 2, valid range is [0,23].
	\param	iMinute = Minute field of RTC time to set/get.  Valid range is [0-59]
	\param  iSecond =Second field of RTC time to set/get.  Valid range is [0-59]

	\return true if successful, false if fail.

	\warning If a "Get" operation is selected then the "by reference" values will be updated.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_RTC_SET_GET_TIME
		(
			HANDLE hResourceContext, unsigned char iReadWrite, unsigned char* iTimeMode, unsigned char* iMonth,
			unsigned char* iDay, unsigned short* iYear, unsigned char* iHour, unsigned char* iMinute,
			unsigned char* iSecond
		);

	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 2.2  RTC Set or Get Alarm Time Command

	Sets or gets the phone's real time clock alarm.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param	iReadWrite = 0 - Set Alarm Time, 1 - Get Alarm Time
	\param  iAlarmId = 0 - RTC_ALARM_1, 1 - RTC_ALARM_2, 2 - RTC_ALARM_3,
	        Note: RTC_ALARM_2 and RTC_ALARM_3 are not currently supported.

	\param	iTimeMode = 0 - 12 hour format (AM), 1 - 12 hour format (PM), 2 - 24 hour format
	\param	iMonth = Month to set/get (1...12), 1 - January...12 - December
	\param	iDay = Day of Month.  Valid range is [0,31]
	\param	iYear = Year to set/get.  Valid range is [1980,2116]
 	\param	iHour = Hour field of RTC time to set/get.  Valid range depends on time_mode field.
					For time_mode = 0 or 1, valid range is [1,12].  For time_mode = 2, valid range is [0,23].
	\param	iMinute = Minute field of RTC time to set/get.  Valid range is [0-59]
	\param  iSecond =Second field of RTC time to set/get.  Valid range is [0-59]

	\return true if successful, false if fail.

	\warning If a "Get" operation is selected then the "by reference" values will be updated.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_RTC_SET_GET_ALARM_TIME(
							HANDLE hResourceContext, unsigned char iReadWrite, unsigned char* iAlarmId,
							unsigned char* iTimeMode, unsigned char* iMonth,
							unsigned char* iDay, unsigned short* iYear, unsigned char* iHour, unsigned char* iMinute,
							unsigned char* iSecond);


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 2.3  RTC Stop Command

	Stop the real time clock

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_RTC_STOP( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 2.4  RTC Get Alarm Status Command

	Get the alarm status

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iAlarmStatus = Status bits.  Alarm 1 trigger status is returned in bit 0 of alarm_status.
	                       Alarms 2 and 3 are not currently supported, so alarm_status[7:1]
						   will always be 'b0000000.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_RTC_GET_ALARM_STATUS( HANDLE hResourceContext, unsigned char* iAlarmStatus );

	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 2.5  RTC Disable Alarm Command

	Disable a RTC alarm

	\param iAlarmId = Alarm to disable, 0 - RTC_ALARM_1, 1 - RTC_ALARM_2, 2 - RTC_ALARM_3
		              Note: RTC_ALARM_2 and RTC_ALARM_3 are not currently supported.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_RTC_DISABLE_ALARM( HANDLE hResourceContext, unsigned char iAlarmId );


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 2.6  RTC Set/Get Time Adjust Command

	Get or set the RTC time adjustment factor

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iReadWrite = 0 - Set Time Adjust, 1 - Get Time Adjust
	\param iTimeAdjust = 32 kHz clock adjustment to set in RTC hardware, or get the current value
	                          from hardware.  Valid range is [0,127].  Actual adjustment is
							  (time_adjust-64)*3.05ppm

	\return true if successful, false if fail.

	\warning if iReadWrite = 0, then the by-reference value in iTimeAdjust will be updated

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_RTC_SET_GET_TIME_ADJUST
		( HANDLE hResourceContext, unsigned char iReadWrite, unsigned char* iTimeAdjust );


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 3.1  Set Charger Switch Command

	Configure the charger switch

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param   iChargerSwitchType =
	\code
               0 - CHG_SWITCH_WALL_CHGR
               1 - CHG_SWITCH_BATTERY_TRANSISTOR
               2 - CHG_SWITCH_WALL_PULSE_CHGR
               3 - CHG_SWITCH_VCP
               4 - CHG_SWITCH_BATT_ALARM
               5 - CHG_SWITCH_COIN_CELL
               6 - CHG_SWITCH_USB_CHGR
               7 - CHG_SWITCH_APP_CODE

	\endcode
               Note.  In the case of chg_switch_type = 7, this represents the application level code
			   that handles the charger state machine.

			   Disabling this switch resets the state machine and initializes the charger to a default state.

	\param   iChargerSwitchCommand = 0 - Disable Switch, 1 - Enable Switch

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_CHG_SET_SWITCH_STATE
		( HANDLE hResourceContext, unsigned char iChargerSwitchType, unsigned char iChargerSwitchCommand );


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 3.2.1  Wall Pulse Charger Config

	Configure wall pulse charging

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iChargerType = 0 - Q_LOW_SIDE, 1 - Q_HIGH_SIDE
	\param iTimeOn = Time on during pulse cycle
		\code
			0 - TON_62p5_MS
			1 - TON_125_MS
			2 - TON_250_MS
			3 - TON_500_MS

		\endcode
	\param iTimeOff = Time off during pulse cycle
		\code
			0 - TOFF_62p5_MS
			1 - TOFF_125_MS
			2 - TOFF_250_MS
			3 - TOFF_500_MS

		\endcode
	\param iTimeDone = Represents a t_done time as a multiple of the configured t_off time.
		\code
				0 - TOFF_X_16
				1 - TOFF_X_32
				2 - TOFF_X_64
				3 - TOFF_X_128

		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_CONFIG_WALL_PULSE_CHGR (
					HANDLE hResourceContext, unsigned char iChargerType,
					unsigned char iTimeOn, unsigned char iTimeOff, unsigned char iTimeDone
					);


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 3.2.2  VBATT detect voltage Config

	Voltage threshold to enable wall pulse charging

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iVbattDetectVoltage = Voltage level in mV

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_CONFIG_WALL_PULSE_CHGR_VBAT_DET
		( HANDLE hResourceContext, unsigned char iVbattDetectVoltage );


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 3.2.3  Wall Charger Transistor Limits Config

	Configure the voltage and current limits of the wall charger transistor

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iChargerMaxCurrent = Maximum current throught the wall charger.
	                                 The current is represented by a voltage across a sense resistor, typically 0.1 ohm.
		\code

        0 - (010mV)/R
        1 - (020mV)/R
        2 - (030mV)/R
        3 - (040mV)/R
        4 - (050mV)/R
        5 - (060mV)/R
        6 - (070mV)/R
        7 - (080mV)/R
        8 - (090mV)/R
        9 - (100mV)/R
        10 - (110mV)/R
        11 - (120mV)/R
        12 - (130mV)/R
        13 - (140mV)/R
        14 - (150mV)/R
        15 - (160mV)/R
        16 - (170mV)/R
        17 - (180mV)/R
        18 - (190mV)/R
        19 - (200mV)/R
        20 - (210mV)/R
        21 - (220mV)/R
        22 - (230mV)/R
        23 - (240mV)/R
        24 - (250mV)/R
        25 - (260mV)/R
        26 - (270mV)/R
        27 - (280mV)/R
        28 - (290mV)/R
        29 - (300mV)/R

		\endcode

	\param iChargerMaxVoltage = Maximum wall transistor voltage.
		\code
			0 - VMAXSEL_4000mV
			1 - VMAXSEL_4025mV
			2 - VMAXSEL_4050mV
			3 - VMAXSEL_4075mV
			4 - VMAXSEL_4100mV
			5 - VMAXSEL_4125mV
			6 - VMAXSEL_4150mV
			7 - VMAXSEL_4175mV
			8 - VMAXSEL_4200mV
			9 - VMAXSEL_4225mV
			10 - VMAXSEL_4250mV
			11 - VMAXSEL_4275mV
			12 - VMAXSEL_4300mV
			13 - VMAXSEL_4325mV
			14 - VMAXSEL_4350mV
			15 - VMAXSEL_4375mV

		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_CONFIG_WALL_CHGR_TRANSISTOR_LIMITS
		( HANDLE hResourceContext, unsigned char iChargerMaxCurrent, unsigned char iChargerMaxVoltage );


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 3.2.4  Trickle Charger Config

	Configure the trickle charger limits

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iChargerMaxCurrent = Maximum trickle charger current.
		\code
			0 - IMAX_00mA
			1 - IMAX_20mA
			2 - IMAX_30mA
			3 - IMAX_40mA
			4 - IMAX_50mA
			5 - IMAX_60mA
			6 - IMAX_70mA
			7 - IMAX_80mA

		\endcode


	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_CONFIG_TRICKLE_CHARGER
		( HANDLE hResourceContext, unsigned char iChargerMaxCurrent );


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 3.2.5  Coin Cell Charger Config

	Set the coin cell charger configuratin

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iVoltageSetting = Coin Cell voltage setting
		\code
			0 - VSET_3p0V
			1 - VSET_3p1V
			2 - VSET_3p2V.

		\endcode
	\param iResistorSetting = Coin Cell resistor setting
		\code
			0 - RSET_2100_Ohms
			1 - RSET_1700_Ohms
			2 - RSET_1200_Ohms
			3 - RSET_800_Ohms

		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_CONFIG_COIN_CELL_CHGR
		( HANDLE hResourceContext, unsigned char iVoltageSetting, unsigned char iResistorSetting );


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 3.2.6  Battery Alarm Config

	Voltage threshold to enable wall pulse charging

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iUpperLimit  = Upper threshold voltage for battery alarm (mV)
	\param iLowerLimit  = Lower threshold voltage for battery alarm (mV)
	\param iHysteresisSetting  = Hysteresis setting.
		\code
			0 - HYST_122us
			1 - HYST_244us
			2 - HYST_488us
			3 - HYST_976us

		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_CONFIG_BATT_ALARM( HANDLE hResourceContext, unsigned short iUpperLimit,
														unsigned short iLowerLimit, unsigned char iHysteresisSetting );


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 3.2.7  USB Charger Transistor Limit Config

	Configure the USB charger transistor

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iMaxCurrent  = Maximum current through USB pass transistor.
	                           Current is given as a voltage across a sense resistor, typically 0.1 ohm.
		\code
			0 - IMAX_010mV_div_R
			1 - IMAX_020mV_div_R
			2 - IMAX_030mV_div_R
			3 - IMAX_040mV_div_R
			4 - IMAX_050mV_div_R
			5 - IMAX_060mV_div_R
			6 - IMAX_070mV_div_R
			7 - IMAX_080mV_div_R
			8 - IMAX_090mV_div_R
			9 - IMAX_100mV_div_R
			10 - IMAX_110mV_div_R
			11 - IMAX_120mV_div_R
			12 - IMAX_130mV_div_R
			13 - IMAX_140mV_div_R
			14 - IMAX_150mV_div_R
			15 - IMAX_160mV_div_R
			16 - IMAX_170mV_div_R
			17 - IMAX_180mV_div_R
			18 - IMAX_190mV_div_R
			19 - IMAX_200mV_div_R

		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_CONFIG_USB_TRANSISTOR_LIMITS
		( HANDLE hResourceContext, unsigned char iMaxCurrent );


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 3.2.8  Charger Power Control Limit Config

	Configure the charger power control limit

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iChargerType = Select Charger type to configure.
		\code
			0 - WALL_CHARGER
			1 - USB_CHARGER

		\endcode

	\param iMaxPower = Maximum power delivered by charger.
		\code
			0 - PMAXSEL_DISABLE
			1 - PMAXSEL_400mW
			2 - PMAXSEL_500mW
			3 - PMAXSEL_600mW
			4 - PMAXSEL_750mW
			5 - PMAXSEL_1000mW
			6 - PMAXSEL_1500mW
			7 - PMAXSEL_2000mW

		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_CONFIG_PWR_CTRL_LIMIT(
							HANDLE hResourceContext,
							unsigned char iChargerType,
							unsigned char iMaxPower );


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 4.1  Configure Analog Mux

	Configure the analog multiplexer

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iMuxSelect = Select AMUX channel to route to HKADC block.
	                          Built-in prescaler value shown in parenthesis.
		\code
			0 - ADC_MUXSEL0 (2/3)
			1 - ADC_MUXSEL1 (1/2)
			2 - ADC_MUXSEL2 (1/8)
			3 - ADC_MUXSEL3 (none)
			4 - ADC_MUXSEL4 (1/2)
			5 - ADC_MUXSEL5 (none)
			6 - ADC_MUXSEL6 (none)
			7 - ADC_MUXSEL7 (none)
			8 - ADC_MUXSEL8 (none)
			9 - ADC_MUXSEL9 (none)
			10 - ADC_MUXSEL10 (2/5)
			11 - ADC_MUXSEL11 (none)
			12 - ADC_MUXSEL12 (none)
			13 - ADC_MUXSEL13 (none)
			14 - ADC_MUXSEL14 (none)
			15 - ADC_MUXSEL15 (disables AMUX)

		\endcode

	\param iMuxScale = Offset and gain settings to be applied to the input voltage.  Offset and gain applied after prescaler stage.
							(Offset [Volts],Gain) shown in parenthesis
		\code
			0 - ADC_MUXSCALE0        (0, 1)
			1 - ADC_MUXSCALE1        (0, 1.25)
			2 - ADC_MUXSCALE2        (0, 1.667)
			3 - ADC_MUXSCALE3        (0, 2.5)
			4 - ADC_MUXSCALE4        (0, 5)
			5 - ADC_MUXSCALE5        (0.5, 1.25)
			6 - ADC_MUXSCALE6        (0.5, 1.667)
			7 - ADC_MUXSCALE7        (0.5, 2.5)
			8 - ADC_MUXSCALE8        (0.5, 5)
			9 - ADC_MUXSCALE9        (1, 1.667)
			10 - ADC_MUXSCALE10      (1, 2.5)
			11 - ADC_MUXSCALE11      (1, 5)
			12 - ADC_MUXSCALE12      (1.5, 2.5)
			13 - ADC_MUXSCALE13      (1.5, 5)
			14 - ADC_MUXSCALE14      (2, 5)
			15 - ADC_MUXSCALE15      (0, 1) [bypass mode]

		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_AMUX_CONFIG
		( HANDLE hResourceContext, unsigned char iMuxSelect, unsigned char iMuxScale );

	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 6.1  Enable/Disable VREG Command

	Enable/disable a voltage regulator

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iVRegCmd   = 0 - Disable selected regulators, 1 - Enable selected regulators

	\param iVRegSelect = Voltage regulators to perform the vreg_cmd on.  This can be a logical
	                          OR of any of the following voltage regulator masks.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_VREG_CONTROL
		( HANDLE hResourceContext, unsigned char iVRegCmd, unsigned long iVRegSelect );


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 6.2  Set Voltage Level Command

	Set the voltage level of a regulator

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iVRegSelect = Voltage regulator to set a desired output level.
		\code
			0 - VREG_MSMA
			1 - VREG_MSMP
			2 - VREG_MSME
			3 - VREG_MSMC1
			4 - VREG_MSMC2
			5 - VREG_MSMS
			6 - VREG_MEM
			7 - VREG_GP
			8 - VREG_CAM
			9 - VREG_TCXO
			10 - VREG_PA
			11 - VREG_RFTX
			12 - VREG_RFRX1
			13 - VREG_RFRX2
			14 - VREG_SYNT
			15 - VREG_WLAN
			16 - VREG_USB
			17 - VREG_BOOST
			18 - VREG_MMC
			19 - VREG_RUIM

		\endcode

	\param iVoltageLevel = Voltage level in millivolts to configure the selected regulator.
		\code
				Valid input range depends on the selected regulator ID.

				For VREG_PA,VREG_MSME,VREG_MSMC1,VREG_MSMC2:
					Range = [750, 1525] in 25 mV steps
								   [1550,3050] in 50 mV steps
				For VREG_BOOST and VREG_USB
					Range = [3000, 6100] in 100 mV steps
				For all other regulators
					Range = [1500, 3100] in 50 mV steps.
				NOTE: Command will support any mV input level between the lower and upper limits, but this will get rounded down
						by PMIC driver API to the closest voltage the regulator can support (step size dependent).

					Example:  User selection of VREG_PA = 2940 mV will get converted to 2900 mV.

		\endcode
	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_VREG_SET_LEVEL
		( HANDLE hResourceContext, unsigned char iVRegSelect, unsigned short iVoltageLevel  );

	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 6.X  Get Voltage Level Command

	Get the voltage level of a regulator

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iVRegSelect = Voltage regulator to be queried.
		\code
			0 - VREG_MSMA
			1 - VREG_MSMP
			2 - VREG_MSME
			3 - VREG_MSMC1
			4 - VREG_MSMC2
			5 - VREG_MSMS
			6 - VREG_MEM
			7 - VREG_GP
			8 - VREG_CAM
			9 - VREG_TCXO
			10 - VREG_PA
			11 - VREG_RFTX
			12 - VREG_RFRX1
			13 - VREG_RFRX2
			14 - VREG_SYNT
			15 - VREG_WLAN
			16 - VREG_USB
			17 - VREG_BOOST
			18 - VREG_MMC
			19 - VREG_RUIM

		\endcode

	\param iVoltageLevel = Voltage level in millivolts returned from the selected regulator.
		\code
				Valid input range depends on the selected regulator ID.

				For VREG_PA,VREG_MSME,VREG_MSMC1,VREG_MSMC2:
					Range = [750, 1525] in 25 mV steps
								   [1550,3050] in 50 mV steps
				For VREG_BOOST and VREG_USB
					Range = [3000, 6100] in 100 mV steps
				For all other regulators
					Range = [1500, 3100] in 50 mV steps.
				NOTE: Command will support any mV input level between the lower and upper limits, but this will get rounded down
						by PMIC driver API to the closest voltage the regulator can support (step size dependent).

					Example:  User selection of VREG_PA = 2940 mV will get converted to 2900 mV.

		\endcode
	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_VREG_GET_LEVEL
		( HANDLE hResourceContext, unsigned char iVRegSelect, unsigned short* iVoltageLevel  );

	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 6.3  Config SMPS Mode

	Configure SMPS regulator mode.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iVRegSmps = Voltage regulator to configure
		\code
			0 - SMPS_PA
			1 - SMPS_MSME
			2 - SMPS_MSMC1
			3 - SMPS_MSMC2
			4 - SMPS_BOOST

		\endcode

	\param iSmpsMode =
		\code
			0 - SMPS_MODE_TCXO_EN
			1 - SMPS_MODE_PWM
			2 - SMPS_MODE_PBM
			3 - SMPS_MODE_AUTOMATIC

		\endcode
	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_VREG_CONFIG_SMPS_MODE
		( HANDLE hResourceContext, unsigned char iVRegSmps, unsigned char iSmpsMode  );


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 6.4  Config LDO Powerdown Switch

	Configure LDO power down functionality

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iVRegCmd =
		\code
			0 - Disable LDO Powerdown functionality
			1 - Enable LDO Powerdown functionality

		\endcode

	\param iVRegSelect =
		\code
			0 - PDOWN_MSMP
			1 - PDOWN_MSMA
			2 - PDOWN_WLAN
			3 - PDOWN_RFRX2
			4 - PDOWN_RFRX1
			5 - PDOWN_RFTX
			6 - PDOWN_SYNT
			7 - PDOWN_TCXO
			8 - PDOWN_USB
			9 - PDOWN_MMC
			10 - PDOWN_RUIM
			11 - PDOWN_MSMS
			12 - PDOWN_MEM
			13 - PDOWN_CAM
			14 - PDOWN_GP

		\endcode
	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_VREG_CONFIG_LDO_PD_SW
		( HANDLE hResourceContext, unsigned char iVRegCmd, unsigned char iVRegSelect );


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 6.5  Config Low Power Mode

	Configure LDO low power functionality

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iVRegCmd =
		\code
			0 - Disable Low power functionality
			1 - Enable Low power functionality

		\endcode

	\param iVRegSelect =
		\code
			0 - LP_MSMA
			1 - LP_MSMP

		\endcode
	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_VREG_CONFIG_LP_MODE_CONTROL
		( HANDLE hResourceContext, unsigned char iVRegCmd, unsigned char iVRegSelect);

	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 6.6  Config SMPS Clock

	Configure SMPS clock

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSmpsClockCmd =
		\code
			0 - Select source for SMPS clock
			1 - Select TCXO Divider for SMPS clock

		\endcode

	\param iSmpsClockConfig =
		\code
			For vreg_smps_clk_cmd = 0
			0 - SMPS_CLK_SEL_TCXO
			1 - SMPS_CLK_SEL_RC

			For vreg_smps_clk_cmd = 1
			0 - SMPS_TCXO_DIV_8
			1 - SMPS_TCXO_DIV_10
			2 - SMPS_TCXO_DIV_12
			3 - SMPS_TCXO_DIV_14
			4 - SMPS_TCXO_DIV_16
			5 - SMPS_TCXO_DIV_18

		\endcode
	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_VREG_SMPS_CLK_CONFIG
		( HANDLE hResourceContext, unsigned char iSmpsClockCmd, unsigned char iSmpsClockConfig );


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 7.1  Get Real Time Status Command

	Get interrupt status

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iInterruptStatusId=
		\code
			0 - VALID_CHG_RT_ST
			1 - INVALID_CHG_RT_ST
			2 - VALID_USB_CHG_RT_ST
			3 - INVALID_USB_CHG_RT_ST
			4 - CHG_I_LIMITING_RT_ST
			5 - CHG_P_LIMITING_RT_ST
			6 - PULSE_CHG_DONE_RT_ST
			7 - VCP_IRQ_RT_ST
			8 - T_STAT_CHANGED_RT_ST
			9 - BAT_STAT_CHANGED_RT_ST
			10 - VBAT_DET_RT_ST
			11-  BAT_FET_ON_RT_ST
			12 - KPD_PWR_KEY_ON_RT_ST
			13 - KPD_PWR_KEY_OFF_RT_ST
			14 - RTC_ALRM_RT_ST
			15 - OSC_HALT_RT_ST
			16 - PWR_RST_RT_ST
			17 - SMPL_RT_ST
			18 - CABLE_IN_RT_ST
			19 - OVER_TEMP_RT_ST
			20 - WDOG_TOUT_RT_ST
			21 - KPD_PWRON_EVENT_RT_ST
			22 - USB_BUS_VALID_RT_ST
			23 - USB_SN_VALID_RT_ST
			24 - USB_D_PLUS_HI_RT_ST
			25 - USB_ID_GND_RT_ST
			26 - USB_D_MINUS_HI_RT_ST
			27 - USB_ID_FLOATING_RT_ST
			28 - USB_BOFF_AON_RT_ST
			29 - USB_CARKIT_INT_RT_ST
			38 - MPP01_CHGED_RT_ST
			39 - MPP02_CHGED_RT_ST
			40 - MPP03_CHGED_RT_ST
			41 - MPP04_CHGED_RT_ST
			42 - MPP05_CHGED_RT_ST
			43 - MPP06_CHGED_RT_ST
			44 - MPP07_CHGED_RT_ST
			45 - MPP08_CHGED_RT_ST
			46 - MPP09_CHGED_RT_ST
			47 - MPP10_CHGED_RT_ST
			48 - MPP11_CHGED_RT_ST
			49 - MPP12_CHGED_RT_ST
			50 - MPP13_CHGED_RT_ST
			51 - MPP14_CHGED_RT_ST
			52 - MPP15_CHGED_RT_ST
			53 - MPP16_CHGED_RT_ST

		\endcode

	\param piInterruptCmd = Status returned.
		\code
			0 - Interrupt event real time status not triggered
			1 - Interrupt event real time status triggered

		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_INT_GET_RT_STATUS
		( HANDLE hResourceContext, unsigned char iInterruptStatusId, unsigned char* piInterruptStatus );

	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands 7.2  Clear IRQ Command

	Clear the interrupt status for a specified handler

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iInterruptHandler=
		\code
			0 - VALID_CHG_RT_ST
			1 - INVALID_CHG_RT_ST
			2 - VALID_USB_CHG_RT_ST
			3 - INVALID_USB_CHG_RT_ST
			4 - CHG_I_LIMITING_RT_ST
			5 - CHG_P_LIMITING_RT_ST
			6 - PULSE_CHG_DONE_RT_ST
			7 - VCP_IRQ_RT_ST
			8 - T_STAT_CHANGED_RT_ST
			9 - BAT_STAT_CHANGED_RT_ST
			10 - VBAT_DET_RT_ST
			11-  BAT_FET_ON_RT_ST
			12 - KPD_PWR_KEY_ON_RT_ST
			13 - KPD_PWR_KEY_OFF_RT_ST
			14 - RTC_ALRM_RT_ST
			15 - OSC_HALT_RT_ST
			16 - PWR_RST_RT_ST
			17 - SMPL_RT_ST
			18 - CABLE_IN_RT_ST
			19 - OVER_TEMP_RT_ST
			20 - WDOG_TOUT_RT_ST
			21 - KPD_PWRON_EVENT_RT_ST
			22 - USB_BUS_VALID_RT_ST
			23 - USB_SN_VALID_RT_ST
			24 - USB_D_PLUS_HI_RT_ST
			25 - USB_ID_GND_RT_ST
			26 - USB_D_MINUS_HI_RT_ST
			27 - USB_ID_FLOATING_RT_ST
			28 - USB_BOFF_AON_RT_ST
			29 - USB_CARKIT_INT_RT_ST
			38 - MPP01_CHGED_RT_ST
			39 - MPP02_CHGED_RT_ST
			40 - MPP03_CHGED_RT_ST
			41 - MPP04_CHGED_RT_ST
			42 - MPP05_CHGED_RT_ST
			43 - MPP06_CHGED_RT_ST
			44 - MPP07_CHGED_RT_ST
			45 - MPP08_CHGED_RT_ST
			46 - MPP09_CHGED_RT_ST
			47 - MPP10_CHGED_RT_ST
			48 - MPP11_CHGED_RT_ST
			49 - MPP12_CHGED_RT_ST
			50 - MPP13_CHGED_RT_ST
			51 - MPP14_CHGED_RT_ST
			52 - MPP15_CHGED_RT_ST
			53 - MPP16_CHGED_RT_ST

		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_INT_IRQ_CLR( HANDLE hResourceContext, unsigned char iInterruptHandler );



	/******************************************************************************/
	/**
		Factory Test Mode PMIC Commands 8.1  Set PMIC Pin Drive Level

		The PMIC has three high strength drive pins that are connected to the LCD
		backlight (LCD_DRV pin), the keypad LEDs (KPD_DRV pin), and the vibrator
		(VIB_DRV pin).  Each pin has a programmable drive level as described below.

		FTM_SET_PMIC_DRIVE_LEVEL allows selection of one of three high drive pins
		and selection of the drive level.  A drive level selection of 0 will turn
		off the pin drive.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iHighDrivePinID =  Selects pin for drive level programming, values for this field are:
		\code
              0 = LCD_DRV pin
              1 = KPD_DRV pin
              2 = VIB_DRV pin
		\endcode

		\param iDriveLevel = Programs drive level for selected pin:
		\code
              a) LCD_DRV pin current = drive_level * 10mA.  Valid range is 0-15
              b) KPD_DRV pin current = drive_level * 10mA.  Valid range is 0-15
              c) VIB_DRV pin voltage = drive_level  * 100mV.  Valid range is 0 (off) or 12-31.
		\endcode

		\return true if successful, false if fail.

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_PMIC_DRIVE_LEVEL
		( HANDLE hResourceContext, unsigned char iHighDrivePinID, unsigned char iDriveLevel );

	/******************************************************************************/
	/**
		Factory Test Mode PMIC Commands 8.2  Configure PMIC Speaker Path

		This command will configure the portion of the audio path that goes through
		the PMIC.  The command will support commands to enable/disable the speaker,
		to set the speaker gain, and to set the speaker delay.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iSpeakerCMD =
			\code
                0 - SPKR_DISABLE
                1 - SPKR_ENABLE
                2 - SPKR_MUTE_OFF
                3 - SPKR_MUTE_ON
                4 - SPKR_OFF
                5 - SPKR_ON
			\endcode
		\param iSpeakerGain =
			\code
                0 - SPKR_GAIN_MINUS_16DB
                1 - SPKR_GAIN_MINUS_12DB
                2 - SPKR_GAIN_MINUS_08DB
                3 - SPKR_GAIN_MINUS_04DB
                4 - SPKR_GAIN_00DB
                5 - SPKR_GAIN_PLUS_04DB
                6 - SPKR_GAIN_PLUS_08DB
                7 - SPKR_GAIN_PLUS_12DB
			\endcode

		\param iSpeakerDelay
			\code
                0 - SPKR_DELAY_10MS
                1 - SPKR_DELAY_100MS
			\endcode

		\return true if successful, false if fail.

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_SPKR_CONFIG (
						HANDLE hResourceContext, unsigned char iSpeakerCMD,
						unsigned char iSpeakerGain, unsigned char iSpeakerDelay
						);

	/******************************************************************************/
	/**
		Factory Test Mode PMIC Commands 9.1  Set digital in command

		This command will configure the selected Multi Purpose pin (MPP) to be a digital input pin.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iMPP =	Which MPP we want to configure. Values for this field are:

						\code
						0 - PM_MPP_1
						1 - PM_MPP_2
						2 - PM_MPP_3
						= PM_NUM_MPP_PM6620
						= PM_NUM_MPP_PM6640
						= PM_NUM_MPP_PANORAMIX
						...
						...
						...
						PM_MPP_INVALID

						\endcode

		\param iLevel = The logic level reference that we want to use with this MPP. Values for this field are:

						\code
						0 - PM_MPP__DLOGIC__LVL_MSME
						1 - PM_MPP__DLOGIC__LVL_MSMP
						2 - PM_MPP__DLOGIC__LVL_RUIM
						3 - PM_MPP__DLOGIC__LVL_MMC
						4 - PM_MPP__DLOGIC__LVL_VDD
						\endcode

		\param piStatus = Return status
						\code
						0 = COMMAND_SUCESS
						>0 = Error code
						\endcode

		\return true if successful, false if fail.

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_MPP_CONFIG_DIGITAL_IN(
						HANDLE hResourceContext,
						unsigned char iMpp,
						unsigned char iLevel,
						unsigned short * piStatus);

	/******************************************************************************/
	/**
		Factory Test Mode PMIC Commands 9.2  Set digital out command

		This command will configure the selected Multi Purpose pin (MPP) to be a digital output pin.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iMPP =	Which MPP we want to configure. Values for this field are:

						\code
						0 - PM_MPP_1
						1 - PM_MPP_2
						2 - PM_MPP_3
						= PM_NUM_MPP_PM6620
						= PM_NUM_MPP_PM6640
						= PM_NUM_MPP_PANORAMIX
						...
						...
						...
						PM_MPP_INVALID

						\endcode

		\param iLevel = The logic level reference that we want to configure. Values for this field are:

						\code
						0 - PM_MPP__DLOGIC__LVL_MSME
						1 - PM_MPP__DLOGIC__LVL_MSMP
						2 - PM_MPP__DLOGIC__LVL_RUIM
						3 - PM_MPP__DLOGIC__LVL_MMC
						4 - PM_MPP__DLOGIC__LVL_VDD
						\endcode
		\param iCtrl = The logic level reference that we want to use with this MPP. Values for this field are:

						\code
						0 - PM_MPP__DLOGIC_OUT__CTRL_LOW,    MPP OUTPUT = LOGIC LOW
						1 - PM_MPP__DLOGIC_OUT__CTRL_HIGH,    MPP OUTPUT = LOGIC HIGH
						2 - PM PM_MPP__DLOGIC_OUT__CTRL_MPP,    MPP OUTPUT = CORRESPONDING MPP INPUT (see the note regarding MPP pairs within the description section)
						3 - PM_MPP__DLOGIC_OUT__CTRL_NOT_MPP,   MPP OUTPUT  = CORRESPONDING INVERTED MPP INPUT (see the note regarding MPP pairs within the description section)
						\endcode

		\param piStatus = Return status
						\code
						0 = COMMAND_SUCESS
						>0 = Error code
						\endcode

		\return true if successful, false if fail.

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_MPP_CONFIG_DIGITAL_OUT(
						HANDLE hResourceContext,
						unsigned char iMpp,
						unsigned char iLevel,
						unsigned char iCtrl,
						unsigned short * piStatus);

	/******************************************************************************/
	/**
		Factory Test Mode PMIC Commands 9.3  Set digital inout command

		This command will configure the selected Multi Purpose pin (MPP) to be a digital bidirectional pin.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iMPP =	Which MPP we want to configure. Values for this field are:

						\code
						0 - PM_MPP_1
						1 - PM_MPP_2
						2 - PM_MPP_3
						= PM_NUM_MPP_PM6620
						= PM_NUM_MPP_PM6640
						= PM_NUM_MPP_PANORAMIX
						...
						...
						...
						PM_MPP_INVALID

						\endcode

		\param iLevel = The logic level reference that we want to configure. Values for this field are:

						\code
						0 - PM_MPP__DLOGIC__LVL_MSME
						1 - PM_MPP__DLOGIC__LVL_MSMP
						2 - PM_MPP__DLOGIC__LVL_RUIM
						3 - PM_MPP__DLOGIC__LVL_MMC
						4 - PM_MPP__DLOGIC__LVL_VDD
						\endcode
		\param iPup = The pull-up resistor setting of the selected MPP. Values fro this field are:

						\code
						0 - PM_MPP__DLOGIC_INOUT__PUP_1K          PULL UP = 1  K Ohms
						1 - PM_MPP__DLOGIC_INOUT__PUP_3K          PULL UP = 3  K Ohms
						2 - PM_MPP__DLOGIC_INOUT__PUP_10K        PULL UP = 10  K Ohms
						3 - PM_MPP__DLOGIC_INOUT__PUP_30K        PULL UP = 30  K Ohms

						\endcode

		\param piStatus = Return status
						\code
						0 = COMMAND_SUCESS
						>0 = Error code
						\endcode

		\return true if successful, false if fail.

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_MPP_CONFIG_DIGITAL_INOUT(
						HANDLE hResourceContext,
						unsigned char iMpp,
						unsigned char iLevel,
						unsigned char iPup,
						unsigned short * piStatus);

	/******************************************************************************/
	/**
		Factory Test Mode PMIC Commands 9.4  Set analog in command

		This command will configure the selected Multi Purpose pin (MPP) to be an analog input pin.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iMPP =	Which MPP we want to configure. Values for this field are:

						\code
						0 - PM_MPP_1
						1 - PM_MPP_2
						2 - PM_MPP_3
						= PM_NUM_MPP_PM6620
						= PM_NUM_MPP_PM6640
						= PM_NUM_MPP_PANORAMIX
						...
						...
						...
						PM_MPP_INVALID

						\endcode

		\param iChannel = Which analog mux or analog bus will the selected MPP be routed to. Values for this field are:

						\code
						0 - PM_MPP__AIN__CH_AMUX5
						1 - PM_MPP__AIN__CH_AMUX6
						2 - PM_MPP__AIN__CH_AMUX7
						3 - PM_MPP__AIN__CH_AMUX8
						4 - PM_MPP__AIN__CH_AMUX9
						5 - PM_MPP__AIN__CH_AMUX1
						6 - PM_MPP__AIN__CH_AMUX2
						7 - PM_MPP__AIN__CH_AMUX3

						\endcode

		\param piStatus = Return status
						\code
						0 = COMMAND_SUCESS
						>0 = Error code
						\endcode

		\return true if successful, false if fail.

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_MPP_CONFIG_ANALOG_IN(
						HANDLE hResourceContext,
						unsigned char iMpp,
						unsigned char iChannel,
						unsigned short * piStatus);
	/******************************************************************************/
	/**
		Factory Test Mode PMIC Commands 9.5  Set analog out command

		This command will configure the selected Multi Purpose pin (MPP) to be an analog output pin

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iMPP =	Which MPP we want to configure. Values for this field are:

						\code
						0 - PM_MPP_1
						1 - PM_MPP_2
						2 - PM_MPP_3
						= PM_NUM_MPP_PM6620
						= PM_NUM_MPP_PM6640
						= PM_NUM_MPP_PANORAMIX
						...
						...
						...
						PM_MPP_INVALID

						\endcode

		\param iMpp_switch = This option allows the user to enable/disable the MPP output. Values for this field are:

						\code
						0 - PM_MPP__AOUT__SWITCH_OFF
						1 - PM_MPP__AOUT__SWITCH_ON
						2 - PM_MPP__AOUT__SWITCH_ON_IF_MPP_HIGH
						3 - PM_MPP__AOUT__SWITCH_ON_IF_MPP_LOW

						\endcode

		\param piStatus = Return status
						\code
						0 = COMMAND_SUCESS
						>0 = Error code
						\endcode

		\return true if successful, false if fail.

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_MPP_CONFIG_ANALOG_OUT(
						HANDLE hResourceContext,
						unsigned char iMpp,
						unsigned char iMpp_switch,
						unsigned short * piStatus);
	/******************************************************************************/
	/**
		Factory Test Mode PMIC Commands 9.6  Set current sink command

		This command will configure the selected Multi Purpose pin (MPP) to be a current sink.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iMPP =	Which MPP we want to configure. Values for this field are:

						\code
						0 - PM_MPP_1
						1 - PM_MPP_2
						2 - PM_MPP_3
						= PM_NUM_MPP_PM6620
						= PM_NUM_MPP_PM6640
						= PM_NUM_MPP_PANORAMIX
						...
						...
						...
						PM_MPP_INVALID

						\endcode

		\param iLevel = How much current we want to allow the MPP to sink.  Values for this field are:

						\code
						0 - PM_MPP__I_SINK__LEVEL_5mA
						1 - PM_MPP__I_SINK__LEVEL_10mA
						2 - PM_MPP__I_SINK__LEVEL_15mA
						3 - PM_MPP__I_SINK__LEVEL_20mA
						4 - PM_MPP__I_SINK__LEVEL_25mA
						5 - PM_MPP__I_SINK__LEVEL_30mA
						6 - PM_MPP__I_SINK__LEVEL_35mA
						7 - PM_MPP__I_SINK__LEVEL_40mA

						\endcode

		\param iMpp_switch = This option allows the user to enable/disable the MPP output. Values for this field are:

						\code
						0 - PM_MPP__AOUT__SWITCH_OFF
						1 - PM_MPP__AOUT__SWITCH_ON
						2 - PM_MPP__AOUT__SWITCH_ON_IF_MPP_HIGH
						3 - PM_MPP__AOUT__SWITCH_ON_IF_MPP_LOW

						\endcode

		\param piStatus = Return status
						\code
						0 = COMMAND_SUCESS
						>0 = Error code
						\endcode

		\return true if successful, false if fail.

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_MPP_CONFIG_I_SINK(
						HANDLE hResourceContext,
						unsigned char iMpp,
						unsigned char iLevel,
						unsigned char iMpp_switch,
						unsigned short * piStatus);

	/******************************************************************************/
	/**
		Factory Test Mode PMIC Commands 1.2  Get Voltage Regulator Enumration List

		This command gets supported voltage Regulator enumeration list

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param piNumVreg = Num of supported voltage regulator

		\param piBufferSize =  Size of pBuffer.  The length of enumeration list string is returned with this paramter
							   A value of -1 is to indicate buffer overflow condition

		\param pBuffer = A buffer to store enumeration list string (null character terminated)

		\param piStatus = Return status
						\code
						0 = COMMAND_SUCESS
						>0 = Error code
						\endcode

		\return true if successful, false if fail.

		\warning If the user buffer size is less than enumeration list string length, the function will return false
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_VREG_GET_ENUM_LIST(
						HANDLE hResourceContext,
						unsigned short* piNumVreg,
						short * piBufferSize,
						unsigned char * pBuffer,
						unsigned short *piStatus);

	/******************************************************************************/
	/**
		Factory Test Mode PMIC Commands 1.2  Get Voltage Regulator Enumration List

		This command calls FTM_PMIC_VREG_GET_ENUM_LIST to get supported voltage Regulator enumeration list

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param piNumVreg = Num of supported voltage regulator

		\param aEnumIdList =  An array to store the list of enumeration id

		\param aEnumStrList = An array to store the list of enumeration string

		\param piStatus = Return status
						\code
						0 = COMMAND_SUCESS
						>0 = Error code
						\endcode

		\return true if successful, false if fail.

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_VREG_GET_ENUM_LIST_IN_ARRAY_FORM(
						HANDLE hResourceContext,
						unsigned short* piNumVreg,
						unsigned short aEnumIdList[20],
						unsigned char aEnumStrList[20][8],
						unsigned short *piStatus);


	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands X.X Get PMIC Model

	This command calls FTM_PMIC_GET_MODEL to get PMIC Model ID

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piModel	= PMIC model number:
						\code
						0 = PMIC_IS_PM6610,
						1 = PMIC_IS_PM6620,
						2 = PMIC_IS_PM6640,
						3 = PMIC_IS_PM6650,
						4 = PMIC_IS_PM7500,
						5 = PMIC_IS_PANORAMIX,
						6 = PMIC_IS_INVALID
						\endcode

	\param piStatus = Return status
						\code
						0 = COMMAND_SUCESS
						>0 = Error code
						\endcode

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_GET_MODEL(
								HANDLE hResourceContext,
								unsigned short* piModel,
								unsigned short * piStatus);

	/******************************************************************************/
	/**
		Factory Test Mode PMIC Commands.  Enable/Disable microphone

		This command calls FTM_PMIC_TEST_MIC(10) to command enable/disable the microphone

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iEnable = Enable if iEnable == 1
		                 Disable if iEnable == 0

		\param piStatus = Return status
						\code
						0 = COMMAND_SUCESS
						>0 = Error code
						\endcode

		\return true if successful, false if fail.

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_TEST_MIC_ENABLE(HANDLE hResourceContext, unsigned char iEnable, unsigned short *piStatus);

	/******************************************************************************/
	/**
		Factory Test Mode PMIC Commands.  Set/Get Microphone voltage level.

		This command calls FTM_PMIC_TEST_MIC(10) to set/get microphone voltage level

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

		\param iEnable = Set level if iSet == 1
		                 Get level if iSet == 0

	    \param piVoltageLvl = Voltage Level

							\code
							0  PM_MIC_VOLT_2_00V
							1  PM_MIC_VOLT_1_93V
							2  PM_MIC_VOLT_1_80V
							3  PM_MIC_VOLT_1_73V
							\endcode

		\param piStatus = Return status
						\code
						0 = COMMAND_SUCESS
						>0 = Error code
						\endcode

		\return true if successful, false if fail.

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_TEST_MIC_SET_GET_VOLTAGE_LEVEL(HANDLE hResourceContext, unsigned char iSet, unsigned char* piVoltageLvl, unsigned short* piStatus);

	/******************************************************************************/
	/**
		Factory Test Mode PMIC Commands.  Enable/Disable microphone

		This command calls FTM_PMIC_TEST_RESET (11)

		The Hard Reset command resets all of the PMIC hardware blocks, excluding the RTC

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

		\return true if successful, false if fail.

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_TEST_HARD_RESET(HANDLE hResourceContext);

	/******************************************************************************/
	/**
	Factory Test Mode PMIC Commands  Enable/Disable VREG Command via enumeration

	Enable/disable a voltage regulator through voltage regulator enumeration.

	This command calls PMIC FTM command FTM_PMIC_TEST_VREG_EXT (15)

	This API can only set one regulator at a time.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iVRegCmd   = 0 - Disable selected regulator, 1 - Enable selected regulator

	\param iVRegEnum = Voltage regulator enumeration

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_PMIC_VREG_CONTROL_EXT
		( HANDLE hResourceContext, unsigned char iVRegCmd, unsigned short iVRegEnum );

/******************************************************************************
					cdma2000 FTM
*******************************************************************************/


	/******************************************************************************/
	/**
	CDMA2000 Set the NV_FTM_MODE_I nv item value to either 0 or 1


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iMode = The mode can be either DMSS(0), or FTM(1). The default value is 0.
				   The mode change will not take effect until the next phone reset.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_SET_MODE(
								HANDLE hResourceContext,
								unsigned char iMode);


/******************************************************************************
					cdma2000 FTM non-signaling
*******************************************************************************/
	/******************************************************************************/
	/**
	Enables logging for the CDMA2000 non-signaling commands.  If this is not done, then
	the CDMA2000 NS commands will act only as simple request/response types.

	After this function is called, the cdma2000 non-signaling commands will wait
	for assocated events to occur, before returning.

	The log used to determine searcher state is: 0x119C, FTM_CDMA2000_SRC_TNG_STATUS

	The logs used to determine FER and SER are:
	  0x10D9 - FTM_CDMA2000_RDA2_FRAME_INFO, for MSM6100 and later + SC1X and later
	  0x10C9 - FTM_CDMA2000_RDA_FRAME_INFO, for MSM6000, MSM6025, MSM6050


	The logs used for AGC are FTM logs:
		LOG_FTM2_LOG_1X_AGC = 0x4
		LOG_FTM2_LOG_1X_AGC_C1	= 0x6

  	After this function is called, then the library will begin collecting
	statistics (SER, AGC)


	The function QLIB_FTM_CDMA2000_NS_Stop() should be called when the the CDMA2000 NS
	testing is completed.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param eDR_Type = Dymamic range type, defined by FTM_CDMA2000_NS_DR_Types_Enum in QLib_Defines.h
     \code
      0 = FTM_CDMA2000_NS_DR_85_3  = 85.3dB  dynamic range, min_rssi = -106.0dBm
      1 = FTM_CDMA2000_NS_DR_102_4 = 102.4dB dynamic range, min_rssi = -115.0dBm
     \endcode
	\param dTurnAroundConstant = cdma turn around constant, -73dBm for BC0, -76 for BC1.

	\param bEnableDiversityAGCLog = Enabling AGC Logging for diversity antenna
									This should be set to 0 for non recieve diversity target
									0 = Diversity AGC logging off
									1 = Diversity AGC logging on

	\return true if successful, false if fail.

	\warning Will clear status and enable all CDMA2000 NS statistics, via
	         FTM_CDMA2000_NS_SetStatisticsState()

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_NS_Start(
							HANDLE hResourceContext,
							unsigned char eDR_Type,
							double dTurnAroundConstant,
							unsigned char bEnableDiversityAGCLog);
	/******************************************************************************/
	/**
	This function is same as QLIB_FTM_CDMA2000_NS_Start except addtional flags can be used to 
	NOT turn on RDA and Searcher package.

	If both flags, bEnableFTMLog and bEnableRDALog, are set to true, this function behaves exactly the same as
	QLIB_FTM_CDMA2000_NS_Start
	
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param eDR_Type = Dymamic range type, defined by FTM_CDMA2000_NS_DR_Types_Enum in QLib_Defines.h
     \code
      0 = FTM_CDMA2000_NS_DR_85_3  = 85.3dB  dynamic range, min_rssi = -106.0dBm
      1 = FTM_CDMA2000_NS_DR_102_4 = 102.4dB dynamic range, min_rssi = -115.0dBm
     \endcode
	\param dTurnAroundConstant = cdma turn around constant, -73dBm for BC0, -76 for BC1.

	\param bEnableDiversityAGCLog = Enabling AGC Logging for diversity antenna
									This should be set to 0 for non recieve diversity target
									0 = Diversity AGC logging off
									1 = Diversity AGC logging on
	
	\param bEnableFTMLog = 0 = Not enabling FTM log
	                       1 = Enable FTM log

	\param bEnableSearcherLog = 0 = Not enabling searcher log
	                            1 = enabling searcher log 

	\param bEnableRDALog = 0 = Not enabling RDA Log
						   1 = Enabling RDA log

	\return true if successful, false if fail.

	\warning Will clear status and enable all CDMA2000 NS statistics, via
	         FTM_CDMA2000_NS_SetStatisticsState()

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_NS_Start_V2(
							HANDLE hResourceContext,
							unsigned char eDR_Type,
							double dTurnAroundConstant,
							unsigned char bEnableDiversityAGCLog,
							unsigned char bEnableFTMLog,
							unsigned char bEnableSearcherLog,
							unsigned char bEnableRDALog);


	/******************************************************************************/
	/**
	Disables logging for the CDMA2000 non-signaling commands.  This should be done
	after FTM_CDMA2000_NS_StartLogging() is called, and after all CDMA2000 NS testing is
	completed.

	QLIB_FTM_LOG_StopFTM_Log( HANDLE, LOG_FTM2_LOG_1X_AGC ) = stop the primary AGClog

	If diverisity was enabled then QLIB_FTM_LOG_StopFTM_Log( HANDLE, LOG_FTM2_LOG_1X_AGC_C1 ) to stop
	the diversity AGC log

	QLIB_DIAG_ClearAllLogCodes( HANDLE, LOG_EQUIP_ID_1X	) to stop all RDA and searcher logs

	\return true if successful, false if fail.

	\warning The log mask for the 1X equipment ID will be cleared

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_NS_Stop( HANDLE hResourceContext );


	/******************************************************************************/
	/**
	Turn on or off logging for a certain type of 1xEV-DO non-signaling log

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param eLogType = log type to control
		\code
          FTM_CDMA2000_NS_Log_Searcher,  //!<' CDMA2000 Searcher (LOG_CODE 0x119C)
          FTM_CDMA2000_NS_Log_AGC_C0,    //!<' FTM2 log, sub log 5, for Primary AGC
          FTM_CDMA2000_NS_Log_AGC_C1,    //!<' FTM2 log, sub log 7, for Diversity AGC
          FTM_CDMA2000_NS_Log_RDA2,      //!<' CDMA2000 (LOG_CODE 0x10D9), used for SER
          FTM_CDMA2000_NS_Log_RDA,       //!<' CDMA2000 (LOG_CODE 0x10C9), used for SER
		\endcode
	\param bEnableStatistics = true to enable statistics of the specified log type

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_NS_SetStatisticsState(
							HANDLE hResourceContext,
							unsigned char eLogType,
							unsigned char bEnableStatistics);

	/******************************************************************************/
	/**
	CDMA2000 Non-signaling,

		Reset the entire internal status structure, including all averages

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param bIgnore1stRDA = true to ignore the first RDA log, which may have bad data if the
	                       signal generator settings were just changed.
	\return true if successful, false if failure

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_NS_ClearStatus(
							HANDLE hResourceContext,
							unsigned char bIgnore1stRDA);

	/******************************************************************************/
	/**
	CDMA2000 Non-signaling,

		Reset the SER/FER internal status structure.  This will not affect
		the other status items, such as AGC

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\return true if successful, false if failure

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_NS_ClearFER_Status(
							HANDLE hResourceContext);

	/******************************************************************************/
	/**
	CDMA2000 Non-signaling,
			Returns a copy of the internal state.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pCDMA2000_NS_State = reference to a FTM_CDMA2000_NS_Status_Struct structure that will be
	                        filled in with the state information.
							Structure type is FTM_CDMA2000_NS_Status_Struct, defined in QLib_Defines.h



	\return true if all operations succeeded and the correct event messages were received

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_NS_GetStatus(
							HANDLE hResourceContext,
							void* pCDMA2000_NS_State );


	/******************************************************************************/
	/**
	CDMA2000 Non-signaling,
			Sets the radio configuratoin and FCH rate set to be used for calculating SER.
			This function can also be used for setting up SER measurements in signaling
			mode.

			In signaling mode, the function QLIB_DIAG_CDMA2000_SetSER_State() should be
			used to control the capture of frame data and calculation of SER results.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param eCurrentCDMA2000_RC = Radio configuration to be used. Of type FTM_CDMA2000_NS_FWD_RC_Enum
	                             defined in QLib_Defines.h

	\param eCurrentCDMA2000_DataRate = FCH Data rate being used.  Of type  FTM_CDMA2000_NS_REV_FCH_Rates_Enum
										defined in QLib_Defines.h


	\return true if set successfully

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_NS_SetSER_RCandRS(
								HANDLE hResourceContext,
								unsigned long eCurrentCDMA2000_RC,
								unsigned long eCurrentCDMA2000_DataRate);


	/******************************************************************************/
	/**
	CDMA2000 Non-signaling
		Returns a subset of the cdma2000 NS status--the current FCH SER and FER with the
		option to set a minimum number.

		Will wait until a certain number of symbols or frames have been counted or a time out expires.

		If number of frames is the measurment matrics, set iMinimumNumSymbols = 0
		For example, Get number of FER/SER over 100 frames,

		FTM_CDMA2000_NS_Get_FCH_SER_FER(0,
										100,
										&iTotalSymbols,
										&iTotalErrorSymbols,
										&iTotalFrames,
										&iTotalFrameErrors,
										&dSER_Calculated,
										&dFER_Calculated,
										&iTimeOut_ms);

		If number of symbols is the measurement matrics, set iMinimumNumFrames = 0

		For example, Get number of FER/SER over 2000 symbols,

		FTM_CDMA2000_NS_Get_FCH_SER_FER(2000,
										0,
										&iTotalSymbols,
										&iTotalErrorSymbols,
										&iTotalFrames,
										&iTotalFrameErrors,
										&dSER_Calculated,
										&dFER_Calculated,
										&iTimeOut_ms);

		If instantenous SER/FER measurments are desired, set both iMinimumNumFrames and iMiniNumSymbols to 0

		if both iMinimumNumFrames and iMiniNumSymbols are non-zero, the function will return after both iMinimumNumFrames and
		iMinimumNumSymbols are reached.


	\param iMinimumNumSymbols = input, minimum number of symbols to capture, set 0
	                            to specify there is no minimum number of symbols to wait for
	\param iMinimumNumFrames  = input, mimimum number of frames to capture, , set 0
	                            to specify there is no minimum number of frames to wait for

								If both iMinimumNumSymbols and iMinimumNumFrames  are set to zero then the
								FER/SER status is returned immediately.

	\param iTotalSymbols = output, total number of symbols that have been recorded
	\param iTotalErrorSymbols = output, total symbol errors recorded
	\param iTotalFrames = output, total frames recorded
	\param iTotalFrameErrors = output, total number of frame errors
	\param dSER_Calculated = output, current SER, since the last time that statistics were cleared.
	\param dFER_Calculated = output, current FER, since the last time that statistics were cleared.
	\param iTimeOut_ms = input, number of milliseconds to wait for the number of symbols to exceed
	                     iMinimumNumSymbols.  This time-out applies only when iMinimumNumSymbols > 0.

	\return true if all operations succeeded

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_NS_Get_FCH_SER_FER(
							HANDLE hResourceContext,
							unsigned long iMinimumNumSymbols,
							unsigned long iMinimumNumFrames,
							unsigned long* piTotalSymbols,
							unsigned long* piTotalErrorSymbols,
							unsigned long* piTotalFrames,
							unsigned long* piTotalFrameErrors,
							double* pdSER_Calculated,
							double* pdFER_Calculated,
							unsigned long iTimeOut_ms
							);


		/******************************************************************************/
	/**
	CDMA2000
		Returns a subset of the cdma2000 status--the Paging Channel Symbol Error Rate with the
		option to set a minimum number.

		Will wait until a certain number of symbols have been counted or a time out expires.


	\param iMinimumNumSymbols = input, minimum number of symbols to capture.
	\param piTotalSymbols = output, total number of symbols that have been recorded for paging channel
	\param piTotalErrorSymbols = output, total symbol errors recorded for paging channel
	\param pdPaging_SER_Calculated = output, iTotalErrorSymbols / iTotalSymbols (note, there's no 100 multiplied)

	\param iTimeOut_ms = input, number of milliseconds to wait for the number of symbols to exceed
	                     iMinimumNumSymbols.  This time-out applies only when iMinimumNumSymbols > 0.

	\return true if all operations succeeded

	\warning this function calculates the paging channel symbol error rate instead of message error rate.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_CDMA2000_Get_Paging_SER(
								HANDLE hResourceContext,
								unsigned long iMinimumNumSymbols,
								unsigned long* piTotalSymbols,
								unsigned long* piTotalErrorSymbols,
								double* pdPaging_SER_Calculated,
								unsigned long iTimeOut_ms );

	/******************************************************************************/
	/**
	CDMA2000
		Call MUX1X_DIAG_PAGING_STAT_F with bit mask 0,
		to clear the 1x MUX paging channel buffer on AMSS(ICD 80-V1294-23);
		Call MC_DIAG_STATE_QUERY_CMD with bit mask 0,
		to clear the 1x Call processing paging channel buffer on AMSS(ICD 80-V1294-20).
		these two buffers are used to calculate the Paging Channel Message Error Rate.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if all operations succeeded

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_CDMA2000_Reset_Paging_MER_V2(
								HANDLE hResourceContext);

	/******************************************************************************/
	/**
	CDMA2000
		Call MUX1X_DIAG_PAGING_STAT_F with bit mask 7,
		to read the 1x MUX paging channel buffer on AMSS(ICD 80-V1294-23);
		Call MC_DIAG_STATE_QUERY_CMD with bit mask 7,
		to read the 1x Call processing paging channel buffer on AMSS(ICD 80-V1294-20).
		these two buffers are used to calculate the Paging Channel Message Error Rate.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piTotalNumPages = output, total number of pages that have been recorded for paging channel
	\param pdPaging_MER_Calculated = output, the error message / total * 100

	\return true if all operations succeeded

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_CDMA2000_Get_Paging_MER_V2(
								HANDLE hResourceContext,
								unsigned long* piTotalNumPages,
								double* pdPaging_MER_Calculated);

	/******************************************************************************
	/**
	CDMA2000

	Get the transceiver resource manager (TRM) logs (LOG_CODE 0x12E8, See 80-V1294-1)
	User specifies the number of logs to be collected and a time out value.

	This function resets the internal buffer counter, starts the TRM log and stores the logs to the internal buffer
	The internal buffer size, CDMA2000_TRM_LOG_PACKET_BUFFER_SIZE, is defined in QLIB_Defines.h

	This function will not collect packet with Sub Packet ID 10 (Exchange) from the logs

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pTRMLogBuffer = [in/out] a pointer to user buffer of type CDMA2000_TRM_Log_Header

	\param iSzOfTRMLogBuffer = [in] The size of user buffer
	                           [out]  The number of valid log packets returned to user

	\param iTimeOut_ms = [in]Timeout value in ms

	*******************************************************************************/
	QLIB_API unsigned char QLIB_CDMA2000_Get_TRM_Logs(
								HANDLE hResourceContext,
								void*   pTRMLogBuffer,
								int*    iSzOfTRMLogBuffer,
								unsigned long iTimeOut_ms);

	/******************************************************************************/
	/**
	CDMA2000 Non-signaling command 3.2.1 Acquire pilot

	This function acquires pilot

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iBand_Class = Indicates the band class. Possible values are in FTM_CDMA2000_BandClasstype

		\code
          FTM_CDMA2000_BAND_BC0	= 0,
          FTM_CDMA2000_BAND_BC1	= 1,
          FTM_CDMA2000_BAND_BC2	= 2,
          FTM_CDMA2000_BAND_BC3	= 3,
          FTM_CDMA2000_BAND_BC4	= 4,
          FTM_CDMA2000_BAND_BC5	= 5,
          FTM_CDMA2000_BAND_BC6	= 6,
          FTM_CDMA2000_BAND_BC7	= 7,
          FTM_CDMA2000_BAND_BC8	= 8,
          FTM_CDMA2000_BAND_BC9	= 9,
          FTM_CDMA2000_BAND_BC10	= 10,
          FTM_CDMA2000_BAND_BC11	= 11,
          FTM_CDMA2000_BAND_BC12	= 12,
          FTM_CDMA2000_BAND_BC13	= 13,
          FTM_CDMA2000_BAND_BC14	= 14,
          FTM_CDMA2000_BAND_BC15	= 15,
          FTM_CDMA2000_BAND_BC16	= 16,
          FTM_CDMA2000_BAND_BC17	= 17
		\endcode
	\param iCDMA_Freq  = Indicates the RF channel number.
	\param iACQ_MODE   = Indicates the acquisition mode. Possible values are
		\code
            FTM_CDMA2000_NS_FTM_ACQ_MODE_FULL(0),
            FTM_CDMA2000_NS_FTM_ACQ_MODE_MINI(1),
            FTM_CDMA2000_NS_FTM_ACQ_MODE_MICRO(2).
		 \endcode

	\return true if successful, false if fail.

	\warning If this call fails, then QLIB_FTM_CDMA2000_DEMOD_SYNC() should not be called.

	\note This function can be used in QMSL FTM Sequencer operation

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_PILOT_ACQ(
								HANDLE hResourceContext,
								unsigned long iBand_Class,
								unsigned short iCDMA_Freq,
								unsigned long iAcq_Mode);

	/******************************************************************************/
	/**
	CDMA2000 Non-signaling command 3.2.2 Acquire sync channel

			This function acquires sync channel

	\return true if successful, false if fail.

	\warning QLIB_FTM_CDMA2000_PILOT_ACQ() must be called first, with a passing result.

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_DEMOD_SYNC(HANDLE hResourceContext);

	/******************************************************************************/
	/**
	CDMA2000 Non-signaling command 3.2.3 Assign forward fundamental channel

	This function assigns forward fundamental channel

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRadio_cfg	= Indicates the Radio Configuration of the F-FCH.
						Possible values are:
		\code
          FTM_CDMA2000_NS_RC_1(1),
          FTM_CDMA2000_NS_RC_2(2),
          FTM_CDMA2000_NS_RC_3(3),
          FTM_CDMA2000_NS_RC_4(4),
          FTM_CDMA2000_NS_RC_5(5).
		\endcode
	\param iWalsh		= Indicates the Walsh code to be used for F-FCH.
	\param iQOF_Mask_id = Indicates the QOF index. Possible values are 0, 1, 2,and 3.
							For FTM_FWD_RC1 and FTM_FWD_RC2, this field should be set to 0.
	\param iBypass_LC	= If set to TRUE, the long code mask is set to 0.
	\param iFrame_Offset = Indicates the frame offset for F-FCH.
	\param iSubchan_Gain  = Indicates the Power Control Subchannel Gain.
	\param iFFPC_enable = If set to TRUE, Fast Forward Power Control is enabled.
	\param iFPC_Mode	= Indicates the Forward Power Control Mode.
						  FPC_MODE is not currently used at this time.
	\param iInit_Setpt  = Indicates the initial setpoint for F-FCH.
	\param iOLC_Params_Target_FER = Indicates the target frame error rate for F-FCH.
	\param iOLC_Params_Min_Setpt = Indicates the minimum setpoint for F-FCH.
	\param iOLC_Params_Max_Setpt = Indicates the maximum setpoint for F-FCH.

	\return true if successful, false if fail.

	\warning QLIB_FTM_CDMA2000_DEMOD_SYNC() must be called first, with a passing result.

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_DEMOD_FCH(
								HANDLE hResourceContext,
								unsigned long iRadio_Cfg,
								unsigned char iWalsh,
								unsigned char iQOF_Mask_ID,
								unsigned char iBypass_LC,
								unsigned char iFrame_Offset,
								unsigned char iSubChan_Gain,
								unsigned char iFFPC_Enable,
								unsigned long iFPC_Mode,
								unsigned char iInit_Setpt,
								unsigned char iOLC_Params_Target_FER,
								unsigned char iOLC_Params_Min_Setpt,
								unsigned char iOLC_Params_Max_Setpt);

	/******************************************************************************/
	/**
	CDMA2000 Non-signaling command 3.2.4 Assign forward supplemental channel

	This function assigns forward supplemental channel

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRadio_cfg	= Indicates the Radio Configuration of the F-SCH.
							Possible values are:
		\code
          FTM_CDMA2000_NS_RC_3(3),
          FTM_CDMA2000_NS_RC_4(4),
          FTM_CDMA2000_NS_RC_5(5).
		\endcode
	\param iWALSH		= Indicates the Walsh code to be used for F-SCH.
	\param iQOF_Mask_Id = Indicates the QOF index. Possible values are 0, 1, 2, and 3.
	\param iSch_Rate	= Indicates the data rate for F-SCH

	 Possible values for the rate are 0 to 4 which correspond to
	   \code
        FTM_RATE_1X (9.6 kbps)
        FTM_RATE_2X (19.2 kbps)
        FTM_RATE_4X (38.4 kbps)
        FTM_RATE_8X(76.8 kbps)
        FTM_RATE_16X (153.6 kbps)
	    \endcode


      For turbo-encoded SCH, the possible values are:
	    \code
        FTM_RATE_1X (9.6 kbps)
        FTM_RATE_2X (19.2 kbps)
        FTM_RATE_4X (38.4 kbps)
        FTM_RATE_8X(76.8 kbps)
        FTM_RATE_16X (153.6 kbps)
	    \endcode
	\param iCoding_type = Indicates the coding type for F-SCH. Possible values are
		\code
         0 - FTM_SCH_CODING_CONVOLUTIONAL
         1 - FTM_SCH_CODING_TURBO
		 \endcode
	\param iFFPC_Enable = Indicates whether Forward Power Control is to be enabled.
	\param iFPC_Mode	= Indicates the Forward Power Control Mode.
						  iFPC_MODE is not used at this time.
	\param iInit_Setpt	= Indicates the initial setpoint for F-SCH.
	\param iOLC_Params_Target_FER = Indicates the target frame-error rate for F-SCH.
	\param iOLC_Params_Min_Setpt = Indicates the minimum setpoint for F-SCH.
	\param iOLC_PARAMS_Max_Setpt = Indicates the maximum setpoint for F-SCH.

	\return true if successful, false if fail.

	\warning QLIB_FTM_CDMA2000_DEMOD_SYNC() must be called first, with a passing result.

	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_CDMA2000_DEMOD_FSCH(
								HANDLE hResourceContext,
								unsigned long iRadio_Cfg,
								unsigned char iWalsh,
								unsigned char iQPF_Mask_ID,
								unsigned long iSch_Rate,
								unsigned long iCoding_Type,
								unsigned char iFFPC_Enable,
								unsigned long iFPC_Mode,
								unsigned char iInit_Setpt,
								unsigned char iOLC_Params_Target_FER,
								unsigned char iOLC_Params_Min_Setpt,
								unsigned char iOLC_Params_Max_Setpt);


	/******************************************************************************/
	/**
	CDMA2000 Non-signaling command 3.2.5 Assign reverse fundamental channel

	This function assigns reverse fundamental channel

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRadio_cfg = Indicates the Radio Configuration for R-FCH.
						Possible values are:
		\code
         1 = FTM_REV_RC1
		 2 = FTM_REV_RC2
		 3 = FTM_REV_RC3
		 4 = FTM_REV_RC4
		\endcode
	\param iFrame_offset = Indicates the frame offset for R-FCH.
	\param iFCH_Rate	= Indicates the data rate for R-FCH. Possible values are
		\code
         0 = FTM_CDMA2000_NS_REV_FCH_FULL_RATE
         1 = FTM_CDMA2000_NS_REV_FCH_HALF_RATE
         2 = FTM_CDMA2000_NS_REV_FCH_QTR_RATE
         3 = FTM_CDMA2000_NS_REV_FCH_8TH_RATE
		\endcode
	\param iEnable_RPC	= If set to TRUE, Reverse Power Control is enabled.
	\param iNum_Preambles = Indicates the number of preambles that will be sent on R-FCH. One preamble = 20 ms.
	\param iTX_Pattern	=	Specifies the Tx pattern that is to be transmitted on R-FCH.
							This pattern will be repeated every 4 bytes.

	\return true if successful, false if fail.

	\warning QLIB_FTM_CDMA2000_DEMOD_SYNC() must be called first, with a passing result.

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/


	QLIB_API unsigned char QLIB_FTM_CDMA2000_MOD_FCH(
								HANDLE hResourceContext,
								unsigned long iRadio_Cfg,
								unsigned char iFrame_Offset,
								unsigned long iFCH_Rate,
								unsigned char iEnable_RPC,
								unsigned short iNum_Preambles,
								unsigned long iTX_Pattern);

	/******************************************************************************/
	/**
	CDMA2000 Non-signaling command 3.2.6 Assign reverse supplemental channel

	This function assigns reverse supplemental channel

	\param iRadio_cfg = Indicates the Radio Configuration for R-SCH.
						Possible value is FTM_REV_RC3(3).
	\param iSch_Rate  = Indicates the R-SCH data rate. Possible values are from 0 to 7 which correspond to
	                    The enumeration, FTM_SCH_DataRates_Enum
       \code
       FTM_REV_SCH_1_5_RATE (0 = 1.5 kbps),
       FTM_REV_SCH_2_7_RATE (1 = 2.7 kbps),
       FTM_REV_SCH_4_8_RATE (2 = 4.8 kbps),
       FTM_REV_SCH_9_6_RATE (3 = 9.6 kbps),
       FTM_REV_SCH_19_2_RATE(4 = 19.2 kbps),
       FTM_REV_SCH_38_4_RATE (5 = 38.4 kbps),
       FTM_REV_SCH_76_8_RATE (6 = 76.8kbps), and
       FTM_REV_SCH_153_6_RATE (7 = 153.6kbps) respectively.
	   \endcode

		Note that for turbo-encoded frames, the minimum supported rate is FTM_REV_SCH_19_2_RATE.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iCoding_type = Indicates the coding type for R-SCH. Possible values are:
		\code
         0 - FTM_SCH_CODING_CONVOLUTIONAL
         1 - FTM_SCH_CODING_TURBO
		 \endcode

	\param iTX_Pattern = Specifies the Tx pattern for R-SC

	\return true if successful, false if fail.

	\warning QLIB_FTM_CDMA2000_DEMOD_SYNC() must be called first, with a passing result.

	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_CDMA2000_MOD_SCH(
								HANDLE hResourceContext,
								unsigned long iRadio_Cfg,
								unsigned long iSCH_Rate,
								unsigned long iCoding_Type,
								unsigned long iTX_Pattern);

	/******************************************************************************/
	/**
	CDMA2000 Non-signaling command 3.2.7 Enable loopback on the fundamental channel

	This command enables the loopback mode where all data received on the forward link is copied
	to the reverse link. The forward and reverse fundamental channels must already be set up before
	loopback mode is requested. The rate of the reverse link matches the forward link. In the case
	where an erasure is received on the forward link, a full rate frame of all zeros is sent on the
	reverse link.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\return true if successful, false if fail.

	\warning FTM_CDMA2000_DEMOD_FCH and FTM_CDMA2000_MOD_FCH must be called first

	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_CDMA2000_FCH_LOOPBACK( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	CDMA2000 Non-signaling command 3.2.8 Enable loopback on the supplemental channel

	This command enables the SCH loopback mode. The forward and reverse supplemental channels
	should already be set up to the same rate.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\return true if successful, false if fail.

	\warning QLIB_FTM_CDMA2000_DEMOD_SYNC() and QLIB_FTM_CDMA2000_MOD_SCH must be
	         called first, with a passing result.


	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_SCH_LOOPBACK( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	CDMA2000 Non-signaling command 3.2.9 Deassign all traffic channels

	This command releases all traffic channels and leaves the phone ready to acquire a pilot.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_CMD_RELEASE( HANDLE hResourceContext );


	/******************************************************************************/
	/**
	CDMA2000 Non-signaling command

	This command calls pilot acquistion, synchronization and forward fundamental assignment in order.
	Specifically, these functions are called:
		QLIB_FTM_CDMA2000_PILOT_ACQ()
		QLIB_FTM_CDMA2000_DEMOD_SYNC()
		QLIB_FTM_CDMA2000_DEMOD_FCH()

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iBand_Class, Band Class number (1=BC1)
	\param iCDMA_Freq,  CDMA channel number
	\param iRadio_Cfg,  Indicates the Radio Configuration of the F-FCH.
						Possible values are:
		\code
         1 = FTM_FWD_RC_1
		 2 = FTM_FWD_RC_2
		 3 = FTM_FWD_RC_3
         4 = FTM_FWD_RC_4
		 5 = FTM_FWD_RC_5
		\endcode
	\param iWalsh		Wash code to be used for F-FCH
	\param iFFPC_Enable	If set to TRUE, Fast Forward Power Control is enabled.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_GOTO_FWD_TRAFFIC_STATE(
									HANDLE hResourceContext,
									unsigned long iBand_Class,
									unsigned short iCDMA_Freq,
									unsigned long iRadio_Cfg,
									unsigned char iWalsh,
									unsigned char iFFPC_Enable );

	/******************************************************************************/
	/**

	CDMA2000 Non-signaling command 3.2.10 Assign forward dedicated control channel

	This command assigns forward dedicated control channel

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRadio_Cfg = Indicates the Radio Configuration of the F-FCH.
											Possible values are FTM_FWD_RC_3(3), FTM_FWD_RC_4(4), and FTM_FWD_RC_5(5).
	\param iWalsh     = Indicates the Walsh code to be used for F-FCH.
	\param iQof_Mask_Id = Indicates the QOF index. Possible values are 0, 1, 2, and 3.
												For FTM_FWD_RC1 and FTM_FWD_RC2, this field should be set to 0.
	\param iBypass_Lc = If set to TRUE, the long code mask is set to 0.
	\param iSo_Pri = Indicates the primary service option.
	\param iSo_Sec = Indicates the secondary service option
	\param iFrame_Offset = Indicates the frame offset for F-DCCH.
	\param iIlpc_Enable = If set to TRUE, the inter loop power control is enable.
	\param iOlpc_Enable = If set to TRUE, the open loop power control is enable.
	\param iInit_Setpt = Indicates the Initial setpoint for F-DDCH.
	\param iFpc_Subchan_Gain = Forward Power control sub-chan gain
	\param iOlc_Params_Target_Fer = Indicates the target frame-error rate for F-DCCH.
	\param iOlc_Params_Min_Setpt = Indicates the minimum setpoint for F-DCCH.
	\param iOlc_Params_Max_Setpt = Indicates the maximum setpoint for F-DCCH.

	\return true if successful, false if fail.

	\warning QLIB_FTM_CDMA2000_DEMOD_SYNC() must be called first, with a passing result.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_DEMOD_DCCH	(	HANDLE hResourceContext,
	  unsigned long iRadio_Cfg,
	  unsigned char iWalsh,
	  unsigned char iQof_Mask_Id,
	  unsigned char iBypass_Lc,
	  unsigned short iSo_Pri,
	  unsigned short iSo_Sec,
	  unsigned char iIlpc_Enable,
	  unsigned char iOlpc_Enable,
	  unsigned char iFpc_Subchan_Gain,
	  unsigned char iOlc_Params_Target_Fer,
	  unsigned char iOlc_Params_Min_Setpt,
	  unsigned char iOlc_Params_Max_Setpt);

	/******************************************************************************/
	/**
	CDMA2000 Non-signaling command 3.2.11 Assign reverse dedicated control channel

	This command assigns reverse dedicated control channel

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRadio_Cfg = Indicates the Radio Configuration for R-DCCH.
											Possible values are FTM_REV_RC3(3) and FTM_REV_RC4(4).
	\param iFrame_Offset - Indicates the frame offset for R-DCCH.
	\param iSch_On = If set to TRUE, the SCH is enabled.
	\param iSch_Rc = Indicates the Radio Configuration of the F-SCH.
									Possible values are FTM_FWD_RC_3(3), FTM_FWD_RC_4(4).
	\param iSch_Turbo = Indicates the coding type for SCH. Possible values
										are FTM_CODING_CONVOLUTIONAL(0) and FTM_CODING_TURBO(1).
	\param iSch_Ltu_Size = Indicates the logical transition unit size
	\param iSch_Rate = Indicates the data rate for SCH.
	                    Possible values for
	   \code
        FTM_RATE_1X (9.6 kbps)
        FTM_RATE_2X (19.2 kbps)
        FTM_RATE_4X (38.4 kbps)
        FTM_RATE_8X(76.8 kbps)
        FTM_RATE_16X (153.6 kbps)
		FTM_RATE_32X (5 = 307.2 kbps)
	    \endcode

			For turbo-encoded SCH, the possible values are FTM_RATE_2X, FTM_RATE_4X, FTM_RATE_8X,
			FTM_RATE_16X and FTM_RATE_32X.
	\param iNum_Preambles = Indicates the number of preambles that will be sent on R-DCCH. One preamble = 20 ms.
	\param iTx_Pattern = Specifies the Tx pattern that is to be transmitted on R-DCCH. This pattern will be
											repeated every 4 bytes.

	\return true if successful, false if fail.

	\warning QLIB_FTM_CDMA2000_DEMOD_SYNC() must be called first, with a passing result.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_MOD_DCCH(	HANDLE hResourceContext,
														unsigned long iRadio_Cfg,
														unsigned char iFrame_Offset,
														unsigned char iSch_On,
														unsigned long iSch_Rc,
														unsigned char iSch_Turbo,
														unsigned short iSch_Ltu_Size,
														unsigned long iSch_Rate,
														unsigned short iNum_Preambles,
														unsigned long iTx_Pattern);
	/******************************************************************************/
	/**
	CDMA2000 Non-signaling command 3.2.12 Enable loopback on the dedicated control channel

	This command enables loopback on the dedicated control channel

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\return true if successful, false if fail.

	\warning QLIB_FTM_CDMA2000_DEMOD_SYNC(), QLIB_FTM_CDMA2000_MOD_DCCH(),  and
	         QLIB_FTM_CDMA2000_DEMOD_DCCH() must be called first, each with a passing result.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_DCCH_LOOPBACK(HANDLE hResourceContext);

	/******************************************************************************/
	/**
	CDMA2000 Non-signaling command 3.3.15 Handover

	This function will command the mobile to a new band class and channel number.

	The FTM code for this function was added in December 2006, long afer the
	original cdma2000 non-signaling commands were in FTM.  If the command fails,
	it is quite possible that embedded software does not support it.

	In order to verify the RF channel has been changed, this function uses
	QLIB_DIAG_IS2000_STATUS_F() to check the mobile status for the band class
	and channel number.  If the mobile does not report the new numbers, then a
	this function will also fail.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iBand_Class = Indicates the band class. Possible values are in FTM_CDMA2000_BandClasstype
						See QLIB_FTM_CDMA2000_PILOT_ACQ() for the full list.
	\param iCDMA_Freq  = Indicates the RF channel number.
	\param iEnable_RPC = 1 to enable reverse link power control (RPC), 0 to disable RPC

	\return true if successful, false if fail.

	\warning This must be called only after the QLIB_FTM_CDMA2000_DEMOD_FCH() is called successfully

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_FTM_FWD_HHO_SC(
								HANDLE hResourceContext,
								unsigned long iBand_Class,
								unsigned short iCDMA_Freq,
								unsigned char iEnable_RPC
								);

	/******************************************************************************/
	/**
	CDMA2000 Non-signaling command 3.3.16 Set reverse link power

	This function overrides the reverse link power control with CDMA2000 NS mode

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iPower_Type = Indicates the power control method.
						 Possible values are in FTM_CDMA2000_NS_Set_Rev_Power_Type_Enum listed in QLib_Defines.h

	\param iRev_Pwr_indBm10  = Indicates the power level in 10/dBm units as signed number.
						 This field is used only when iPower_Type is set to FTM_1X_TX_POWER_TYPE_AGC_SETPOINT

						 For example, to set 24dBm, 240 should be used

	\return true if successful, false if fail.

	\warning This function should be called only a NS call has been established successfully

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_SET_REV_PWR(
								HANDLE hResourceContext,
								unsigned char iPower_Type,
								long iRev_Pwr_indBm10
								);
	/******************************************************************************/
	/**
	cdma2000 Non-signaling command x.x.xx Reset fowrward link FER/SER statistics

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning This function should be called only a NS call has been established successfully

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_RESET_FCH_STAT(	HANDLE hResourceContext );
	/******************************************************************************/
	/**
	cdma2000 Non-signaling command x.x.xx Get fowrward link FER/SER statistics

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iNumFrame = Total packets since the counter set

	\param iFrameError = Total number of error packets since last counter reset

	\param dFER =	Frame error rate (iFrameError/iNumFrame * 100).
					999.0 is returned if the target does not support the command

	\param iNumSymboal = Total number of symbol in FCH channel

	\param iSymbolError = Total number of symbol error in FCH channel

	\param dSER = Symbol Error Rate (iSymbolError/iNumSymbol * 100)
				  999.0 is returned if the target does not support the command

	\return true if successful, false if fail.

	\warning This function should be called only a NS call has been established successfully

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_GET_FCH_STAT(	HANDLE hResourceContext,
															unsigned long* iNumFrame,
															unsigned long* iFrameError,
															double* dFER,
															unsigned long* iNumSymbol,
															unsigned long* iSymbolError,
															double* dSER);
	/******************************************************************************/
	/**
	cdma2000 Non-signaling command x.x.xx Get fowrward link FER/SER statistics

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iRxChain = 0 - Primary Rx
	                  1 - Secondary Rx

	\param iStatus = 0 - FTM_SUCCESS
	                 1 - FTM_INVALID_CMD
					 2 - FTM_INVALID_STATE
					 3 - FTM_NO_SUCCESS

    \param iRxAGC = Rx AGC value

	\param iRxPowerdBm = output value, Rx power in 1/10 dBm units
	                     this is a signed value

	\return true if successful, false if fail.

	\warning This function should be called only a NS call has been established successfully

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CDMA2000_RX_LEVEL_REQ(	HANDLE hResourceContext,
															unsigned char iRxChain,
															unsigned char* iStatus,
															short *iRxAGC,
															short *iRxPowerdBm);


/******************************************************************************
						EVDO Non-signaling FTM
*******************************************************************************/

	/******************************************************************************/
	/**
	Enables logging for the EVDO non-signaling commands.  If this is not done, then
	the EVDO NS commands will act only as simple request/response types.

	After this function is called, the commands will for assocated events
	to occur, before they returning to the library client.

	In addition, after this function is called, then the library will begin collecting C/I statistics

	The log used to determine searcher state is: 0x108A, FTM_EVDO_NS_LOG_CODE_FINGER_INFO

	The logs used for AGC are FTM logs:
	\code
		LOG_FTM2_LOG_HDR_AGC		= 0x5
		LOG_FTM2_LOG_HDR_AGC_C1 = 0x7
	\endcode

	When this function is called, only log 0x108A, FTM_EVDO_NS_LOG_CODE_FINGER_INFO will
	be enabled.  At the same time, the FTM AGC logs will be >>DISABLED<<

	The user must call QLIB_FTM_EVDO_NS_EnableMeasurementLogs() in order to activate
	0x1068, FTM_EVDO_NS_LOG_CODE_AIR_LINK_SUMMARY and the FTM AGC logs and measure
	AGC and PER.  This is because the MSM6800 design is such that there will be
	problems if the FTM AGC log is enabled when the pilot acquisition is perfomed. This
	is by-design, so the PC side must be managed around this.

	The function FTM_EVDO_NS_Stop should be called when the the EVDO NS testing
	is completed.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iDR_Type = Dymamic range type, defined by FTM_EVDO_NS_DR_Types_Enum in QLib_Defines.h
		\code
          0 = FTM_EVDO_NS_DR_85_3  = 85.3dB  dynamic range, min_rssi = -106.0dBm
          1 = FTM_EVDO_NS_DR_102_4 = 102.4dB dynamic range, min_rssi = -115.0dBm
		\endcode
	\param dTurnAroundConstant = cdma turn around constant, -73dBm for BC0, -76 for BC1.
	\return true if successful, false if fail.

	\warning Will clear status and enable EVDO NS statistics for FTM_EVDO_NS_Log_FingerInfo, via
	         FTM_EVDO_NS_SetStatisticsState().  Will also clear the EVDO NS status
			 using QLIB_FTM_EVDO_NS_ClearStatus()

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_NS_Start( HANDLE hResourceContext,  unsigned char iDR_Type, double dTurnAroundConstant  );


	/******************************************************************************/
	/**
	Enables logging for the EVDO non-signaling commands.  If this is not done, then
	the EVDO NS commands will act only as simple request/response types.

	After this function is called, the commands will for assocated events
	to occur, before they returning to the library client.

	In addition, after this function is called, then the library will begin collecting C/I statistics

	This function is a variant from QLIB_FTM_EVDO_NS_Start() -- the difference is that this function
	does not clear the EVDO NS status and it does not stop the FTM AGC logs.

	The log used to determine searcher state is: 0x108A, FTM_EVDO_NS_LOG_CODE_FINGER_INFO

	The logs used for AGC are FTM logs:
	\code
		LOG_FTM2_LOG_HDR_AGC		= 0x5
		LOG_FTM2_LOG_HDR_AGC_C1 = 0x7
	\endcode

	When this function is called, only log 0x108A, FTM_EVDO_NS_LOG_CODE_FINGER_INFO will
	be enabled.

	The user must call QLIB_FTM_EVDO_NS_EnableMeasurementLogs() in order to activate
	0x1068, FTM_EVDO_NS_LOG_CODE_AIR_LINK_SUMMARY and the FTM AGC logs and measure
	AGC and PER.  This is because the MSM6800 design is such that there will be
	problems if the FTM AGC log is enabled when the pilot acquisition is perfomed. This
	is by-design, so the PC side must be managed around this.

	The function FTM_EVDO_NS_Stop should be called when the the EVDO NS testing
	is completed.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iDR_Type = Dymamic range type, defined by FTM_EVDO_NS_DR_Types_Enum in QLib_Defines.h
		\code
          0 = FTM_EVDO_NS_DR_85_3  = 85.3dB  dynamic range, min_rssi = -106.0dBm
          1 = FTM_EVDO_NS_DR_102_4 = 102.4dB dynamic range, min_rssi = -115.0dBm
		\endcode
	\param dTurnAroundConstant = cdma turn around constant, -73dBm for BC0, -76 for BC1.
	\return true if successful, false if fail.

	\warning Will enable EVDO NS statistics for FTM_EVDO_NS_Log_FingerInfo, via
	         FTM_EVDO_NS_SetStatisticsState().  Will NOT clear the EVDO NS status
			 using QLIB_FTM_EVDO_NS_ClearStatus()

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_NS_Start_NO_CLEAR( HANDLE hResourceContext,  unsigned char iDR_Type, double dTurnAroundConstant  );


	/******************************************************************************/
	/**
	Enables measurement logs for the EVDO non-signaling commands.  If this is not done,
	then it will not be possible to report PER and AGC from the QMSL functions.

 	This function should be called after a successful transfer to traffic state when
	QLIB_FTM_EVDO_DEMOD_CC_MAC_FTC(), or
	QLIB_FTM_EVDO_MOD_REVERSE_TRA for Release 0, or
	QLIB_FTM_EVDO_REV_A_MOD_TRA for Revision A, or
	QLIB_FTM_EVDO_REV_B_MOD_RTC for Revision B is called.

	After this function is called, then the library will begin collecting
	statistics (PER, C/I, AGC, Rev.0/A Forward Statistics, Power, etc, depending on the mask)

	The logs used to determine PER is: 0x1068, FTM_EVDO_NS_LOG_CODE_AIR_LINK_SUMMARY

	The logs used for AGC are FTM logs:
	\code
	       LOG_FTM2_LOG_HDR_AGC    = 0x5
       	LOG_FTM2_LOG_HDR_AGC_C1 = 0x7
	\endcode
	\note Only 1 chain of AGC log should be enabled at a time.

	The logs used for forward and reverse links Power:  EVDO_POWER	0x1069

	The logs used for HDR release 0 throughput: EVDO_FORWARD_LINK_STATISTICS_SUMMARY 0x1084

	The logs used for HDR revision A throughput: EVDO_REVA_SU_FWDSTATS 0x1192

	The function QLIB_FTM_EVDO_NS_Stop should be called when the the EVDO NS testing is completed.

	The function QLIB_FTM_EVDO_NS_DisableMeasurementLogs can be used to disable
		any logs that were enabled by this function during testing.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iLogMask = Log mask, defined by FTM_EVDO_NS_MeasurementLogs_Enum.

		The mask values are as follows:
		\code
		FTM_EVDO_NS_LOG_AIR_LINK_SUMMARY = 0x0001,	//!<'  Air link summary 0x1068
		FTM_EVDO_NS_LOG_AGC_C0			 = 0x0002,	//!<'  FTM AGC Log for primary Rx (C0)
		FTM_EVDO_NS_LOG_AGC_C1			 = 0x0004,	//!<'  FTM AGC Log for secondary Rx (C1)
		FTM_EVDO_NS_LOG_Default 		 = 0x0003,	//!<'  Default is to include logs air link summary and AGC Primary Chain FTM logs.
		FTM_EVDO_NS_LOG_POWER			 = 0x0008,	//!<'  Power Logs 0x1069
		FTM_EVDO_NS_LOG_FWD_STAT		 = 0x0010,	//!<'  Forward statistics summary 0x1084
		FTM_EVDO_NS_LOG_REVA_SU_FWD_STAT = 0x0020,	//!<'  Rev. A Single User forward statistics summary 0x1192
		FTM_EVDO_NS_LOG_MC_AIR_LINK 	 = 0x0040,	//!<'  Rel. B Multi-carrier airlink summary 0x1296
		FTM_EVDO_NS_LOG_MC_SU_FWD_STAT	 = 0x0080,	//!<'  Rev. B Multi-carrier Single User forward statistics summary 0x12A2
		FTM_EVDO_NS_LOG_MC_POWER		 = 0x0100,	//!<'  Rev. B Multi-carrier Power 0x129C
		FTM_EVDO_NS_LOG_ALL 			 = 0xFFFB	//!<'  All log codes available for EVDO(excluding Secondary chain FTM AGC log)
		\endcode

		The default mask is FTM_EVDO_NS_LOG_Default, which includes logs for Airlink summary and AGC primary chain FTM logs.

	\return true if successful, false if fail.

	\warning 	Only 1 chain of AGC log should be enabled at a time.
			This function will enable EVDO NS statistics based on the mask, via FTM_EVDO_NS_SetStatisticsState().

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_NS_EnableMeasurementLogs( HANDLE hResourceContext,  unsigned short iLogMask );

	/******************************************************************************/
	/**
	Disables measurement logs for the EVDO non-signaling commands.

	After this function is called, then the library will stop collecting
	statistics (PER, C/I, AGC, Rev.0/A Forward Statistics, Power, etc, depending on the mask)

	The logs used to determine PER is: 0x1068, FTM_EVDO_NS_LOG_CODE_AIR_LINK_SUMMARY

	The logs used for AGC are FTM logs:
	\code
	       LOG_FTM2_LOG_HDR_AGC    = 0x5
       	LOG_FTM2_LOG_HDR_AGC_C1 = 0x7
	\endcode

	The logs used for forward and reverse links Power:  EVDO_POWER	0x1069

	The logs used for HDR release 0 throughput: EVDO_FORWARD_LINK_STATISTICS_SUMMARY 0x1084

	The logs used for HDR revision A throughput: EVDO_REVA_SU_FWDSTATS 0x1192

	The function QLIB_FTM_EVDO_NS_Stop should be called when the the EVDO NS testing is completed.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iLogMask = Log mask, defined by FTM_EVDO_NS_MeasurementLogs_Enum.

		The mask values are as follows:
		\code
		FTM_EVDO_NS_LOG_AIR_LINK_SUMMARY = 0x0001,	//!<'  Air link summary 0x1068
		FTM_EVDO_NS_LOG_AGC_C0			 = 0x0002,	//!<'  FTM AGC Log for primary Rx (C0)
		FTM_EVDO_NS_LOG_AGC_C1			 = 0x0004,	//!<'  FTM AGC Log for secondary Rx (C1)
		FTM_EVDO_NS_LOG_Default 		 = 0x0003,	//!<'  Default is to include logs air link summary and AGC Primary Chain FTM logs.
		FTM_EVDO_NS_LOG_POWER			 = 0x0008,	//!<'  Power Logs 0x1069
		FTM_EVDO_NS_LOG_FWD_STAT		 = 0x0010,	//!<'  Forward statistics summary 0x1084
		FTM_EVDO_NS_LOG_REVA_SU_FWD_STAT = 0x0020,	//!<'  Rev. A Single User forward statistics summary 0x1192
		FTM_EVDO_NS_LOG_MC_AIR_LINK 	 = 0x0040,	//!<'  Rel. B Multi-carrier airlink summary 0x1296
		FTM_EVDO_NS_LOG_MC_SU_FWD_STAT	 = 0x0080,	//!<'  Rev. B Multi-carrier Single User forward statistics summary 0x12A2
		FTM_EVDO_NS_LOG_MC_POWER		 = 0x0100,	//!<'  Rev. B Multi-carrier Power 0x129C
		FTM_EVDO_NS_LOG_ALL 			 = 0xFFFB	//!<'  All log codes available for EVDO(excluding Secondary chain FTM AGC log)
		\endcode

		The default mask is FTM_EVDO_NS_LOG_Default, which includes logs for airlink summary and AGC primary chain FTM logs.

	\return true if successful, false if fail.

	\warning This function will disable EVDO NS statistics based on the mask, via FTM_EVDO_NS_SetStatisticsState().
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_NS_DisableMeasurementLogs( HANDLE hResourceContext,  unsigned short iLogMask );


	/******************************************************************************/
	/**
	Disables logging for the EVDO non-signaling commands.  This should be done
	after FTM_EVDO_NS_StartLogging() is called, and after all EVDO NS testing is
	completed.

	This functin calls
		QLIB_FTM_LOG_StopFTM_Log( HANDLE, LOG_FTM2_LOG_HDR_AGC ) to stop primary AGC logs
		QLIB_FTM_LOG_StopFTM_Log( HANDLE, LOG_FTM2_LOG_HDR_AGC_C1 ) to stop diveristy AGC logs
		QLIB_DIAG_ClearExtendedLogCode( HANDLE, LOG_EQUIP_ID_1X, FTM_EVDO_NS_LOG_CODE_FINGER_INFO) to stop FINGER_INFO logs

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning The FTM AGC logs will be disabled.
		The log code enabled by QLIB_EVDO_NS_Start will also be disabled (FTM_EVDO_NS_LOG_CODE_FINGER_INFO 0x108A).
		The log codes enabled by QLIB_FTM_EVDO_NS_EnableMeasurementLogs will NOT be disabled.
		Use QLIB_FTM_EVDO_NS_DisableMeasurementLogs to clear any other log used during EVDO NS testing.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_NS_Stop( HANDLE hResourceContext );


	/******************************************************************************/
	/**
	Turn on or off logging for a certain type of 1xEV-DO non-signaling log

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param eLogType = log type to control
		\code
			FTM_EVDO_NS_Log_FingerInfo,				//!<' 1xEV-DO Finger, Ver 2 (LOG_CODE 0x108A), C/I for both C0 and C1
			FTM_EVDO_NS_Log_AGC_C0, 				//!<' FTM2 log, sub log 5, for Primary AGC
			FTM_EVDO_NS_Log_AGC_C1, 				//!<' FTM2 log, sub log 7, for Diversity AGC
			FTM_EVDO_NS_Log_PER,					//!<' 1xEV-DO Air Link Summary (LOG_CODE 0x1068), used for PER
			FTM_EVDO_NS_Log_FWD_Stat_Summary,		//!<' 1xEV-DO Forward Statistis Summary (LOG_CODE 0x1084), used for Release 0 Throughput
			FTM_EVDO_NS_Log_Power_Summary,			//!<' 1xEV-DO Power logs (LOG_CODE 0x1069), used for EVDO Power.
			FTM_EVDO_NS_Log_RevA_SU_FWD_Stat_Summary,	//!<' 1xEV-DO Rev. A Single User Forward Statistis Summary (LOG_CODE 0x1192), used for Revision A Throughput
			FTM_EVDO_NS_Log_MC_Airlink_Summary, 	//!<' 1xEV-DO Multi-carrier Airlink Summary (LOG_CODE 0x1296)
			FTM_EVDO_NS_Log_MC_SU_FWD_Stat_Summary, 	//!<' 1xEV-DO Multi-carrier single user Forward Statistis Summary (LOG_CODE 0x12A2)
			FTM_EVDO_NS_Log_MC_Power_Summary,		//!<' 1xEV-DO Multi-carrier Power (LOG_CODE 0x129C)
		\endcode
	\param bEnableStatistics = true to enable statistics of the specified log type

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_NS_SetStatisticsState( HANDLE hResourceContext, unsigned char eLogType, unsigned char bEnableStatistics);


	/******************************************************************************/
	/**
	1XEV-DO Non-signaling,

		Reset the internal status structure, including all averages

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if failure

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_NS_ClearStatus( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	1XEV-DO Non-signaling,

		Reset the internal PER status structure, will not affect other statistics,
		such as AGC averages

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if failure

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_NS_ClearPER_Status( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	1XEV-DO Non-signaling,
			Returns a copy of the internal state.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pEVDO_NS_State = reference to a FTM_EVDO_NS_Status_Struct structure that will be
	                        filled in with the state information.
							Structure type is FTM_EVDO_NS_Status_Struct, defined in QLib_Defines.h



	\return true if all operations succeeded and the correct event messages were received

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_NS_GetStatus( HANDLE hResourceContext, void* pEVDO_NS_State );

	/******************************************************************************/
	/**
	1XEV-DO Non-signaling,
			Returns a subset of the EVDO NS status--the current average PER and
			the number of 16-

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iMinimumNumPackets = input, minimum number of packets to capture.  Set to 0 to return
	                            the current statistics
	\param piTotalPackets = output, total number of packets that have been recorded
	\param pdPER_Calculated = output, current PER, since the last time that statistics were cleared.
	\param iTimeOut_ms = input, number of milliseconds to wait for the number of packets to exceed
	                     iMinimumNumPackets.  This time-out applies only when iMinimumNumPackets > 0.

	\return true if all operations succeeded

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_NS_GetPER(
							HANDLE hResourceContext,
							unsigned long iMinimumNumPackets,
							unsigned long* piTotalReceivedPackets,
							double* pdPER_Calculated,
							unsigned long iTimeOut_ms
							);

	/******************************************************************************/
	/**
	1XEV-DO Non-signaling, command 3.2.1 Acquire 1xEV-DO forward pilot channel

	This command acquires 1xEV-DO forward pilot channel

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iBand_Class = Indicates the band class. Possible values are:
		\code
          FTM_EVDO_BAND_CLASS_CELLULAR	= 0,
          FTM_EVDO_BAND_CLASS_PCS			= 1,
          FTM_EVDO_BAND_BC0	= 0,
          FTM_EVDO_BAND_BC1	= 1,
          FTM_EVDO_BAND_BC2	= 2,
          FTM_EVDO_BAND_BC3	= 3,
          FTM_EVDO_BAND_BC4	= 4,
          FTM_EVDO_BAND_BC5	= 5,
          FTM_EVDO_BAND_BC6	= 6,
          FTM_EVDO_BAND_BC7	= 7,
          FTM_EVDO_BAND_BC8	= 8,
          FTM_EVDO_BAND_BC9	= 9,
          FTM_EVDO_BAND_BC10	= 10,
          FTM_EVDO_BAND_BC11	= 11,
          FTM_EVDO_BAND_BC12	= 12,
          FTM_EVDO_BAND_BC13	= 13,
          FTM_EVDO_BAND_BC14	= 14,
          FTM_EVDO_BAND_BC15	= 15,
          FTM_EVDO_BAND_BC16	= 16,
          FTM_EVDO_BAND_BC17	= 17
		\endcode

	\param iCdma_Freq = Indicates the RF channel number.
	\param iAcq_Mode = Indicates the acquisition mode; possible value is FTM_ACQ_MODE_FULL(0)
	\param iDiversity_Mode = Indicates whether diversity is enabled (1) or	disabled (0).

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_PILOT_ACQ(
								HANDLE hResourceContext,
								unsigned long iBand_Class,
								unsigned short iCDMA_Freq,
								unsigned long iACQ_Mode,
								unsigned long iDiversity_Mode);

	/******************************************************************************/
	/**
	1XEV-DO Non-signaling, command 3.2.2 Acquire 1xEV-DO system time

	This command acquires 1xEV-DO system time

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\warning

	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_EVDO_SYS_TIME_ACQ(
								HANDLE hResourceContext);

	/******************************************************************************/
	/**
	1XEV-DO Non-signaling, command 3.2.3 Demodulate 1xEV-DO forward CC/MAC/FTC

	This command demodulates 1xEV-DO forward CC/MAC/FTC

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iArq_Enable = Enables/disables the early termination feature when decoding the forward channel.
	\param iDrc_Lockperiod = Time interval in slots between transmission of two consecutive DRCLock bit
													transmissions on the Forward MAC Channel.
	\param iDrc_Locklength = Number of times a DRCLock bit is repeated.
	\param iMac_Index	 = Medium access control index assigned to the AT: 5 to 63.
	\param iRab_Length = Number of slots over which reverse activity bit is transmitted.
	\param iRab_Offset = Slots in which a new reverse activity bit can be transmitted.

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_EVDO_DEMOD_CC_MAC_FTC(
								HANDLE hResourceContext,
								unsigned char* iARQ_Enable,
								unsigned char* iDRC_Lockperiod,
								unsigned char* iDRC_Locklength,
								unsigned char* iMAC_Index,
								unsigned char* iRAB_Index,
								unsigned char* iRAB_Offset);

	/******************************************************************************/
	/**
	1XEV-DO Non-signaling, command 3.2.4 Modulate reverse access channel

	This subcommand modulates the reverse access channel.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iACLC_Mask_I_Hi = Upper 32 bits of access channel long code mask for I quadrature, default value is 0x3FF
	\param iACLC_Mask_I_Lo = Lower 32 bits of access channel long code mask for I quadrature,default value is 0x0
	\param iACLC_Mask_Q_Hi = Upper 32 bits of access channel long code mask for Q quadrature,default value is 0x3FE
	\param iACLC_Mask_Q_Lo = Lower 32 bits of access channel long code mask for Q quadrature,default value is 0x1
	\param iAC_Txpattern = Data pattern to transmit, recommended value is 0x84B3E374 (a 32-bit Pseudo-Random Bit Sequence)
	\param iAccess_Cycle_Duration = Duration of an access channel cycle, default value is 64
	\param iOpen_Loop_Adjust = Nominal power used in open-loop power estimate.
							default value is 81 for low bands, 84 for high bands.
	\param iProbe_Initial_Adjust = Correction power factor used in open-loop power estimate.
							default value is 15
	\param iProbe_Num_Step = Maximum number of access probes in single-access sequence.
							default value is 15
	\param iPower_Step = Probe power increase step in unit of 0.5dB
					default value is 15 (7.5dB)
	\param iPreamble_Length = Length of access probe preamble portion.
					default value is 2.
	\warning

	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_EVDO_MOD_ACC(
								HANDLE hResourceContext,
								unsigned long iACLC_Mask_I_Hi,
								unsigned long iACLC_Mask_I_Lo,
								unsigned long iACLC_Mask_Q_Hi,
								unsigned long iACLC_Mask_Q_Lo,
								unsigned long iAC_Txpattern,
								unsigned char iAccess_Cycle_Duration,
								unsigned char iOpen_Loop_Adjust,
								unsigned char iProbe_Initial_Adjust,
								unsigned char iProbe_Num_Step,
								unsigned char iPower_Step,
								unsigned char iPreamble_Length);

	/******************************************************************************/
	/**
	1XEV-DO Non-signaling, command 3.2.5 Modulate reverse traffic channel

	This subcommand modulates the reverse traffic  channel.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iACK_Gain	= Ratio of the power level of the ACK channel (when transmitted) to the power level
						of the reverse pilot channel, in unit of 0.5dB.
						default value is 6 (3dB)
	\param iDataoffset_Nom = Nominal offset of reverse data channel power to the reverse pilot channel power.
						default value is 0
	\param iDataoffset_9K6 = Ratio of reverse data channel power at 9.6 kbps to
						 the nominal reverse data channel power at 9.6 kbps.
						 default value is 0
	\param iDataoffset_19K2 = Ratio of reverse data channel power at 19.2 kbps to
						the nominal reverse data channel power at 19.2 kbps.
						default value is 0
	\param iDataoffset_38K4 = Ratio of reverse data channel power at 38.4 kbps to
						the nominal reverse data channel power at 38.4 kbps.
						default value is 0
	\param iDataoffset_76K8 = Ratio of reverse data channel power at 76.8 kbps to
						the nominal reverse data channel power at 76.8 kbps.
						default value is 0
	\param iDataoffset_153K6 = Ratio of reverse data channel power at 153.6 kbps to
						 the nominal reverse data channel power at 153.6 kbps.
						 default value is 0
	\param iDRC_Value = DRC value, forward traffic channel data rate, valid values are from 1 to 12.
	\param iDRC_Cover = DRC cover, default value is 1.
	\param iDRC_Gain = Ratio of the power level of the DRC channel (when	transmitted) to the power level of the reverse traffic pilot channel, in unit of 0.5dB.
					default value is 6 (3dB)
	\param iDRC_Length = DRC length
						0 = DRC length is 1 slot
						1 = DRC length is 2 slots
						2 = DRC length is 4 slots
						3 = DRC length is 8 slots
						default value is 0.
	\param iDRC_Gating = DRC gating enable/disable, default value is 0.
	\param iFrame_Offset = Frame offset, default value is 0
	\param iPRC_Enable = RPC enable/disable, default value is true
	\param iRPC_Step = Reverse power control step
						0 = Corresponds to 0.5 dB step
						1 = Corresponds to 1 dB step
						default value is 1 dB
	\param iRRI = Reverse rate indicator, reverse traffic channel data rate, valid values are from 1 to 5.
	\param iRTCLC_Mask_I_Hi = Upper 32 bits of reverse traffic channel long code mask for I quadrature, default value is 0x3FF
	\param iRTCLC_Mask_I_Lo = Lower 32 bits of reverse traffic channel long code mask for I quadrature, default value is 0x0
	\param iRTCLC_Mask_Q_Hi = Upper 32 bits of reverse traffic channel long code mask for Q quadrature, default value is 0x3FE
	\param iRTCLC_Mask_Q_Lo = Lower 32 bits of reverse traffic channel long code mask for Q quadrature, default value is 0x1
	\param iRTC_Txpattern = Data pattern to transmit, recommended value is 0x84B3E374 (a 32-bit Pseudo-Random Bit Sequence)
	\param iRTC_Txduty_Cycle = Frame duty cycle of RTCTxPattern. 8 bits. Duty cycle starts at MSB and wraps around after LSB. 1 bit
							default value is 0xFF
	\param iHDR_ACK_Mode = ack, nak, or do not ack every slot in the non-signaling
			Mode:
		\code
           0 = FTM_EVDO_IS856_COMPLIANT: Normal IS-856 operation. Early decode enabled; do not ack.
           1 = FTM_EVDO_IS856_NO_ACK: IS856 but with no early termination. Early decode disabled; do not ack.
           2 = FTM_EVDO_IS890_MODE_0: First slot decode mode. Ack each slot (test app mode).
           3 = FTM_EVDO_IS890_MODE_1: Full packet decode mode; Nak each slot (test app mode).
           4 = FTM_EVDO_IS890A_MODE_ACK_BPSK: Always ack with bipolar keying (BPSK) modulation.
           5 = FTM_EVDO_IS890A_MODE_NAK_BPSK: Always nak with bipolar keying (BPSK) modulation.
           6 = FTM_EVDO_IS890A_MODE_ACK_OOK: Always ack with on-off keying (OOK) modulation.
           7 = FTM_EVDO_IS890A_MODE_NAK_OOK: Always nak with on-off keying (OOK) modulation.
		\endcode
		Default value is 3, FTM_EVDO_IS890_MODE_1.(Must be FTM_EVDO_IS890_MODE_1 to comply with 3GPP2 Spec IS-866-A)
	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_MOD_REVERSE_TRA(
								HANDLE hResourceContext,
								unsigned char iACK_Gain,
								unsigned char iDataoffset_Nom,
								unsigned char iDataoffset_9K6,
								unsigned char iDataoffset_19K2,
								unsigned char iDataoffset_38K4,
								unsigned char iDataoffset_76K8,
								unsigned char iDataoffset_153K6,
								unsigned char iDRC_Value,
								unsigned char iDRC_Cover,
								unsigned char iDRC_Gain,
								unsigned char iDRC_Length,
								unsigned char iDRC_Gating,
								unsigned char iFrame_Offset,
								unsigned char iPRC_Enable,
								unsigned char iRPC_Step,
								unsigned char iRRI,
								unsigned long iRTCLC_Mask_I_Hi,
								unsigned long iRTCLC_Mask_I_Lo,
								unsigned long iRTCLC_Mask_Q_Hi,
								unsigned long iRTCLC_Mask_Q_Lo,
								unsigned long iRTC_Txpattern,
								unsigned char iRTC_Txduty_Cycle,
								unsigned char iHDR_ACK_Mode);

	/******************************************************************************/
	/**
	1XEV-DO Non-signaling, This command causes mobile to demodulate a different foward data rate without releaseing a non-signaling call.
	It calls QLIB_FTM_EVDO_MOD_REVERSE_TRA twice to change to a different rate

	The following procedure can be used to change the data rate:

	1. Set up a non-signaling call
	2. Change the forward data rate on test equipment
	3. Call this function with the new data rate (new DRC value)

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iACK_Gain	=	Ratio of the power level of the ACK channel (when transmitted) to the power level
											of the reverse pilot channel.
	\param iDataoffset_Nom = Nominal offset of reverse data channel power to the reverse pilot channel power.
	\param iDataoffset_9K6 = Ratio of reverse data channel power at 9.6 kbps to
													 the nominal reverse data channel power at 9.6 kbps.
	\param iDataoffset_19K2 = Ratio of reverse data channel power at 19.2 kbps to
														the nominal reverse data channel power at 19.2 kbps.
	\param iDataoffset_38K4 = Ratio of reverse data channel power at 38.4 kbps to
														the nominal reverse data channel power at 38.4 kbps.
	\param iDataoffset_76K8 = Ratio of reverse data channel power at 76.8 kbps to
														the nominal reverse data channel power at 76.8 kbps.
	\param iDataoffset_153K6 = Ratio of reverse data channel power at 153.6 kbps to
														 the nominal reverse data channel power at 153.6 kbps.
	\param iDRC_Value = DRC value. (the new data rate)
	\param iDRC_Cover = DRC cover.
	\param iDRC_Gain = Ratio of the power level of the DRC channel (when
											transmitted) to the power level of the reverse traffic pilot channel.
	\param iDRC_Length = DRC length.
	\param iDRC_Gating = DRC gating enable/disable.
	\param iFrame_Offset = Frame offset.
	\param iPRC_Enable = RPC enable/disable.
	\param iRPC_Step = Reverse power control step.
	\param iRRI = Reverse rate indicator.
	\param iRTCLC_Mask_I_Hi = Upper 32 bits of reverse traffic channel long code mask for I quadrature.
	\param iRTCLC_Mask_I_Lo = Lower 32 bits of reverse traffic channel long code mask for I quadrature.
	\param iRTCLC_Mask_Q_Hi = Upper 32 bits of reverse traffic channel long code mask for Q quadrature.
	\param iRTCLC_Mask_Q_Lo = Lower 32 bits of reverse traffic channel long code mask for Q quadrature.
	\param iRTC_Txpattern = Data pattern to transmit.
	\param iRTC_Txduty_Cycle = Frame duty cycle of RTCTxPattern. 8 bits. Duty cycle starts at MSB
															and wraps around after LSB. 1 bit
	\param iHDR_ACK_Mode = ack, nak, or do not ack every slot in the non-signaling
			Mode:
		\code
           0 = FTM_EVDO_IS856_COMPLIANT: Normal IS-856 operation. Early decode enabled; do not ack.
           1 = FTM_EVDO_IS856_NO_ACK: IS856 but with no early termination. Early decode disabled; do not ack.
           2 = FTM_EVDO_IS890_MODE_0: First slot decode mode. Ack each slot (test app mode).
           3 = FTM_EVDO_IS890_MODE_1: Full packet decode mode; Nak each slot (test app mode).
           4 = FTM_EVDO_IS890A_MODE_ACK_BPSK: Always ack with bipolar keying (BPSK) modulation.
           5 = FTM_EVDO_IS890A_MODE_NAK_BPSK: Always nak with bipolar keying (BPSK) modulation.
           6 = FTM_EVDO_IS890A_MODE_ACK_OOK: Always ack with on-off keying (OOK) modulation.
           7 = FTM_EVDO_IS890A_MODE_NAK_OOK: Always nak with on-off keying (OOK) modulation.
		\endcode
		Default value is 3, FTM_EVDO_IS890_MODE_1.(Must be FTM_EVDO_IS890_MODE_1 to comply with 3GPP2 Spec IS-866-A)
	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_EVDO_CHANGE_DRC(
								HANDLE hResourceContext,
								unsigned char iACK_Gain,
								unsigned char iDataoffset_Nom,
								unsigned char iDataoffset_9K6,
								unsigned char iDataoffset_19K2,
								unsigned char iDataoffset_38K4,
								unsigned char iDataoffset_76K8,
								unsigned char iDataoffset_153K6,
								unsigned char iDRC_Value,
								unsigned char iDRC_Cover,
								unsigned char iDRC_Gain,
								unsigned char iDRC_Length,
								unsigned char iDRC_Gating,
								unsigned char iFrame_Offset,
								unsigned char iPRC_Enable,
								unsigned char iRPC_Step,
								unsigned char iRRI,
								unsigned long iRTCLC_Mask_I_Hi,
								unsigned long iRTCLC_Mask_I_Lo,
								unsigned long iRTCLC_Mask_Q_Hi,
								unsigned long iRTCLC_Mask_Q_Lo,
								unsigned long iRTC_Txpattern,
								unsigned char iRTC_Txduty_Cycle,
								unsigned char iHDR_ACK_Mode);


	/******************************************************************************/
	/**
	1XEV-DO Non-signaling, command 3.2.6 This subcommand deassigns all 1xEV-DO channels

	This subcommand deassigns all 1xEV-DO channels

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_CMD_RELEASE(
								HANDLE hResourceContext);


	/******************************************************************************/
	/**
	1XEV-DO Non-signaling, command 3.2.6 This subcommand deassigns all 1xEV-DO channels

	This subcommand deassigns all 1xEV-DO channels

	This function send the same command as in QLIB_FTM_EVDO_CMD_RELEASE except that it waits for searcher to go to IDLE state.
	QLIB_FTM_EVDO_NS_Start() must be called first to determine searcher state

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_CMD_RELEASE_V2(
								HANDLE hResourceContext);


	/******************************************************************************/
	/**
	EVDO Non-signaling command 3.2.7 Demodulate Forward Link with No Reverse Link Rev 0.


	This single replaces the this sequence of commands:
		QLIB_FTM_EVDO_DEMOD_CC_MAC_FTC()
		QLIB_FTM_EVDO_MOD_ACC()
		QLIB_FTM_EVDO_MOD_REVERSE_TRA()

	However, versions of AMSS created before 2006 may not have this command available in the embedded
	source code.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iDRC_VALUE = Data rate at which AN transmits data to AT; valid values are from 1 to 14.
	\param iDRC_COVER = DRC cover value associated with the sector from which the forward traffic data at a particular DRC
						value is requested; valid values are from 1 to 7.
	\param iARQ_ENABLE = Enables/disables the early termination feature when decoding the forward channel
	\param iDRC_LOCKPERIOD = Time interval in slots between transmission of two consecutive DRCLock bit transmissions on the
							forward MAC channel; valid values are 0 and 1:
							0 = DRC lock period of 8 slots
							1 = DRC lock period of 16 slots
	\param iDRC_LOCKLENGTH = Number of times a DRCLock bit is repeated; valid values are from 0 to 3:
							0 = Repeated 4 times for Rev 0
							1 = Repeated 8 times for Rev 0
							2 = Repeated 16 times for Rev 0
							3 = Repeated 32 times for Rev 0

	\param iMAC_INDEX = Medium access control index assigned to the AT; valid values are 5 to 63 for Rev 0

	\param iRAB_LENGTH = Number of slots over which reverse activity bit is transmitted; valid values are 0 to 3:
							0 = Corresponds to 8 slots
							1 = Corresponds to 16 slots
							2 = Corresponds to 32 slots
							3 = Corresponds to 64 slots
						This field is applicable only for Rev 0.

	\param iRAB_OFFSET = Slots in which a new reverse activity bit can be transmitted; the value in slots of RAB Offset is the
						 value of the field x RAB_LENGTH/8.

						Valid values are from 0 to 7.

						This field is applicable only for Rev 0.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_DEMOD_FWD_WITH_NO_REV(
										HANDLE hResourceContext,
										unsigned char iDRC_Value,
										unsigned char iDRC_Cover,
										unsigned char iARQ_Enable,
										unsigned char iDRC_Lockperiod,
										unsigned char iDRC_Locklength,
										unsigned char iMAC_Index,
										unsigned char iRAB_Length,
										unsigned char iRAB_Offset);

	/******************************************************************************/
	/**
	EVDO Non-signaling command 3.2.8 Set Idle mode

	This command puts the searcher in Idle mode

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_SET_IDLE( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	EVDO Non-signaling command 3.2.9 Configure Rev A MAC for Forward CC/MAC/FTC

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSHORT_PACKET_ENABLE = Sets the Short Packet mode bit of the MDSP HDR mode register:
								0 = Do not try to decode short packet
								1 = Try all hypotheses, long and short packets, starting with the canonical (long) packet
	\param iMULTI_USER_PACKET_ENABLE = Enables or disables the use of multi-user packet; valid values are 0 and 1:
								0 = Disables multi-user packet
								1 = Enables multi-user packet

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_REV_A_CONF_MAC_FOR_FWD_CC_MAC_FTC(
													HANDLE hResourceContext,
													unsigned char iShort_Packet_Enable,
													unsigned char  iMulti_User_Packet_Enable);

	/******************************************************************************/
	/**
	EVDO Rev A Non-signaling command 3.2.10 Modulate Reverse Access Channel Rev A

	This subcommand modulates the reverse access channel in IS-856 Rev A mode

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iACLC_MASK_I_HI = Upper 32 bits of access channel long code mask for I quadrature, default value is 0x3FF
	\param iACLC_MASK_I_LO = Lower 32 bits of access channel long code mask for I quadrature, default value is 0x0
	\param iACLC_MASK_Q_HI = Upper 32 bits of access channel long code mask for Q quadrature, default value is 0x3FE
	\param iACLC_MASK_Q_LO = Lower 32 bits of access channel long code mask for Q quadrature,default value is 0x1
	\param iAC_TXPATTERN = Data pattern to transmit, recommended value is 0x84B3E374 (a 32-bit Pseudo-Random Bit Sequence)
	\param iACCESS_CYCLE_DURATION = Duration of an access channel cycle in units of slots;
								   valid values are in range of 1 to 255
								   default value is 64.
	\param iOPEN_LOOP_ADJUST = Negative of the nominal power used in open-loop power estimate,
							   expressed as an unsigned value in units of 1 dB
							   Value used by AT is -1 times the value of this field
							   default value is 81 for low bands, 84 for high bands.
	\param iPROBE_INITIAL_ADJUST =	Correction power factor used in open-loop power estimate for initial transmission
									on access channel
									Expressed as 2s complement value in units of 1 dB.
									Valid values are from -16 dB to +15 dB
									default value is 15
	\param iPROBE_NUM_STEP = Maximum number of access probes in single access sequence; valid values are 1 to 15
									default value is 15
	\param iPOWER_STEP = Probe power increase step; valid values are 0 to 15 in units of 0.5 dB, default value is 15 (7.5dB)
	\param iPREAMBLE_LENGTH =	Length of access probe preamble portion in frames of 16 slots; valid values are from 1 to 7 frames
								Applicable only if enhanced access channel feature is not enabled.
								default value is 2
	\param iENHANCED_ACCESS_ENABLE = Whether enhanced access channel is enabled; valid values are 0 and 1:
								0 = Enhanced access channel feature is disabled
								1 = Enhanced access channel feature is enabled
								default value is 1.
	\param iPREAMBLE_LENGTH_SLOTS = Preamble length in slots; valid values are 0 and 1:
								0 = Corresponds to 4 slots
								1 = Corresponds to 16 slots
								Applicable only if enhanced access channel feature is enabled
								default value is 1
	\param iACCESS_OFFSET = Indicates the slot relative to the start of access cycle duration when the access terminal may start
							the access probe; valid values are 0 to 3 in steps of 4 slots
							Defaults to 0 if enhanced acess channel feature is not enabled
	\param iSECTOR_ACCESS_RATE_MAX = Indicates the maximum data rate at which access channel capsule can be transmitted tor the
									particular sector; valid values are from 0 to 2:
									0 = Corresponds to 9.6 kbps
									1 = Corresponds to 19.2 kbps
									2 = Corresponds to 38.4 kbps
									Defaults to 0 if enhanced access channel feature is not enabled
	\param iTERMINAL_ACCESS_RATE_MAX = Indicates the maximum data rate at which AT is allowed to transmit an access probe;
										valid values are from 0 to 2:
									0 = Corresponds to 9.6 kbps
									1 = Corresponds to 19.2 kbps
									2 = Corresponds to 38.4 kbps
									Defaults to 0 if enhanced access channel feature is not enabled

	***********************************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_REV_A_MOD_ACC(	HANDLE hResourceContext,
														unsigned long iACLC_MASK_I_HI,
														unsigned long iACLC_MASK_I_LO,
														unsigned long iACLC_MASK_Q_HI,
														unsigned long iACLC_MASK_Q_LO,
														unsigned long iAC_Txpattern,
														unsigned char iACCESS_CYCLE_DURATION,
														unsigned char iOpen_Loop_Adjust,
														unsigned char iProbe_Initial_Adjust,
														unsigned char iProbe_Num_Step,
														unsigned char iPower_Step,
														unsigned char iPreamble_Length,
														unsigned char iEnhanced_Access_Enable,
														unsigned char iPreamble_Length_Slots,
														unsigned char iAccess_Offset,
														unsigned char iSector_Access_Rate_Max,
														unsigned char iTerminal_Access_Rate_Max);

	/******************************************************************************/
	/**

	EVDO Rev A Non-signaling command 3.2.11 Modulate Reverse Traffic Channel Rev A

	This subcommand modulates the reverse traffic channel in IS-856 Rev A.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iDRC_VALUE = Data rate at which AN transmits data to AT; valid values are 1 to 14
	\param iDRC_COVER_VALUE = DRC cover value associated with the sector from which the forward traffic data at
								particular DRC value is requested; valid values are from 1 to 7
								default value is 1
	\param iDRC_LENGTH = Number of slots the AT shall use to transmit a single DRC value; valid values are from 0 to 3:
						0 = DRC length is 1 slot
						1 = DRC length is 2 slots
						2 = DRC length is 4 slots
						3 = DRC length is 8 slots
						default value is 0.
	\param iDRC_GATING = DRC gating; valid values are 0 or 1:
						0 = Continuous transmission of DRC value in each slot
						1 = Discontinuous transmission of DRC channel
						default value is 0.
	\param iDRC_CH_GAIN = Power of DRC channel relative to pilot channel expressed as 2s complement value in units of 0.5 dB;
						 valid values are from -9 dB to 6 dB;
						 default value is 6 (3dB)
	\param iACK_CH_GAIN = Power of the ACK channel relative to the pilot channel expressed as 2s complement value in units
						  of 0.5 dB; valid values are from -3 dB to 6 dB
						  default value is 6 (3dB)
	\param iDSC_VALUE = Cell cover associated with the forward link data source; valid values are from 1 to 7
						default value is 1
	\param iDSC_LENGTH = Length of single DSC value transmission in units of 8 slots; valid values are from 1 to 32
						 default value is 8 (64 slots)
	\param iDSC_GAIN = Power of the DSC channel relative to the pilot channel in units of -0.5 dB;
						valid values are from 0 to -15.5 dB
						default value is 18 (-9dB)
	\param iRPC_STEP = Power control step size to be used by AT when controlling the power of reverse link; valid values are 0 and 1:
						0 = Corresponds to 0.5 dB step
						1 = Corresponds to 1 dB step
						default value is 1 dB
	\param iFRAME_OFFSET = Offset from CDMA system time for frame start in units of slots; valid values are from 0 to 15 slots
						default value is 0
	\param iRPC_ENABLE = RPC enable/disable
						default value is true (enable)
	\param iRTC_TXPATTERN = Data pattern to transmit
						recommended value is 0x84B3E374 (a 32-bit Pseudo-Random Bit Sequence)
	\param iLCM_I_CHAN_HI = Long code mask for I channel high 32 bits, default value is 0x3FF
	\param iLCM_I_CHAN_LOW = Long code mask for I channel low 32 bits, default value is 0x0
	\param iLCM_Q_CHAN_HI = Long code mask for q channel high 32 bits, default value is 0x3FE
	\param iLCM_Q_CHAN_LOW = Long code mask for q channel low 32 bits, default value is 0x1
	\param iRRI_PAYLOAD = Physical layer packet size index; valid values are from 1 to 12
	\param iHI_CAP_LO_LATENCY = The transmit mode of operation; valid values are 0 and 1:
								0 = High capacity
								1 = Low latency
								default value is 0
	\param iGAIN_TRANSITION_POINT = Set to one less than the number of subframes for which the receiver shall use
									pretransition T2P values and the number of subpackets after
									which the receiver shall use posttransition values based on the above-set transmission
									mode and RRI; valid values are from 0 to 3
									default value is 3 (must be 3 to comply with 3GPP2 Spec IS-866-A)
	\param iT2P_PRE_TRANSITION = Set to the data channel power relative to the pilot channel power based on above-set RRI and
								 transmission mode for the subframes prior to T2P transition;
								 valid values are from 0 to 128 (inclusive) in units of 0.25 dB
								 default values are:
								 For high capacity mode: {3, 15, 28, 35, 40, 46, 52, 57, 62, 68, 74, 85} for RRI payload from 128 bits to 12288 bits.
								 For low latency mode: {28, 40, 52, 59, 65, 73, 77, 77, 82, 87, 93, 105} for RRI payload from 128 bits to 12288 bits.
	\param iT2P_POST_TRANSITION = Set to the data channel power relative to the pilot channel power based on above-set RRI and
								transmission mode for the subframes following the T2P_transition_point;
								valid values are from 0 to 128 (inclusive) in units of 0.25 dB
								default values are:
								 For both high capacity and low latency modes: {3, 15, 28, 35, 40, 46, 52, 57, 62, 68, 74, 85} for RRI payload from 128 bits to 12288 bits.
	\param iARQ_MODE = Reverse link ARQ mode for sending Acks to and Nacks for reverse link packets; valid values are 0 and 1:
								0 = ARQ mode bi-polar
								1 = ARQ mode ON-OFF keying
								default value is 0
	\param iAUX_PILOT_MIN_PAYLOAD =	Minimum reverse traffic channel payload for which the acess channel is required to
									transmit the auxiliary pilot channel; valid values are from 0 to 11
									default value is 7 (3072 bits). Note that this payload starts from 0.
	\param iAUX_PILOT_CHAN_GAIN = Set to auxiliary pilot channel gain relative to the traffic data channel gain;
									a 4-bit value in units of -1 dB in the range of 0 to -15 dB
									default value is 12 (-12dB)
	\param iRRICH_GAIN_PRE_TRANSITION = Set to RRI channel gain for the subframes transmitted before the T2P transition
										based on above-set RRI and transmission mode; specified as
										2s complement 4-bit number in units of 1 dB
										default values are 0 for gain transition point 0, 1; -6 dB for gain transition point 2, 3.
	\param iRRICH_GAIN_POST_TRANSITION = Set to RRI channel gain for the subframes transmitted following the T2P transition
										based on above-set RRI and transmission mode;
										specified as 2s complement 4-bit number in units of 1 dB
										default values are -6 dB for all gain transition points.
	\param iHDR_ACK_Mode = ack, nak, or do not ack every slot in the non-signaling
			Mode:
		\code
           0 = FTM_EVDO_IS856_COMPLIANT: Normal IS-856 operation. Early decode enabled; do not ack.
           1 = FTM_EVDO_IS856_NO_ACK: IS856 but with no early termination. Early decode disabled; do not ack.
           2 = FTM_EVDO_IS890_MODE_0: First slot decode mode. Ack each slot (test app mode).
           3 = FTM_EVDO_IS890_MODE_1: Full packet decode mode; Nak each slot (test app mode).
           4 = FTM_EVDO_IS890A_MODE_ACK_BPSK: Always ack with bipolar keying (BPSK) modulation.
           5 = FTM_EVDO_IS890A_MODE_NAK_BPSK: Always nak with bipolar keying (BPSK) modulation.
           6 = FTM_EVDO_IS890A_MODE_ACK_OOK: Always ack with on-off keying (OOK) modulation.
           7 = FTM_EVDO_IS890A_MODE_NAK_OOK: Always nak with on-off keying (OOK) modulation.
		\endcode
		Default value is 3, FTM_EVDO_IS890_MODE_1. (Must be FTM_EVDO_IS890_MODE_1 to comply with 3GPP2 Spec IS-866-A)
	*********************************************************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_REV_A_MOD_TRA(	HANDLE hResourceContext,
														unsigned char iDRC_Value,
														unsigned char iDRC_Cover_Value,
														unsigned char iDRC_Length,
														unsigned char iDRC_Gating,
														char iDRC_Ch_Gain,
														char iACK_Ch_Gain,
														unsigned char iDSC_Value,
														unsigned char iDSC_Length,
														unsigned char iDSC_Gain,
														unsigned char iRPC_Step,
														unsigned char iFrame_Offset,
														unsigned char iRPC_Enable,
														unsigned long iRTC_Txpattern,
														unsigned long iLCM_I_CHAN_HI,
														unsigned long iLCM_I_CHAN_LOW,
														unsigned long iLCM_Q_CHAN_HI,
														unsigned long iLCM_Q_CHAN_LOW,
														unsigned char iRRI_Payload,
														unsigned char iHi_Cap_Lo_Latency,
														unsigned char iGain_Transition_Point,
														unsigned char iT2P_Pre_Transition,
														unsigned char iT2P_Post_Transition,
														unsigned char iARQ_Mode,
														unsigned char iAux_Pilot_Min_Payload,
														unsigned char iAux_Pilot_Chan_Gain,
														char iRRICH_Gain_Pre_Transition,
														char iRRICH_Gain_Post_Transition,
														unsigned char iHDR_ACK_Mode);

	/*********************************************************************************************************************/
	/**

	EVDO Rev A Non-signaling command 3.2.12 Demodulate Forward Link with No Reverse Link Rev A

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iDRC_VALUE = Data rate at which AN transmits data to AT; valid values are from 1 to 14
	\param iDRC_COVER = DRC cover value associated with the sector from which the forward traffic data at a particular DRC
						value is requested; valid values are from 1 to 7
	\param iDSC_VALUE = Cell cover associated with the forward link data source; valid values are from 1 to 7
	\param iARQ_ENABLE = Enables/disables the early termination feature when decoding the forward channel
	\param iDRC_LOCKPERIOD =	Time interval in slots between transmission of two consecutive DRCLock bit transmissions on the
								forward MAC channel; valid values are 0 and 1:
								0 = DRC lock period of 8 slots
								1 = DRC lock period of 16 slots
	\param iDRC_LOCKLENGTH = Number of times a DRCLock bit is repeated; valid values are from 0 to 3:
							0 = Repeated 8 times for Rev A
							1 = Repeated 16 times for Rev A
							2 = Repeated 32 times for Rev A
							3 = Repeated 64 times for Rev A
	\param iMAC_INDEX = Medium access control index assigned to the AT; valid values are 5 to 63 and 72 to 127 for Rev A
	\param iRAB_LENGTH = Number of slots over which reverse activity bit is transmitted; valid values are from 0 to 3:
							0 = Corresponds to 8 slots
							1 = Corresponds to 16 slots
							2 = Corresponds to 32 slots
							3 = Corresponds to 64 slots
						This field is applicable only for Rev0. For RevA mode, this field is always set to 0.
	\param iRAB_OFFSET = Slots in which a new reverse activity bit can be transmitted.
						The value in slots of RAB Offset is the value of the field x RAB_LENGTH/8;
						valid values are from 0 to 7.
						This field is applicable only for Rev 0.
						For Rev A mode, this field is always set to 0.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_REV_A_DEMOD_FWD_WITH_NO_REV(	HANDLE hResourceContext,
																		unsigned char iDRC_Value,
																		unsigned char iDRC_Cover,
																		unsigned char iDSC_Value,
																		unsigned char iARQ_Enable,
																		unsigned char iDRC_Lockperiod,
																		unsigned char iDRC_Locklength,
																		unsigned char iMAC_Index,
																		unsigned char iRAB_Length,
																		unsigned char iRAB_Offset);

	/******************************************************************************/
	/**
	EVDO Rev B Non-signaling command: Modulate Reverse Traffic Channel Rev B.
	This command supports 1 FL and multi-RL carriers.
	The Open loop estimate of the 2nd and 3rd carriers are copied from main RL carrier.
	When RPC is disabled, all RL carriers can have a power offset on top of the open loop estimate.
	When RPC is enabled, the power offsets do not take effect. the reverse power will be controlled by the forward link.
		The close loop adjust of the 1st (main) RL carrier is carrierd over to the 2nd/3rd carrier.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param bSingleFLMode	= to indicate if the open loop estimate of the multi-carrier reverse link carriers
						will be derived from the main carrier (on which the pilot/system time is acquired).
						Currently AMSS only supports bSingleFLMode = TRUE (param reserved for further extension).
						This parameter does not affect the capability to decode multi-forward link carriers.
						Configure the equipment at the desired RF frequences, and use this command to make a Rev. B call.
						The modem will automatically decode all forward carriers and provide valid PER measurement on each carrier.
	\param iNum_RL_Carriers = num of carriers to modulate. valid values are 1, 2 and 3.
	\param iDRC_VALUE = Data rate at which AN transmits data to AT; valid values are 1 to 14.
						New Rev. B data rates with DRC values from 16 to 27 are allowed on supported AMSS
						NOTE: This DRC value is used on ALL forward carriers,
						thus the physical FL signal on equipment must be configured to use the same DRC.
	\param iDRC_CH_GAIN = Power of DRC channel relative to pilot channel n units of 0.5 dB;
						valid values are -18 to +12 (corresponding from -9 dB to 6 dB)
						default value is 6 (3dB)
	\param iACK_CH_GAIN = Power of the ACK channel relative to the pilot channelin units
						  of 0.5 dB; valid values are -6 to +12 (corresponding from -3 dB to 6 dB)
  						default value is 6 (3dB)
	\param iDSC_GAIN = Power of the DSC channel relative to the pilot channel in units of -0.5 dB;
						valid values are from 0 to 31 (corresponding from 0 to -15.5 dB)
						default value is 18 (-9dB)
	\param iRPC_STEP = Power control step size to be used by AT when controlling the power of reverse link:
					\code
					0 = FTM_EVDO_RPC_STEP_HalfdB: Corresponds to 0.5 dB step
					1 = FTM_EVDO_RPC_STEP_1dB: Corresponds to 1 dB step
					\endcode
					defaut value is 1 dB.
	\param iRPC_ENABLE = enable/disable reverse power control.
					TRUE = Enable RPC
					FALSE = Disable RPC
	\param iRRI_PAYLOAD = Revese link physical layer packet size index; valid values are from 1 to 12 (corresponding from 128Bit to 12288Bit)
	\param iHI_CAP_LO_LATENCY = The transmit mode of operation
				\code
				0 = FTM_EVDO_HIGH_CAPACITY: High capacity,
				1 = FTM_EVDO_LOW_LATENCY: Low capacity
				\endcode
				defaut value is 0:FTM_EVDO_HIGH_CAPACITY

	\param iAUX_PILOT_CHAN_GAIN = Set to auxiliary pilot channel gain relative to the traffic data channel gain;
								a 4-bit value in units of -1 dB.
								valid values are from 0 to 15 (corresponding from 0 to -15 dB)
								default value is 12 (-12 dB)
	\param iPower_Offset = Tx power offset of the main RL carrier from open loop estimate in unit of 1/4 dB, valid only when RPC is disabled.
	\param iRL_2_Channel = channel number of the 2nd RL carrier. Must follow MaxSeparation constraint. valid only when iNum_RL_Carriers =2 or 3
	\param iRL_2_Power_Offset = Tx power offset of the 2nd RL carrier in unit of 1/4 dB, valid only when RPC is disabled and iNum_RL_Carriers = 2 or 3
	\param iRL_2_RRI_Payload = Reverse Rate Indicator Payload of the 2nd RL carrier. valid values are from 1 to 12. valid only only when iNum_RL_Carriers =2 or 3
	\param iRL_3_Channel = channel number of the 3rd RL carrier. Must follow MaxSeparation constraint. valid only when iNum_RL_Carriers =3
	\param iRL_3_Power_Offset = Tx power offset of the 3rd RL carrier in unit of 1/4 dB, valid only when RPC is disabled and iNum_RL_Carriers =3
	\param iRL_3_RRI_Payload = Reverse Rate Indicator Payload of the 3rd RL carrier. valid values are from 1 to 12, valid only when iNum_RL_Carriers =3

	\return true if successful, false if fail.

	\note: The following sequence should be used to call this command.
		QLIB_FTM_EVDO_NS_Start
		QLIB_FTM_EVDO_PILOT_ACQ
		QLIB_FTM_EVDO_SYS_TIME_ACQ
		QLIB_FTM_EVDO_REV_A_MOD_ACC (same API for Rev. A access channel)
		QLIB_FTM_EVDO_REV_B_CONFIG_RTC(optional)
		QLIB_FTM_EVDO_REV_B_MOD_RTC

	*********************************************************************************************************************/

	QLIB_API unsigned char QLIB_FTM_EVDO_REV_B_MOD_RTC(	HANDLE hResourceContext,
														 unsigned char bSingleFLMode,
														 unsigned char iNum_RL_Carriers,
														 unsigned char iDRC_Value,
														 char iDRC_Ch_Gain,
														 char iACK_Ch_Gain,
														 unsigned char iDSC_Gain,
				   										 unsigned char iRPC_Step,
				   										 unsigned char iRPC_Enable,
				   										 unsigned char iRRI_Payload,
				   										 unsigned char iHi_Cap_Lo_Latency,
				   										 unsigned char iAux_Pilot_Chan_Gain,
				   										 unsigned char iPower_Offset,
				   										 unsigned short iRL2_Channel,
				   										 unsigned char iRL2_Power_Offset,
				   										 unsigned char iRL2_RRI_Payload,
				   										 unsigned short iRL3_Channel,
				   										 unsigned char iRL3_Power_Offset,
				   										 unsigned char iRL3_RRI_Payload
														);


	/******************************************************************************/
	/**

	EVDO Rev B Non-signaling command: Configure Reverse Traffic Channel Rev B
	This function is not required if using default values. Otherwise, it can be called multiple times to configure all required fields.
	For example, to configure T2P pre-transition gain for different rri.
	AT will reject this command if AT's current state is in Traffic, and the return value will be false.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iDRC_COVER_VALUE = DRC cover value associated with the sector from which the forward traffic data at
							particular DRC value is requested; valid values are from 1 to 7. default value is 1.
	\param iDRC_LENGTH = Number of slots the AT shall use to transmit a single DRC value
		\code
               0 = FTM_EVDO_DRC_1_SLOTS: DRC length is 1 slot
		 1 = FTM_EVDO_DRC_2_SLOTS: DRC length is 2 slots
		 2 = FTM_EVDO_DRC_4_SLOTS: DRC length is 4 slots
		 3 = FTM_EVDO_DRC_8_SLOTS: DRC length is 8 slots
		\endcode
		default value is 0: FTM_EVDO_DRC_1_SLOTS.
	\param iDRC_GATING = DRC gating:
			0 = FTM_EVDO_DRC_CONTINUOUS:Continuous transmission of DRC value in each slot
			1 = FTM_EVDO_DRC_DISCONTINOUS = Discontinuous transmission of DRC channel
			Default value is 0: FTM_EVDO_DRC_CONTINUOUS
	\param iDSC_VALUE = Cell cover associated with the forward link data source; valid values are from 1 to 7
						default 1.
	\param iDSC_LENGTH = Length of single DSC value transmission in units of 8 slots; valid values are from 1 to 32
						default 8 (64 slots)
	\param iFRAME_OFFSET = Offset from CDMA system time for frame start in units of slots; valid values are from 0 to 15 slots
						default 0
	\param iRTC_TXPATTERN = Data pattern to transmit. recommended value is 0x84B3E374 (a 32-bit Pseudo-Random Bit Sequence)
	\param iLCM_I_CHAN_HI = Long code mask for I channel high 32 bits. default 0x3ff
	\param iLCM_I_CHAN_LOW = Long code mask for I channel low 32 bits. default 0x0
	\param iLCM_Q_CHAN_HI = Long code mask for q channel high 32 bits. default 0x3fe
	\param iLCM_Q_CHAN_LOW = Long code mask for q channel low 32 bits. default 0x1
	\param iARQ_MODE = Reverse link ARQ mode for sending Acks to and Nacks for reverse link packets:
			\code
			0 = FTM_EVDO_ARQ_BPSK: ARQ mode bi-polar FTM_EVDO_ARQ_BPSK,
			1 = FTM_EVDO_ARQ_OOK: ARQ mode ON-OFF keying
			\endcode
			default value is 0, FTM_EVDO_ARQ_BPSK
	\param iHDR_ACK_Mode = ack, nak, or do not ack every slot in the non-signaling mode:
			\code
			   0 = FTM_EVDO_IS856_COMPLIANT: Normal IS-856 operation. Early decode enabled; do not ack.
			   1 = FTM_EVDO_IS856_NO_ACK: IS856 but with no early termination. Early decode disabled; do not ack.
			   2 = FTM_EVDO_IS890_MODE_0: First slot decode mode. Ack each slot (test app mode).
			   3 = FTM_EVDO_IS890_MODE_1: Full packet decode mode; Nak each slot (test app mode).
			   4 = FTM_EVDO_IS890A_MODE_ACK_BPSK: Always ack with bipolar keying (BPSK) modulation.
			   5 = FTM_EVDO_IS890A_MODE_NAK_BPSK: Always nak with bipolar keying (BPSK) modulation.
			   6 = FTM_EVDO_IS890A_MODE_ACK_OOK: Always ack with on-off keying (OOK) modulation.
			   7 = FTM_EVDO_IS890A_MODE_NAK_OOK: Always nak with on-off keying (OOK) modulation.
			\endcode
			Default value is 3, FTM_EVDO_IS890_MODE_1. (Must be FTM_EVDO_IS890_MODE_1 to comply with 3GPP2 Spec IS-866-A)
	\param iAUX_PILOT_MIN_PAYLOAD =	Minimum reverse traffic channel payload for which the acess channel is required to
									transmit the auxiliary pilot channel; valid values are from 0 to 11.
									Default value is 7: 3072 bit.
	\param iRRI_PAYLOAD = Physical layer packet size index used only to configure T2P and RRI channel gain parameters;
									valid values are from 1 to 12
	\param iHI_CAP_LO_LATENCY = The transmit mode of operation used only to configure T2P and RRI channel gain parameters
			\code
			0 = FTM_EVDO_HIGH_CAPACITY: High capacity,
			1 = FTM_EVDO_LOW_LATENCY: Low capacity
			\endcode
			defaut value is 0:FTM_EVDO_HIGH_CAPACITY

	\param iGAIN_TRANSITION_POINT = Set to one less than the number of subframes for which the receiver shall use
									pretransition T2P values and the number of subpackets after
									which the receiver shall use posttransition values based on the above-set transmission
									mode and RRI; valid values are from 0 to 3. Default value is 3.
	\param iT2P_PRE_TRANSITION = Set to the data channel power relative to the pilot channel power based on above-set RRI and
								 transmission mode for the subframes prior to T2P transition;
								 valid values are from 0 to 128 (inclusive) in units of 0.25 dB.
								 Default vlues are:
								 high capacity mode: 3, 15, 28, 35, 40, 46, 52, 57, 62, 68, 74, 85 for RRI from 1 to 12
								 low latency mode: 28, 40, 52, 59, 65, 73, 77, 77, 82, 87, 93, 105 for RRI from 1 to 12
	\param iT2P_POST_TRANSITION = Set to the data channel power relative to the pilot channel power based on above-set RRI and
								transmission mode for the subframes following the T2P_transition_point;
								valid values are from 0 to 128 (inclusive) in units of 0.25 dB
								 Default vlues are:
								 both high capacity and low latency modes: 3, 15, 28, 35, 40, 46, 52, 57, 62, 68, 74, 85 for RRI from 1 to 12

	\param iRRICH_GAIN_PRE_TRANSITION = Set to RRI channel gain for the subframes transmitted before the T2P transition
										based on above-set RRI and transmission mode; Unit is 1 dB
								default values are: 0,0,-6,-6 for gain transition point from 0 to 3
	\param iRRICH_GAIN_POST_TRANSITION = Set to RRI channel gain for the subframes transmitted following the T2P transition
										based on above-set RRI and transmission mode; in units of 1 dB
								default values are: -6,-6,-6,-6 for gain transition point from 0 to 3

	\return true if successful, false if fail.

	*********************************************************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_REV_B_CONFIG_RTC(	HANDLE hResourceContext,
												unsigned char iDRC_Cover_Value,
												unsigned char iDRC_Length,
												unsigned char iDRC_Gating,
												unsigned char iDSC_Value,
												unsigned char iDSC_Length,
												unsigned char iFrame_Offset,
												unsigned long iRTC_Txpattern,
												unsigned long iLCM_I_CHAN_HI,
												unsigned long iLCM_I_CHAN_LOW,
												unsigned long iLCM_Q_CHAN_HI,
												unsigned long iLCM_Q_CHAN_LOW,
												unsigned char iARQ_Mode,
												unsigned char iHDR_ACK_Mode,
												unsigned char iAux_Pilot_Min_Payload,
												unsigned char iRRI_Payload,
												unsigned char iHi_Cap_Lo_Latency,
												unsigned char iGain_Transition_Point,
												unsigned char iT2P_Pre_Transition,
												unsigned char iT2P_Post_Transition,
												char iRRICH_Gain_Pre_Transition,
												char iRRICH_Gain_Post_Transition);

	/******************************************************************************
	/**
	EVDO Non-signaling command: set same channel params, including pilot add, pilot drop, pilot compare, etc.
	This function is not required to bring up an FTM non-signaling call. Call it only if reconfiguration is required.
	This function applies to Rel. 0, Rev. A and Rev. B, on supported AMSS.
	See 3GPP2 C.S0024-B v2.0: cdma2000 High Rate Packet Data Air Interface Specification, section 7.8.7.2.2 SetManagementSameChannelParameters Attribute.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param	iPilot_Add = Pilot detecting threshold (in -0.5 dB) .
						This value is used by the access terminal to trigger a RouteUpdate in the Connected State.
						Valid values are from 0x0 to 0x3F (0 to 63).
						Default value is 0x0e (-7dB)
	\param 	iPilot_Drop = Threshold to start drop timer (in -0.5 dB)
						This value is used by the access terminal to start a pilot drop timer for a pilot in the Active Set or the Candidate Set.
						Valid values are from 0x0 to 0x3F (0 to 63)
						Default value is 0x12 (-9dB)
	\param 	iPilot_Compare = Comparison threshold for Route Update message (in 0.5 dB)
						Active Set versus Candidate Set comparison threshold, expressed as a 2s complement number.
						Valid values are from 0x0 to 0x3F (0 to 63)
						Default value is 0x05
	\param 	iPilot_Drop_Timer = Expiration time of the Drop timer (lookup table)
						\code
							typedef enum
							{
							  FTM_EVDO_DROPTIMER_100_MS,
							  FTM_EVDO_DROPTIMER_1_SEC,
							  FTM_EVDO_DROPTIMER_2_SEC,
							  FTM_EVDO_DROPTIMER_4_SEC,
							  FTM_EVDO_DROPTIMER_6_SEC,
							  FTM_EVDO_DROPTIMER_9_SEC,
							  FTM_EVDO_DROPTIMER_13_SEC,
							  FTM_EVDO_DROPTIMER_19_SEC,
							  FTM_EVDO_DROPTIMER_27_SEC,
							  FTM_EVDO_DROPTIMER_39_SEC,
							  FTM_EVDO_DROPTIMER_55_SEC,
							  FTM_EVDO_DROPTIMER_79_SEC,
							  FTM_EVDO_DROPTIMER_112_SEC,
							  FTM_EVDO_DROPTIMER_159_SEC,
							  FTM_EVDO_DROPTIMER_225_SEC,
							  FTM_EVDO_DROPTIMER_319_SEC,
							  FTM_EVDO_DROPTIMER_MAX_SIZE
							}FTM_EVDO_DROP_TIMER_Enum
						\endcode
						Default value is FTM_EVDO_DROPTIMER_4_SEC
	\param 	bDynamic_Thresholds = Flag to indicate if following 3 parameters are valid
						This field shall be set to 1 if the following three fields are used. Otherwise, this field shall be set to 0.
						Default value is 0.
	\param 	iSoft_Slope = This field is valid only if DynamicThresholds is set to 1.
						This field shall be set to an unsigned binary number, which is used
						by the access terminal in the inequality criterion for adding a pilot to
						the Active Set or dropping a pilot from the Active Set.
						Default value is 0
	\param 	iAdd_Intercept = This field is valid only if DynamicThresholds is set to 1.
						This field shall be set to a 2s complement signed binary number in
						units of dB.
						Default value is 0
	\param 	iDrop_Intercept = This field is valid only if DynamicThresholds is set to 1.
						This field shall be set to a 2s complement signed binary number in
						units of dB.
						Default value is 0
	\param 	iNset_Max_Age = Maximum age for NSET pilots.  Pilots this old are dropped first.
						No unit. This value is used by AMSS to limit a counter (AGE).
						The AGE counter behavior is described in 3GPP2 C.S0024-B v2.0,
						section 7.8.6.1.2.7 Neighbor Set Management for Default Route Update Protocol (Rev.0/A),
						section 7.9.6.1.2.10 Neighbor Set Management for Multi-carrier Route Update Protocol (Rev. B).
						Default value is 0
	\return true if successful, false if fail.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_CONFIG_SAME_CHANNEL (HANDLE hResourceContext,
												unsigned short iPilot_Add,
												unsigned short iPilot_Drop,
												unsigned short iPilot_Compare,
												unsigned char iPilot_Drop_Timer,
												unsigned char bDynamic_Thresholds,
												char iSoft_Slope,
												char iAdd_Intercept,
												char iDrop_Intercept,
												unsigned char iNset_Max_Age);

	/******************************************************************************
	/**
	EVDO Non-signaling command: configure reverse traffic channel tx data pattern for rev. b.
	This function is not required to bring up an FTM non-signaling call. Call it only if reconfiguration is required.
	This function applies to Rev. B, on supported AMSS.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param	iUse_Pattern = if or not to use fixed data pattern.
			true = the following tx patterns for each carrier will be repeated for entire tx packet
			false = the modem will generte random bytes in the entire tx packet.
	\note	the following params only takes effect when iUse_Pattern = true
	\param	iRL1Tx_Pattern = 32 bits Tx data pattern on reverse link carrier 1.
	\param	iRL2Tx_Pattern = 32 bits Tx data pattern on reverse link carrier 2.
	\param	iRL3Tx_Pattern = 32 bits Tx data pattern on reverse link carrier 3.
	\return true if successful, false if fail.
	\warning It's recommended to use random data bytes in reverse traffic channel (by not calling this command or use iUse_Pattern = 0).
			If use fixed data pattern, it's important to use different patterns on each reverse carrier, to minimize the correlations.
			The recommended values include: (32-bit Pseudo-Random Bit Sequences)
			0x84B3E374, 0x3E375096, 0xEA12CF8D
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_REV_B_CONFIG_RTC_TX_PATTERN (HANDLE hResourceContext,
												unsigned char iUse_Pattern,
												unsigned long iRL1Tx_Pattern,
												unsigned long iRL2Tx_Pattern,
												unsigned long iRL3Tx_Pattern);


	/******************************************************************************/
	/**
	1XEV-DO Non-signaling, command to make a 1xEV-DO Release 0 non-signaling call in the desired band and channel.

	This command makes a 1xEV-DO non-signaling call with default parameters for access and traffic channel.
	After this command is successful, use QLIB_FTM_EVDO_NS_EnableMeasurementLogs to enable the measurement log code,
	And use QLIB_FTM_EVDO_NS_GetStatus to poll the measurement result.
	The forward link signal level can be changed to the desired level to perform measurement without affecting the existing call.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iBand_Class = Indicates the band class. Possible values are:
		\code
	          FTM_EVDO_BAND_CLASS_CELLULAR	= 0,
	          FTM_EVDO_BAND_CLASS_PCS			= 1,
	          FTM_EVDO_BAND_BC0	= 0,
	          FTM_EVDO_BAND_BC1	= 1,
	          FTM_EVDO_BAND_BC2	= 2,
	          FTM_EVDO_BAND_BC3	= 3,
	          FTM_EVDO_BAND_BC4	= 4,
	          FTM_EVDO_BAND_BC5	= 5,
	          FTM_EVDO_BAND_BC6	= 6,
	          FTM_EVDO_BAND_BC7	= 7,
	          FTM_EVDO_BAND_BC8	= 8,
	          FTM_EVDO_BAND_BC9	= 9,
	          FTM_EVDO_BAND_BC10	= 10,
	          FTM_EVDO_BAND_BC11	= 11,
	          FTM_EVDO_BAND_BC12	= 12,
	          FTM_EVDO_BAND_BC13	= 13,
	          FTM_EVDO_BAND_BC14	= 14,
	          FTM_EVDO_BAND_BC15	= 15,
	          FTM_EVDO_BAND_BC16	= 16,
	          FTM_EVDO_BAND_BC17	= 17
		\endcode

	\param iCdma_Freq = Indicates the RF channel number.
	\param iDRC_Value = DRC index of forward traffic channel, valid values are from 1 to 12
	\param iRRI = Reverse rate indicator. valid values are from 1 to 5.
	\param bEnableRPC = enable or disable reverse power control.
	\param iDiversity_Mode = enable or disable diversity mode.
	\param iMax_Num_Attempt = the maximum allowed attempts to make an FTM non-signaling call.

	\return true if successful, false if fail.

	\warning Test equipment must be set to the desired band, channel and MAC index= 63 before calling this command.

			A failed return value (false) indicates phone fails to make an FTM non-signaling call.
			Make sure test equipment has been properly set to the desired band, channel,
			and it transmits a moderate forward link signal (e.g., -55 - -75 dBm).
			If the failure remains, a phone reset is recommended.

	\note The following sub-commands are called until a call is made, or the function reaches the maximum allowed number of attempts.
		The access channel and traffic channel will use default parameters.
		For a complete list of default parameters, see the subcommand respectively.
		\code
			//step 1: enable NS and clear status.
			QLIB_FTM_EVDO_NS_Start;
			//step 2: make sure previous call is down
			QLIB_FTM_EVDO_CMD_RELEASE;
			//step 3: acq pilot
			QLIB_FTM_EVDO_PILOT_ACQ
			//step 4: acq time
			QLIB_FTM_EVDO_SYS_TIME_ACQ
			//step 5: mod acc chan.
			QLIB_FTM_EVDO_MOD_ACC
			//wait half second for phone to transmit at least 1 probe.
			Sleep(500);
			//step 6: mod RTC
			QLIB_FTM_EVDO_MOD_TRA
		\endcode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_REV_0_START_CALL(
								HANDLE hResourceContext,
								unsigned long iBand_Class,
								unsigned short iCDMA_Freq,
								unsigned char iDRC_Value,
								unsigned char iRRI,
								unsigned char bEnableRPC,
								unsigned long iDiversity_Mode,
								unsigned short iMax_Num_Attempt);


	/******************************************************************************/
	/**
	1XEV-DO Non-signaling, command to make a 1xEV-DO Revision A non-signaling call in the desired band and channel.

	This command makes a 1xEV-DO non-signaling call with default parameters for access and traffic channel.
	After this command is successful, use QLIB_FTM_EVDO_NS_EnableMeasurementLogs to enable the measurement log code,
	And use QLIB_FTM_EVDO_NS_GetStatus to poll the measurement result.
	The forward link signal level can be changed to the desired level to perform measurement without affecting the existing call.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iBand_Class = Indicates the band class. Possible values are:
		\code
	          FTM_EVDO_BAND_CLASS_CELLULAR	= 0,
	          FTM_EVDO_BAND_CLASS_PCS			= 1,
	          FTM_EVDO_BAND_BC0	= 0,
	          FTM_EVDO_BAND_BC1	= 1,
	          FTM_EVDO_BAND_BC2	= 2,
	          FTM_EVDO_BAND_BC3	= 3,
	          FTM_EVDO_BAND_BC4	= 4,
	          FTM_EVDO_BAND_BC5	= 5,
	          FTM_EVDO_BAND_BC6	= 6,
	          FTM_EVDO_BAND_BC7	= 7,
	          FTM_EVDO_BAND_BC8	= 8,
	          FTM_EVDO_BAND_BC9	= 9,
	          FTM_EVDO_BAND_BC10	= 10,
	          FTM_EVDO_BAND_BC11	= 11,
	          FTM_EVDO_BAND_BC12	= 12,
	          FTM_EVDO_BAND_BC13	= 13,
	          FTM_EVDO_BAND_BC14	= 14,
	          FTM_EVDO_BAND_BC15	= 15,
	          FTM_EVDO_BAND_BC16	= 16,
	          FTM_EVDO_BAND_BC17	= 17
		\endcode

	\param iCdma_Freq = Indicates the RF channel number.
	\param iDRC_Value = DRC index of forward traffic channel; valid values are from 1 to 14.
	\param iRRI_PAYLOAD = Physical layer packet size index; valid values are from 1 to 12
	\param bEnableRPC = enable or disable reverse power control.
	\param iDiversity_Mode = enable or disable diversity mode.
	\param iMax_Num_Attempt = the maximum allowed attempts to make an FTM non-signaling call.

	\return true if successful, false if fail.

	\warning Test equipment must be set to the desired band, channel and MAC index= 63 before calling this command.

			A failed return value (false) indicates phone fails to make an FTM non-signaling call.
			Make sure test equipment has been properly set to the desired band, channel,
			and it transmits a moderate forward link signal (e.g., -55 - -75 dBm).
			If the failure remains, a phone reset is recommended.

	\note The following sub-commands are called until a call is made, or the function reaches the maximum allowed number of attempts.
		The access channel and traffic channel will use default parameters.
		For a complete list of default parameters, see the subcommand respectively.
		\code
			//step 1: enable NS and clear status.
			QLIB_FTM_EVDO_NS_Start
			//step 2: make sure previous call is down
			QLIB_FTM_EVDO_CMD_RELEASE
			//step 3: acq pilot
			QLIB_FTM_EVDO_PILOT_ACQ
			//step 4: acq time
			QLIB_FTM_EVDO_SYS_TIME_ACQ
			//step 5: mod acc chan.
			QLIB_FTM_EVDO_REV_A_MOD_ACC
			//wait half second for phone to transmit at least 1 probe.
			Sleep(500);
			//step 6: mod RTC
			QLIB_FTM_EVDO_REV_A_MOD_TRA
		\endcode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_REV_A_START_CALL(
								HANDLE hResourceContext,
								unsigned long iBand_Class,
								unsigned short iCDMA_Freq,
								unsigned char iDRC_Value,
								unsigned char iRRI_Payload,
								unsigned char bEnableRPC,
								unsigned long iDiversity_Mode,
								unsigned short iMax_Num_Attempt);

	/******************************************************************************/
	/**
	1XEV-DO Non-signaling, command to make a 1xEV-DO Revision B non-signaling call in the desired band and channel.

	This command makes a 1xEV-DO non-signaling call with default parameters for access and traffic channel.
	After this command is successful, use QLIB_FTM_EVDO_NS_EnableMeasurementLogs to enable the measurement log code,
	And use QLIB_FTM_EVDO_NS_GetStatus to poll the measurement result.
	The forward link signal level can be changed to the desired level to perform measurement without affecting the existing call.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iBand_Class = Indicates the band class. Possible values are:
		\code
	          FTM_EVDO_BAND_CLASS_CELLULAR	= 0,
	          FTM_EVDO_BAND_CLASS_PCS			= 1,
	          FTM_EVDO_BAND_BC0	= 0,
	          FTM_EVDO_BAND_BC1	= 1,
	          FTM_EVDO_BAND_BC2	= 2,
	          FTM_EVDO_BAND_BC3	= 3,
	          FTM_EVDO_BAND_BC4	= 4,
	          FTM_EVDO_BAND_BC5	= 5,
	          FTM_EVDO_BAND_BC6	= 6,
	          FTM_EVDO_BAND_BC7	= 7,
	          FTM_EVDO_BAND_BC8	= 8,
	          FTM_EVDO_BAND_BC9	= 9,
	          FTM_EVDO_BAND_BC10	= 10,
	          FTM_EVDO_BAND_BC11	= 11,
	          FTM_EVDO_BAND_BC12	= 12,
	          FTM_EVDO_BAND_BC13	= 13,
	          FTM_EVDO_BAND_BC14	= 14,
	          FTM_EVDO_BAND_BC15	= 15,
	          FTM_EVDO_BAND_BC16	= 16,
	          FTM_EVDO_BAND_BC17	= 17
		\endcode

	\param iCdma_Freq = Indicates the RF channel number.
	\param iDRC_Value = DRC index of forward traffic channel; valid values are from 1 to 14;
						New Rev. B data rates with DRC values from 16 to 27 are allowed on supported AMSS
						NOTE: This DRC value is used on ALL forward carriers,
						thus the physical FL signal on equipment must be configured to use the same DRC.
	\param iRRI_PAYLOAD = Physical layer packet size index; valid values are from 1 to 12
	\param bEnableRPC = enable or disable reverse power control.
	\param iDiversity_Mode = enable or disable diversity mode.
	\param iNum_of_Carriers = the number of carriers, valid values are from 1 to 3,
	\param iRL_2_Channel = channel number of the 2nd RL carrier. Must follow MaxSeparation constraint. valid only when iNum_of_Carriers =2 or 3
	\param iRL_2_RRI_Payload = Reverse Rate Indicator Payload of the 2nd RL carrier. valid values are from 1 to 12. valid only only when iNum_of_Carriers =2 or 3
	\param iRL_3_Channel = channel number of the 3rd RL carrier. Must follow MaxSeparation constraint. valid only when iNum_of_Carriers =3
	\param iRL_3_RRI_Payload = Reverse Rate Indicator Payload of the 3rd RL carrier. valid values are from 1 to 12, valid only when iNum_of_Carriers =3
	\param iMax_Num_Attempt = the maximum allowed attempts to make an FTM non-signaling call.

	\return true if successful, false if fail.

	\warning Test equipment must be set to the desired band, channel and with MAC index= 63 before calling this command.
		Only the main forward link carrier at iCDMA_Freq is required to make a Rev. B call;
		All the reverse link measurements are supported with only one forward carrier.
		However, only the forward carriers that are physically present will report valid PER information.

		A failed return value (false) indicates phone fails to make an FTM non-signaling call.
		Make sure test equipment has been properly set to the desired band, channel,
		and it transmits a moderate forward link signal (e.g., -55 - -75 dBm).
		If the failure remains, a phone reset is recommended.

	\note The following sub-commands are called until a call is made, or the function reaches the maximum allowed number of attempts.
		The access channel and traffic channel will use default parameters.
		For a complete list of default parameters, see the subcommand respectively.
		\code
			//step 1: enable NS and clear status.
			QLIB_FTM_EVDO_NS_Start
			//step 2: make sure previous call is down
			QLIB_FTM_EVDO_CMD_RELEASE
			//step 3: acq pilot
			QLIB_FTM_EVDO_PILOT_ACQ
			//step 4: acq time
			QLIB_FTM_EVDO_SYS_TIME_ACQ
			//step 5: mod acc chan. //Rev. B re-uses same command as Rev. A for Access channel.
			QLIB_FTM_EVDO_REV_A_MOD_ACC
			//wait half second for phone to transmit at least 1 probe.
			Sleep(500);
			//step 6: mod RTC
			QLIB_FTM_EVDO_REV_B_MOD_RTC
		\endcode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_REV_B_START_CALL(
								HANDLE hResourceContext,
								unsigned long iBand_Class,
								unsigned short iCDMA_Freq,
								unsigned char iDRC_Value,
								unsigned char iRRI_Payload,
								unsigned char bEnableRPC,
								unsigned long iDiversity_Mode,
								unsigned char iNum_of_Carriers,
								unsigned short iRL2_Channel,
								unsigned char iRL2_RRI_Payload,
								unsigned short iRL3_Channel,
								unsigned char iRL3_RRI_Payload,
								unsigned short iMax_Num_Attempt);

	/******************************************************************************/
	/**
	EVDO Non-signaling command x.x.xx Handoff command

	This function performs hard-handoff in non-signalling

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iBand_Class = Indicates the band class. Possible values are in FTM_CDMA2000_BandClasstype in QLib_Defines.h

	\param iCDMA_Freq  = Indicates the RF channel number.

	\param iEnable_RPC = 1 to enable reverse link power control (RPC), 0 to disable RPC

	\return true if successful, false if fail.

	\warning This must be called only after a NS EVDO is called successfully

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_FWD_HHO_SC(
								HANDLE hResourceContext,
								unsigned long iBand_Class,
								unsigned short iCDMA_Freq,
								unsigned char iEnable_RPC );


	/******************************************************************************/
	/**
	EVDO Non-signaling command x.x.xx Set reverse link power

	This function overrides the reverse link power control with EVDO NS mode

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iPower_Type = 1 = enable (Override reverse link power with iRev_Pwr_indBm10)
						 0 = disabled (use power control bit if RPC is enabled)

	\param iRev_Pwr_indBm10  = Indicates the power level in 10/dBm units as signed number.
						 This field is used only when iPower_Type is set to FTM_1X_TX_POWER_TYPE_AGC_SETPOINT

						 For example, to set 24dBm, 240 should be used

	\return true if successful, false if fail.

	\warning This function should be called only a NS call has been established successfully

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_SET_REV_PWR(
								HANDLE hResourceContext,
								unsigned char iPower_Type,
								unsigned long iRev_Pwr_indBm10
								);

	/******************************************************************************/
	/**
	EVDO Non-signaling command x.x.xx Reset fowrward link PER statistics

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning This function should be called only a NS call has been established successfully

	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_EVDO_RESET_FWD_STAT( HANDLE hResourceContext);

	/******************************************************************************/
	/**
	Synchronous EVDO Non-signaling command x.x.xx Get fowrward link PER statistics

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iTotalPacket = Total packets since the counter set

	\param iTotalPacketError = Total number of error packets since last counter reset

	\param dPER = Packet Error Rate (iTotalPacketError/iTotalPacket*100)
				  999.0 is returned if the traget does not support the command

	\return true if successful, false if fail.

	\warning This function should be called only a NS call has been established successfully

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_GET_FWD_STAT( HANDLE hResourceContext, unsigned long* iTotalPacket, unsigned long* iTotalPacketError, double * dPER);
	/******************************************************************************/
	/**
	Synchronous EVDO Non-signaling command x.x.xx Get forward link power level

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iRxChain = 0 - Primary Rx
	                  1 - Secondary Rx

	\param iStatus = 0 - FTM_SUCCESS
	                 1 - FTM_INVALID_CMD
					 2 - FTM_INVALID_STATE
					 3 - FTM_NO_SUCCESS

    \param iRxAGC = Rx AGC value

	\param iRxPowerdBm = output value, Rx power in 1/10 dBm units
	                     this is a signed value

	\return true if successful, false if fail.

	\warning This function should be called only a NS call has been established successfully

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EVDO_RX_LEVEL_REQ(	HANDLE hResourceContext,
															unsigned char iRxChain,
															unsigned char* iStatus,
															short *iRxAGC,
															short *iRxPowerdBm);

/******************************************************************************
						FTM SV
*******************************************************************************/



/******************************************************************************
						Bluetooth FTM
*******************************************************************************/

	/******************************************************************************/
	/**
	Factory Test Mode Bluetooth Commands 1.2.1.1 User-specified HCI command

	Send a host controller interface (HCI) command to a device

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pBuffer = pointer to a series of bytes that will be sent as an HCI command.
	\param iLength = number of bytes to send, from pBuffer

	\return true if successful, false if fail.

	\warning QLIB_FTM_SET_MODE( PHONE_MODE_BLUETOOTH ) must be called first

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_HCI_USER_CMD
		( HANDLE hResourceContext, unsigned char* pBuffer, unsigned char iLength);

	/******************************************************************************/
	/**
	Factory Test Mode Bluetooth, custom command to activate Bluetooth mode

	Sends: 1) HCI Enable DUT, 2)HCI Write Scan Enable, 3) HCI Set Event Filter Conn 2

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param =pBuffer = pointer to a series of bytes that will be sent as an HCI command.
	\param iLength = number of bytes to send, from pBuffer

	\return true if successful, false if fail.

	\warning QLIB_FTM_SET_MODE( PHONE_MODE_BLUETOOTH ) must be called first

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_Enable_Bluetooth( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Factory Test Mode Bluetooth, custom command turn on BT transmitter to a specific channel number

	The underlying HCI command is a vendor-specific command called BT_HCI_TX_CONTINUOUS_FREQ.
	This does not actually produce a CW signal, rather a a DH5 packet is transmitted every 6 slots.
	The result is a bursted signal.  It is apparently not possible to transmit just a CW signal
	using the available HCI commands.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iChannel= channel number for Tx. (Tx frequency = 2402 + chan_num, in MHz)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_SetCW(  HANDLE hResourceContext, unsigned char iChannel );

	/******************************************************************************/
	/**
	Factory Test Mode Bluetooth, custom command turn on BT transmitter with a CW,
	to a specific channel number

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iAddr = 6 digit Bluetooth address.  This will temporarily load the BT address
	               into embedded RAM.  When modes are reset or the phone is restarted,
				   the address will be gone.

                   The address will be transformed as follows:
				   Input array: { 0x12, 0x90, 0x78, 0x56 0x34, 0x12 }

				   Resulting BT address: 123456789012


	\return true if successful, false if fail.

	\warning If the NV_BD_ADDR_I NV item has a value then the NV address will always
	         be used and the value specified in this command will be ignored.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_SetAddr(  HANDLE hResourceContext, unsigned char iAddr[6] );

	/******************************************************************************/
	/**

	This command issues a Bluetooth "Read_Local_Version_Information" HCI command to
	the Bluetooth module and then capture the resulting Bluetooth event log, which
	contains the Local_Version of the Bluetooth module.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pBluetootHCI_Version = reference to the structure that will be filled in with the local version information.
	                              use the type Bluetooth_LocalVersion_struct, defined in QLIB_Defines.h

	\return true if successful, false if fail.

	\warning Will reset the log code and logging state



	*******************************************************************************/
	QLIB_API unsigned char QLIB_BT_GetModuleVersion( HANDLE hResourceContext, unsigned char* pBluetootHCI_Version  );


	/******************************************************************************/
	/**

	This function sends BT HCI command and returns the first HCI event/response received

	Call QLIB_ConfigureTimeout( hResourceContext, QMSL_Timeout_BT_HCI_Response, TimeOut) to configure the timeout value for waiting for BT response

	See Test_FTM_BT() in QLibDemo.cpp on how to use this function

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pHCI_Buffer [in] = HCI command buffer

	\param iHCI_Length [in] = HCI command buffer length

	\param pBTResponseBuffer [in/out] = HCI response buffer

	\param iBTResponseLength [in/out] = [in] is the size of pBTResponseBuffer,
										[out] is the length of valid data returned by pBTResponseBuffer, 0 means that there is no BT response

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_HCI_USER_CMD_WithEventResponse( HANDLE hResourceContext, unsigned char* pHCI_Buffer, unsigned short iHCI_Length, unsigned char* pBTResponseBuffer, unsigned short* iBTResponseLength );
	/******************************************************************************/
	/**

	This function sends BT HCI command and returns the first and second HCI event/response received

	Call QLIB_ConfigureTimeout( hResourceContext, QMSL_Timeout_BT_HCI_Response, TimeOut) to configure the timeout value for waiting for BT response

	See Test_FTM_BT() in QLibDemo.cpp on how to use this function

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pHCI_Buffer [in] = HCI command buffer

	\param iHCI_Length [in] = HCI command buffer length

	\param pBTResponseBuffer [in/out] = HCI response buffer

	\param iBTResponseLength [in/out] = [in] is the size of pBTResponseBuffer,
										[out] is the length of valid data returned by pBTResponseBuffer, 0 means that there is no BT response

	\param pSecondBTResponseBuffer2 [in/out] = Second HCI response buffer

	\param iSecondBTResponseLength2 [in/out] = [in] is the size of pSecondBTResponseBuffer,
										[out] is the length of valid data returned by pSecondBTResponseBuffer, 0 means that there is no BT response

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_HCI_USER_CMD_WithTwoEventResponse( HANDLE hResourceContext, unsigned char* pHCI_Buffer, unsigned short iHCI_Length, unsigned char* pBTResponseBuffer, unsigned short* iBTResponseLength, unsigned char* pSecondBTResponseBuffer2, unsigned short* iSecondBTResponseLength );

	/******************************************************************************/
	/**

	This function sends BT HCI command and returns the first and second HCI event/response received

	Call QLIB_ConfigureTimeout( hResourceContext, QMSL_Timeout_BT_HCI_Response, TimeOut) to configure the timeout value for waiting for BT response

	See Test_FTM_BT() in QLibDemo.cpp on how to use this function

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pHCI_Buffer [in] = HCI command buffer

	\param iHCI_Length [in] = HCI command buffer length

	\param pBTResponseBuffer [in/out] = HCI response buffer

	\param iBTResponseLength [in/out] = [in] is the size of pBTResponseBuffer,
										[out] is the length of valid data returned by pBTResponseBuffer, 0 means that there is no BT response

	\param pSecondBTResponseBuffer2 [in/out] = Second HCI response buffer

	\param iSecondBTResponseLength2 [in/out] = [in] is the size of pSecondBTResponseBuffer,
										[out] is the length of valid data returned by pSecondBTResponseBuffer, 0 means that there is no BT response

	\param pThirdBTResponseBuffer3 [in/out] = Third HCI response buffer

	\param iThirdBTResponseLength3 [in/out] = [in] is the size of pThirdBTResponseBuffer,
										[out] is the length of valid data returned by pThirdBTResponseBuffer, 0 means that there is no BT response


	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_HCI_USER_CMD_WithThreeEventResponse( HANDLE hResourceContext, unsigned char* pHCI_Buffer, unsigned short iHCI_Length, unsigned char* pBTResponseBuffer, unsigned short* iBTResponseLength,unsigned char* pSecondBTResponseBuffer, unsigned short* iSecondBTResponseLength, unsigned char* pThirdBTResponseBuffer, unsigned short* iThirdBTResponseLength  );

	/******************************************************************************/
	/**

	This function disables the sleep feature of the BT device. Method should be called before calling QLIB_FTM_BT_PROD_TEST_SUBCOMMAND_TEST_TXC_ONLY.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_DisableSleep(HANDLE hResourceContext);

	/******************************************************************************/
	/**

	This function will reset the BT controller.  This method should be utilized to stop the continouse Transmit of the device.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_HCI_Reset(HANDLE hResourceContext);

	/******************************************************************************/
	/**

	This method provides user to be able to poke 32 bit value into the memory.  The method sends the "EDL_POKE32_REQ" command.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param memAddress [in] = memory location where the data will be written

	\param datalength [in] = number of bytes taht need to be written. number of bytes must be multiple of 4 and must be >=  4.

	\param data [in] = data that is going to be written into the memory.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_EDL_POKE32_REQ(HANDLE hResourceContext, unsigned long memAddress, unsigned char datalength, unsigned char *data);

	/******************************************************************************/
	/**

	This method provides user to be able to poke 16 bit value into the memory.  The method sends the "EDL_POKE16_REQ" command.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param memAddress [in] = memory location where the data will be written

	\param datalength [in] = number of bytes taht need to be written. number of bytes must be multiple of 2 and must be >=  2.

	\param data [in] = data that is going to be written into the memory.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_EDL_POKE16_REQ(HANDLE hResourceContext, unsigned long memAddress, unsigned char datalength, unsigned char *data);


	/******************************************************************************/
	/**

	This method provides user to be able to poke 8 bit value into the memory.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param memAddress [in] = memory location where the data will be written

	\param datalength [in] = number of bytes taht need to be written.

	\param data [in] = data that is going to be written into the memory.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_EDL_POKE8_REQ(HANDLE hResourceContext, unsigned long memAddress, unsigned char datalength, unsigned char *data);




	/******************************************************************************/
	/**

	This method provides user to be able to peek 32 bit value into the memory.  The method sends the "EDL_PEEK32_REQ" command.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param memAddress [in] = memory location for reading the content of memory

	\param datalength [in] = number of bytes taht need to be read from the memory. Number of bytes must be multiple of 4 and must be >=  4.

	\param data [out] = data that is going to be read from the memory.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_EDL_PEEK32_REQ(HANDLE hResourceContext, unsigned long memAddress, unsigned char dataLengthToBeRead, unsigned char *data);



	/******************************************************************************/
	/**

	This method retrieves accumulated test statistics on received packets and the number of errors in the packets received during the testing.
	The method sends the "VS_PROD_TEST_SUBCOMMAND_TEST_STATS" command to gather the statistics.
	The method returns the unsigned char *, but BlueTooth_Prod_Test_Channel_Stat structure should be utilized while casting the parameteres.
	See section 2.5.1.3 of document 80-VE132-7.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param memAddress [in] = memory location for reading the content of memory

	\param datalength [in] = number of bytes taht need to be read from the memory. Number of bytes must be multiple of 4 and must be >=  4.

	\param channel1Stats [out] = statistics for channel 1

	\param channel2Stats [out] = statistics for channel 2

	\param channel3Stats [out] = statistics for channel 3

	\param channel4Stats [out] = statistics for channel 4

	\param channel5Stats [out] = statistics for channel 5

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_PROD_TEST_SUBCOMMAND_TEST_STATS(HANDLE hResourceContext,
																		unsigned char *channel1Stats,
																		unsigned char *channel2Stats,
																		unsigned char *channel3Stats,
																		unsigned char *channel4Stats,
																		unsigned char *channel5Stats);

	/******************************************************************************/
	/**

	The method causes the device to transmit full Bluetooth packets while bursting, without
	being in a connection with another device.	The method accomplish this by sending the "VS_PROD_TEST_SUBCOMMAND_TEST_TX" command.
	See section 2.5.1.4 of document 80-VE132-7.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param hopChannels [in] = contains 5 channels the device hops over if limited hopping is available

	\param itransmitPattern [in] = defines the trasmit pattern.  this parameter maps to BlueTooth_TransmittPatternPayload.

	\param ipacketType [in] = defines the type of packet that will be transmitted. This parameter maps to BlueTooth_PacketType.

	\param idataWhiteningEnable [in] = TRUE will enable the whitening. FALSE will disable the whitening.

	\param itransitOutputPower [in] = determine the output power. It needs to be between 0-9.

	\param ireceiverHighGainEnable [in] = determine the receiver gain. TRUE enables high gain. FALSE enables low gain.

	\param itragetDeviceAddress [in] = 6 byte Master Bluetooth device address

	\param ipayloadLength [in] = payload length

	\param ilogicalTransportAddress [in] = logical transport address

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_PROD_TEST_SUBCOMMAND_TEST_TX(HANDLE hResourceContext,
																	unsigned char ihopChannels[5],
																	unsigned char itransmitPattern,
																	unsigned char ipacketType,
																	unsigned char idataWhiteningEnable,
																	unsigned char itransitOutputPower,
																	unsigned char ireceiverHighGainEnable,
																	unsigned char itragetDeviceAddress[6],
																	unsigned char ihoppingEnable,
																	unsigned short ipayloadLength,
																	unsigned char ilogicalTransportAddress);

	/******************************************************************************/
	/**

	The method sets the device into slave mode.  The device then specified frequency for the presence of a master device.
	Once the master device is found, the two devices transmit data.
	The method accomplish this by sending the "VS_PROD_TEST_SUBCOMMAND_TEST_SLAVE" command.
	See section 2.5.1.1 of document 80-VE132-7.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param hopChannels [in] = contains 5 channels the device hops over if limited hopping is available

	\param itransmitPattern [in] = defines the trasmit pattern.  this parameter maps to BlueTooth_TransmittPatternPayload.

	\param ipacketType [in] = defines the type of packet that will be transmitted. This parameter maps to BlueTooth_PacketType.

	\param idataWhiteningEnable [in] = TRUE will enable the whitening. FALSE will disable the whitening.

	\param itransitOutputPower [in] = determine the output power. It needs to be between 0-9.

	\param ireceiverHighGainEnable [in] = determine the receiver gain. TRUE enables high gain. FALSE enables low gain.

	\param itragetDeviceAddress [in] = 6 byte Master Bluetooth device address

	\param ipayloadLength [in] = payload length

	\param ilogicalTransportAddress [in] = logical transport address

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_PROD_TEST_SUBCOMMAND_TEST_SLAVE(HANDLE hResourceContext,
																		unsigned char  ihopChannels[5],
																		unsigned char  itransmitPattern,
																		unsigned char  ipacketType,
																		unsigned char  idataWhiteningEnable,
																		unsigned char  itransitOutputPower,
																		unsigned char  ireceiverHighGainEnable,
																		unsigned char  itragetDeviceAddress[6],
																		unsigned char  ihoppingEnable,
																		unsigned short ipayloadLength,
																		unsigned char  ilogicalTransportAddress);

	/******************************************************************************/
	/**

	The method causes the device to transmit continuously on the specified channel.
	The method accomplish this by sending the "VS_PROD_TEST_SUBCOMMAND_TEST_TXC_ONLY" command to the BT device.
	See section 2.5.1.5 of document 80-VE132-7.

	Note:
		In order to support 4020/4021/4025 and Marimba devices, following algorithm is been used.
			Method gets the unit app version by looking at the PF values (as per Bill Chens request).
			It is done by looking at the 4 bytes starting at 0x2A location of the event that was sent back.

			if power level less than or equal to 7 send the command as normal.  If the unit is 4025 then send a series of poke8 commands provided by the apps team.
			if power level is either 8 or 9 then take actions as described below.
				If unit 4025 send the Tx packet with Power level '7' in it and then send series of poke8 commands provided by Apps team.
				If unit is either 4020 / 4021 / 4000 then power level is set back to 7 and command is sent to the unit. (no Poke commands are sent)
				if some other unit is found (e.g .. Marimba), command is sent as is where the unit is expected to support power 8 and 9.



	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param ichannel [in] = device transmit channel

	\param itransmitOutputPower [in] = determine the output power. It needs to be between 0-9.

	\param itransmitType [in] = defines the trasmit type.  this parameter maps to BlueTooth_TransmitType.

	\param ipatternLength [in] = specifies the length of the repeated pattern

	\param ibitPattern [in] = bit pattern transmitted repeatdly

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_PROD_TEST_SUBCOMMAND_TEST_TXC_ONLY( HANDLE hResourceContext,
																		unsigned char ichannel,
																		unsigned char itransmitOutputPower,
																		unsigned char itransmitType,
																		unsigned char ipatternLength,
																		unsigned long ibitPattern);

	/******************************************************************************/
	/**

	The method causes the device to receive continuously on the specified channel to test receiving rates of device transmitting in production
	test mode.  The method accomplish this by sending the "VS_PROD_TEST_SUBCOMMAND_TEST_RX_ONLY" command to the BT device.
	See section 2.5.1.6 of document 80-VE132-7.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param hopChannels [in] = contains 5 channels the device hops over if limited hopping is available

	\param itransmitPattern [in] = defines the trasmit pattern.  this parameter maps to BlueTooth_TransmittPatternPayload.

	\param ipacketType [in] = defines the type of packet that will be transmitted. This parameter maps to BlueTooth_PacketType.

	\param idataWhiteningEnable [in] = TRUE will enable the whitening. FALSE will disable the whitening.

	\param itransitOutputPower [in] = determine the output power. It needs to be between 0-9.

	\param ireceiverHighGainEnable [in] = determine the receiver gain. TRUE enables high gain. FALSE enables low gain.

	\param itragetDeviceAddress [in] = 6 byte Master Bluetooth device address

	\param ipayloadLength [in] = payload length

	\param ilogicalTransportAddress [in] = logical transport address

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_BT_PROD_TEST_SUBCOMMAND_TEST_RX_ONLY( HANDLE hResourceContext,
																	unsigned char ihopChannels[5],
																	unsigned char ipacketType,
																	unsigned char idataWhiteningEnable,
																	unsigned char itransitOutputPower,
																	unsigned char ireceiverHighGainEnable,
																	unsigned char itragetDeviceAddress[6],
																	unsigned char ihoppingEnable,
																	unsigned short ipayloadLength,
																	unsigned char ilogicalTransportAddress);

/******************************************************************************
						Audio FTM
*******************************************************************************/
	/******************************************************************************/
	/**
	Factory Test Mode Audio, 2.4 Audio Set Path command

		The audio set path command activates a supported audio device in the phone. The audio device
		refers to the physical connection of a microphone/speaker or another audio input/output hardware
		to one of the vocoders PCM paths. Typical audio devices are handset, headset, and Bluetooth
		headset.

		NOTE Since some of the audio devices are featurized, not all audio devices are available on all
		platforms. If an audio path selected is not supported in the phone, the status field in the response
		packet is set to 2.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iAudioDevice - set the receive/transmit pair of audio devices

	\code
		0 = Handset
		1 = Handsfree kit
		2 = Mono headset
		3 = Stereo headset
		4 = Analog handsfree kit
		5 = Stereo DAC
		6 = Speaker phone
		7 = TTY Handsfree kit
		8 = TTY headset
		9 = TTY VCO
		10 = TTY HCO
		11 = Bluetooth intercom
		12 = Bluetooth headset
		13 = Bluetooth local audio
		14 = USB audio
		15 = SND_DEVICE_FM_RADIO_HEADSET
		16 = SND_DEVICE_FTM_HANDSET
		17 = SND_DEVICE_FTM_HEADSET
		18 = SND_DEVICE_FTM_SPEAKER
		19 = SND_DEVICE_FTM_CARKIT

	\endcode
		* The microphone and speaker used by each audio device varies between platforms. Refer
		to file msmaud.h for the mapping between audio devices and microphone/speaker pairs.


	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AUDIO_SET_PATH( HANDLE hResourceContext, unsigned short iAudioDevice );

	/******************************************************************************/
	/**
	Factory Test Mode Audio, 2.5 Audio Set Volume command
		The audio set volume command sets the RXvolume on the current audio path to the specified
		level (reference Figure 2-1). The volume steps are defined in arrays corresponding to the sound
		device and method in sndcal.c. Volume steps are from 0...4 (0 being mute and 4 being the
		loudest).

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iVolume - Volume steps from 0...4

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AUDIO_SET_VOLUME( HANDLE hResourceContext, unsigned char iVolume );


	/******************************************************************************/
	/**
	Factory Test Mode Audio, 2.6 Audio DSP Loopback command

		The DSP loopback command can be used to perform an audio loopback in the DSP. After this
		command is sent, audio samples from the microphone specified in the current audio path are
		routed to the corresponding speaker.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param bLoopbackOn - unsigned charean to switch DSP loopback on or off. 0 = Off, 1 = On

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AUDIO_DSP_LOOPBACK( HANDLE hResourceContext, unsigned char bLoopbackOn );

	/******************************************************************************/
	/**
	Factory Test Mode Audio, 2.7 Audio PCM Loopback command
		The PCM loopback command can be used to perform a PCM loopback in the codec. Once this
		command is sent, audio samples from the microphone specified in the current audio path are
		looped back in the codec to the corresponding speaker.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param bLoopbackOn  - unsigned charean to switch PCM loopback on or off. 0 = Off, 1 = On

	\code
	\endcode


	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AUDIO_PCM_LOOPBACK( HANDLE hResourceContext, unsigned char bLoopbackOn );

	/******************************************************************************/
	/**
	Factory Test Mode Audio, 2.8 Audio Tones Play command

		The tones play command can be used to play out tones in specified frequencies, using the speaker
		in the current audio path. The user can specify up to two frequencies, the higher one first.

		Only one frequency is desired, the iLoFreq parameter is set to 0

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iHiFreq - Higher of the two frequencies in Hz. The maximum frequency that can be specified is 3500 Hz
	\param iLoFreq - Lower of the two frequencies in Hz. The minimum, frequency that can be specified is 50 Hz
	\param iMethod - method to play the sound. FTM_Audio_Sound_Methods_Enum can be used for the
	                 basic values, but the specific audio features must be known to access methods beyond #3
		\code

          SND_METHOD_VOICE = 0,   // Use the device's voice generator

          // Application-Specific Methods

          SND_METHOD_KEY_BEEP = 1,// Use the device's keybeep generator
          SND_METHOD_MESSAGE = 2, // Use the path's ringer, or voice generator
          SND_METHOD_RING = 3,    // Use the device's ring generator
          #ifdef FEATURE_CLICK
             SND_METHOD_CLICK,       // Use the device's click generator
          #endif
          #if defined(FEATURE_AUDIO_FORMAT) || defined(FEATURE_MIDI_OUT)
            SND_METHOD_MIDI,        // Use the device's Midi generator
          #endif
            SND_METHOD_AUX,         // Use the device's auxiliary generator if avail.
            SND_METHOD_MAX          // Always last in the list

		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AUDIO_TONES_PLAY
		( HANDLE hResourceContext, unsigned short iHiFreq, unsigned short iLoFreq, unsigned short iMethod );

	/******************************************************************************/
	/**
	Factory Test Mode Audio, 2.9 Audio Tones Stop command
		The tones stop command stops the current tone that is being played.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AUDIO_TONES_STOP( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Factory Test Mode Audio, 2.10 Audio Noise Suppressor command
		The noise suppressor command can be used to turn the noise suppressor on or off.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iNoiseSuppressorOn - 0 = Off, 1 = On (the default state)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AUDIO_NS_CONTROL( HANDLE hResourceContext, unsigned char iNoiseSuppressorOn );


	/******************************************************************************/
	/**
	Factory Test Mode Audio,

		  Captures PCM data at 8kHz, with 16-bit samples.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iNumBuffers - Number of buffers to be captured.  Can be from 1 to 100.

	                     Each buffer is 160 samples, 1 sample = 16 bits.
						 100 buffers = 100 * 160 words = 100 * 160 * 2 byte = 32,000 bytes

	\param iDelay_ms - Number of milliseconds to wait between sending the command and receving
	                   a response packet.  This time increased as more buffers are captured.
					   The maximum value needed is 2000 for 2 seconds.

	\return true if successful, false if fail.

	\warning QLIB_FTM_AUDIO_PCM_STOP_CAPTURE must be called after the PCM data is transferred to the PC

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AUDIO_PCM_CAPTURE
		( HANDLE hResourceContext, unsigned short iNumBuffers, unsigned short iDelay_ms);

	/******************************************************************************/
	/**
	Factory Test Mode Audio,
		Releases the memory buffer held for the captured PCM data.
		Must be called after QLIB_FTM_AUDIO_PCM_CAPTURE.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AUDIO_PCM_STOP_CAPTURE( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Factory Test Mode Audio, 2.11 Get Audio PCM Capture Data
		This command is used to return the data from a PCM capture.  Data is
		separated into section of 512 bytes.  This command returns one section of the
		data last captured using the FTM_AUDIO_PCM_CAPTURE command


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iDataOffset - Offset in the PCM Capture buffer from which to return.
	\param iDataSize   - Number of bytes to transfer

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AUDIO_GET_PCM_CAPTURE_DATA
		( HANDLE hResourceContext, unsigned long iDataOffset, unsigned short iDataSize, unsigned char* pBuffer);

	/******************************************************************************/
	/**
	Factory Test Mode Audio

		This function calls the FTM_AUDIO_PCM_CAPTURE and FTM_AUDIO_GET_PCM_CAPTURE_DATA
		functions such that the PCM data will be captured and all of the data filled
		into the pBuffer storage area specified by the user.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iNumBuffers - Number of buffers to be captured.  Can be from 1 to 100.

	                     Each buffer is 160 samples, 1 sample = 16 bits.
						 100 buffers = 100 * 160 words = 100 * 160 * 2 byte = 32,000 bytes

	\param iDelay_ms - delay in milliseconds between the Send Request and the receive Response operations
	\param pBuffer = storage space for PCM data.  For buffer size, see comments for bCreateWAVformat

	\param iDataTransferSize - number of bytes to transfer for each time the
	                     FTM_AUDIO_GET_PCM_CAPTURE_DATA function is called.
						 This number should be a factor of the iDataSize number.
						 Only the value 512 will be tested for this parameter.

	\param bCreateWAVformat = Flag to indicate if the buffer should be stored in a WAV format.
	                          If set to 0, no action occurs.  If set to 1, the first 44 bytes of
							  the buffer will be filled in with a WAV header and the PCM data
							  will be stored after that.

	                          Note!  If this option is set to 1, then the user must specify
							  a buffer that is 44 bytes larger than the PCM data to be captured.

							  The WAV format is referenced from this web site:
							     http://ccrma.stanford.edu/courses/422/projects/WaveFormat/
	\code
       The WAV header is created as follows:
       // WAVE Header
       const dword c_iWAV_HeaderSize = 44;
       const byte c_iWAV_HeaderBuffer[ c_iWAV_HeaderSize ] =
       {
       0x52, 0x49, 0x46, 0x46, 0x3E, 0xA4, 0x00, 0x00, // 1-8
       0x57, 0x41, 0x56, 0x45, 0x66, 0x6D, 0x74, 0x20, // 9-16
       0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, // 17-24
       0x40, 0x1F, 0x00, 0x00, 0x80, 0x3E, 0x00, 0x00, // 25-32
       0x02, 0x00, 0x10, 0x00, 0x64, 0x61, 0x74, 0x61, // 33-40
       0x80, 0x3E, 0x00, 0x00                          // 41-44
       };
	\endcode


	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AUDIO_CapturePCMandTransferData
		(	HANDLE hResourceContext,
			unsigned short iNumBuffers,
			unsigned short iDelay_ms,
			unsigned char* pBuffer,
			unsigned short iDataTransferSize,
			unsigned char bCreateWAVformat
		);


	/******************************************************************************/
	/**
	Factory Test Mode Audio,
		Set the adjustment factor for CodecTxGain.
		The change will take effect immediately in the codec.

		The value still needs to be written to the NV item NV_CODECTXGAIN_ADJUST_I
		once the proper level is determined.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iCodecTxGainAdjust = adjustment value from -600 to +600, in 1/100dB steps

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AUDIO_SET_CODECTXGAIN_ADJUST( HANDLE hResourceContext, short iCodecTxGainAdjust );
	/******************************************************************************/
	/**
	Factory Test Mode Audio,

	The Audio Set path command activates an input and an output device pairing for the FTM DSP Loopback and Tone Play test.

	NOTE: This API is introduced in MSM7x30 chipset targets. It replaces the FTM_AUDIO_SET_PATH 5 audio command for targets
	that follow the MSM7x30 chipset. This API is not available for pre-MSM7x30 chipset targets.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iInputDevice = Available options (depends on actual product requirements)
							0  Handset Microphone (Mic1)
							1  Headset Microphone (Mic2)
							2  Digital Microphone 1
							3  Digital Microphone 2
							4  Digital Microphone 3
							5  Digital Microphone 4
							6  Aux In (analog)
							7  FM Input (L and R)
							8  LineIn Left
							9  LineIn Right
							10  Mic1 and AuxIn
							11  Mic1 and Mic2
							12  Digital Mic1 and Mic2
							13  Digital Mic3 and Mic4

	\param OutputDevice = Available options (depends on actual product requirements)

							0  Handset Earphone
							1  Headset Earphone Left
							2  Headset Mono Differential Output
							3  Headset Left & Right
							4  Speaker Phone 1 Left
							5  Speaker Phone 1 Left & Right
							6  Speaker Phone 2 Left
							7  Speaker Phone 2 Left & Right
							8  Lineout Left
							9  Lineout Differential Output
							10  Lineout Left & Right
							11  Aux Out
							12  FM Output (L& R)
							13  HDMI SD0
							14  HDMI SD1
							15  HDMI SD2
							16  HDMI SD3

	\param iStatus = Available options
					0  Success
					1  Command did not complete successfully
					2  Audio Path is not supported

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AUDIO_SET_PATH_INPUT_OUTPUT( HANDLE hResourceContext, unsigned short  iInputDevice, unsigned short iOutputDevice, unsigned short* iStatus);
	/******************************************************************************/
	/**
	Factory Test Mode Audio,

	The Enable PCM Recording command starts PCM audio recording. The audio data cannot exceed 100 buffers.

	Each buffer contains 160 samples. This API is intended for use with FTM_AUDIO_GET_PCM_SAMPLES.

	NOTE: This API is introduced in MSM7x30 chipset targets and will replace the
	FTM_AUDIO_SET_PATH audio command for targets after the M7x30 chipset.
	This API will not be available for pre-MSM7x30 chipset targets.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iNum_PCM_Buffers = Nummber of PCM buffers (frame)

	\param iRate = PCM Sampling Rate 8000/16000/48000

	\param iNum_Channels = Numer of channels,

	\param iSample_Width = 8/16/24/32

	\param iFrameSize = Typical frame size = 160 for 8k voice

	\param sFileName = e_file name to store recorded PCM data

					   If efile_name is empty, data is saved to memory instead;
					   FTM_AUDIO_GET_PCM_SAMPLES is sent to phone to get PCM data after this command;
					   else, if a valid path exists, PCM data is saved to e_file in Flash memory on phone;
					   FTM_AUDIO_GET_PCM_SAMPLES are not issued

					   The filename size should not exceed 50 bytes

	\param sFilePath = e_file location in phone, QRCT will prefix standard e-file root directory to path user selected

						The file path should not exceeed 128 bytes

	\param iStatus = Status
					 0 - Success
					 1 - Command did not complete successfully

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AUDIO_PCM_ENABLE_WITH_PARAMS( HANDLE hResourceContext, unsigned short iNum_PCM_Buffers, unsigned short iRate,  unsigned short iNum_Channels, unsigned short iSample_Width, unsigned short iFrameSize, char* sFileName, char* sFilePath, unsigned short* iStatus);

/******************************************************************************
						Camera FTM
*******************************************************************************/

	/******************************************************************************/
	/**
	Factory Test Mode Camera, 2.3.1 Camera Start
		This command starts the camera services. The power to the sensor is turned on and set to
		the power-up state for operation. The sensor and the device driver are initialized. Setting picture
		dimensions and taking pictures cannot happen until this command is executed.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iCameraStatus - Camera services status, returns code from calling camera services API:
	\code
       0 = CAMERA_SUCCESS
       1 = CAMERA_INVALID_STATE
       2 = CAMERA_INVALID_PARM
       3 = CAMERA_INVALID_FORMAT
       4 = CAMERA_NO_SENSOR
       5 = CAMERA_NO_MEMORY
       6 = CAMERA_NOT_SUPPORTED
       7 = CAMERA_FAILED
       8 = CAMERA_INVALID_STAND_ALONE_FORMAT
       9 = CAMERA_MALLOC_FAILED_STAND_ALONE
	\endcode


	\code
	This section of sample code taken from the QlibDemo.cpp program.  It demonstrates how to use the
	Camera API.  The assumption is that the QLIB communications with the phone have already been setup
	and the variable g_hResourceContext is a valid HANDLE.


	// Setup variables
	char _sPictureFileName[] = "C:\\FactoryTest.jpg";
	unsigned char	_bAutoPictureSize = true;	// Auto determine picture width
	unsigned short	_iPictureWidth = 0;			// not used because auto-
	unsigned short	_iPictureHeight = 0;
	unsigned short	_iDelay_ms = 2000;			// 2 seconds
	unsigned long	_iQuality = 99;				// % quality (0-99)
	unsigned short	_iFormat = CAMERA_JPEG;		// JPEG format
	unsigned long	_iPicDataSize = 0;			// Will get updated when picture is taken
	unsigned short	_iDataTransferSize = 512;	// Number of bytes transferred at a time
	void*	_piPicData = NULL;
	unsigned short	_iCameraStatus = CAMERA_SUCCESS;

	printf("\nTaking picture...");
	bOk = QLIB_FTM_CAMERA_PerformTakePictureSequence
			(
			g_hResourceContext,
			_bAutoPictureSize,
			_iPictureWidth,
			_iPictureHeight,
			_iDelay_ms,
			_iQuality,
			_iFormat,
			&_iPicDataSize,
			&_iCameraStatus
			);
	printf("\nQLIB_FTM_CAMERA_PerformTakePictureSequence = %s", bOk ? "PASS" : "FAIL");

	// Now transfer the picture into memory
	if (	( bOk )
		&&	(_iPicDataSize != 0 )
		)
	{

		// Allocate memory
		_piPicData = malloc( _iPicDataSize );

		if ( _piPicData != NULL )
		{
			printf("\nRetrieving picture (%d bytes)...", _iPicDataSize );

			bOk = QLIB_FTM_CAMERA_GetEntirePicture
					(
						g_hResourceContext,
						_iPicDataSize,
						_iDataTransferSize,
						(unsigned char*) _piPicData,
						&_iCameraStatus
					);

			printf("\nQLIB_FTM_CAMERA_GetEntirePicture = %s", bOk ? "PASS" : "FAIL");

			if (bOk)
			{
				// Select binary mode for the IO library
				_fmode = _O_BINARY;

				// Setup file pointer
				FILE* _hGraphicFile = NULL;

				// Now store this data into a file
				if (_hGraphicFile = fopen( _sPictureFileName,"w"))
				{
					// Write the data to a file
					fwrite( _piPicData, _iPicDataSize, 1, _hGraphicFile);
				}	// fopen()

				// Close the file
				if (_hGraphicFile != NULL )
					fclose( _hGraphicFile );

			}	// if (bOk)

		}	// if ( _piPicData != NULL )

		// Close the Camera Service
		bOk = QLIB_FTM_CAMERA_STOP( g_hResourceContext,  &_iCameraStatus );

		// Free th memory
		free( _piPicData);

	}	// if ( bOk ... )


	\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CAMERA_START( HANDLE hResourceContext, unsigned short* piCameraStatus );

	/******************************************************************************/
	/**
	Factory Test Mode Camera, 2.3.2 Camera Stop
		This command terminates the camera services. The power sensor is turned off. This command
		also de-allocates the memory heap allocated for picture storage.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iCameraStatus - Camera services status, returns code from calling camera services API:
	\code
       0 = CAMERA_SUCCESS
       1 = CAMERA_INVALID_STATE
       2 = CAMERA_INVALID_PARM
       3 = CAMERA_INVALID_FORMAT
       4 = CAMERA_NO_SENSOR
       5 = CAMERA_NO_MEMORY
       6 = CAMERA_NOT_SUPPORTED
       7 = CAMERA_FAILED
       8 = CAMERA_INVALID_STAND_ALONE_FORMAT
       9 = CAMERA_MALLOC_FAILED_STAND_ALONE
	\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CAMERA_STOP( HANDLE hResourceContext, unsigned short* piCameraStatus );

	/******************************************************************************/
	/**
	Factory Test Mode Camera, 2.3.3 Camera Set Parm
		This command sets the operational parameters of the camera sensor. For a list of possible
		parameter identifiers, refer to the Camera Services Interface Specification and Operational
		Description (80-V5310-1).


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param	iParmId = Camera parameter identifier.  Refer to 80-V5310-1 for definitions of parameter identifiers.
	\code
        0 = CAMERA_PARM_STATE (Read Only)
        1 = CAMERA_PARM_ACTIVE_CMD (Read Only)
        2 = CAMERA_PARM_ZOOM
        3 = CAMERA_PARM_ENCODE_ROTATION
        4 = CAMERA_PARM_SENSOR_POSITION
        5 = CAMERA_PARM_CONTRAST
        6 = CAMERA_PARM_BRIGHTNESS
        7 = CAMERA_PARM_SHARPNESS
        8 = CAMERA_PARM_EXPOSURE
        9 = CAMERA_PARM_WB
        10 = CAMERA_PARM_EFFECT
        11 = CAMERA_PARM_AUDIO_FMT
        12 = CAMERA_PARM_FPS
        13 = CAMERA_PARM_FLASH
        14 = CAMERA_PARM_RED_EYE_REDUCTION
        15 = CAMERA_PARM_NIGHTSHOT_MODE
        16 = CAMERA_PARM_REFLECT
        17 = CAMERA_PARM_PREVIEW_MODE
        18 = CAMERA_PARM_ANTIBANDING
        19 = CAMERA_PARM_THUMBNAIL_WIDTH
        20 = CAMERA_PARM_THUMBNAIL_HEIGHT
        21 = CAMERA_PARM_THUMBNAIL_QUALITY
	\endcode
	\param	iParmValue = This is the camera parameter value.
	                     Refer 80-V5310-1 for specific definitions for each parameter identifiers.

	\param  iCameraStatus - Camera services status, returns code from calling camera services API:
	\code
       0 = CAMERA_SUCCESS
       1 = CAMERA_INVALID_STATE
       2 = CAMERA_INVALID_PARM
       3 = CAMERA_INVALID_FORMAT
       4 = CAMERA_NO_SENSOR
       5 = CAMERA_NO_MEMORY
       6 = CAMERA_NOT_SUPPORTED
       7 = CAMERA_FAILED
       8 = CAMERA_INVALID_STAND_ALONE_FORMAT
       9 = CAMERA_MALLOC_FAILED_STAND_ALONE
	\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CAMERA_SET_PARM
		(
			HANDLE hResourceContext,
			unsigned short iParmId,
			unsigned long iParmValue,
			unsigned short* piCameraStatus
		);

	/******************************************************************************/
	/**
	Factory Test Mode Camera, 2.3.4 Camera Set Dimensions
		This command sets the picture dimensions. The picture width is the horizontal width of the
		picture in number of pixels and the picture height is the vertical height of the picture in number of
		lines. The Camera Start command must be executed before using this command. Refer to Chapter
		3 for recommended picture resolutions.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iPictureWidth - This is the horizontal width of the picture in number of pixels.
	\param iPictureHeight- This is the Vertical height of the picture in number of pixels.
	\param  iCameraStatus - Camera services status, returns code from calling camera services API:
	\code
       0 = CAMERA_SUCCESS
       1 = CAMERA_INVALID_STATE
       2 = CAMERA_INVALID_PARM
       3 = CAMERA_INVALID_FORMAT
       4 = CAMERA_NO_SENSOR
       5 = CAMERA_NO_MEMORY
       6 = CAMERA_NOT_SUPPORTED
       7 = CAMERA_FAILED
       8 = CAMERA_INVALID_STAND_ALONE_FORMAT
       9 = CAMERA_MALLOC_FAILED_STAND_ALONE
	\endcode
	\param iLCD_Width = # of pixel on the X axis of the LCD

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CAMERA_SET_DIMENSIONS
		(
			HANDLE hResourceContext,
			unsigned short iPictureWidth,
			unsigned short iPictureHeight,
			unsigned short iLCD_Width,
			unsigned short* piCameraStatus
		);

	/******************************************************************************/
	/**
	Factory Test Mode Camera, 2.3.5 Camera Start Preview
		This command enters the preview state of camera services. This command must be executed each
		time the Camera Start or the Camera Set Dimensions command is called.
		NOTE A two second delay is recommended between Camera Start Preview and Camera Stop Preview
		commands in order for white balance and exposure to take effect. There is no software feedback
		mechanism indicating these parameters are ready; two seconds is a reasonable time for the human
		eye, which is the only method to verify this.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iCameraStatus - Camera services status, returns code from calling camera services API:
	\code
       0 = CAMERA_SUCCESS
       1 = CAMERA_INVALID_STATE
       2 = CAMERA_INVALID_PARM
       3 = CAMERA_INVALID_FORMAT
       4 = CAMERA_NO_SENSOR
       5 = CAMERA_NO_MEMORY
       6 = CAMERA_NOT_SUPPORTED
       7 = CAMERA_FAILED
       8 = CAMERA_INVALID_STAND_ALONE_FORMAT
       9 = CAMERA_MALLOC_FAILED_STAND_ALONE
	\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CAMERA_START_PREVIEW( HANDLE hResourceContext, unsigned short* piCameraStatus );

	/******************************************************************************/
	/**
	Factory Test Mode Camera, 2.3.6 Camera Stop Preview
		This command exits the preview state of camera services. This command must be executed after
		Camera Start Preview command and before a picture is taken.
		NOTE A two second delay is recommended between Camera Start Preview and Camera Stop Preview
		commands in order for white balance and exposure to take effect. There is no software feedback
		mechanism indicating these parameters are ready; two seconds is a reasonable time for the human
		eye, which is the only method to verify this.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iCameraStatus - Camera services status, returns code from calling camera services API:
	\code
       0 = CAMERA_SUCCESS
       1 = CAMERA_INVALID_STATE
       2 = CAMERA_INVALID_PARM
       3 = CAMERA_INVALID_FORMAT
       4 = CAMERA_NO_SENSOR
       5 = CAMERA_NO_MEMORY
       6 = CAMERA_NOT_SUPPORTED
       7 = CAMERA_FAILED
       8 = CAMERA_INVALID_STAND_ALONE_FORMAT
       9 = CAMERA_MALLOC_FAILED_STAND_ALONE
	\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CAMERA_STOP_PREVIEW( HANDLE hResourceContext, unsigned short* piCameraStatus );

	/******************************************************************************/
	/**
	Factory Test Mode Camera, 2.3.7 Camera Take Picture and Encode

		This command takes the picture, encodes the picture, and saves it in the phones allocated
		memory heap. The format of the picture can be either raw or JPEG-encoded data stored in the
		allocated memory buffer. Memory heap is allocated when this command is executed. Refer to
		Appendix A for details on how the allocated memory buffer or memory length is calculated.
		The compression ratio or quality factor is selected, and it impacts the output file size. A quality
		factor from 1 to 99 can be selected, with 1 as the lowest quality and 99 as the highest quality. In
		addition, the compression ratio is only used for JPEG-encoded format (not with the raw format).

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param	iQuality - This is the compression ratio or quality factor (valid range of [1:99],
	                   with 1 as the lowest quality and 99 as the highest quality).
	\param iFormat   - Format of picture data:
	\code
               0 = CAMERA_RAW
               1 = CAMERA_JPEG
	\endcode

	\param piPicDataSize = This is the size of the entire picture in bytes.

	\param  iCameraStatus - Camera services status, returns code from calling camera services API:
	\code
       0 = CAMERA_SUCCESS
       1 = CAMERA_INVALID_STATE
       2 = CAMERA_INVALID_PARM
       3 = CAMERA_INVALID_FORMAT
       4 = CAMERA_NO_SENSOR
       5 = CAMERA_NO_MEMORY
       6 = CAMERA_NOT_SUPPORTED
       7 = CAMERA_FAILED
       8 = CAMERA_INVALID_STAND_ALONE_FORMAT
       9 = CAMERA_MALLOC_FAILED_STAND_ALONE
	\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CAMERA_TAKE_PICTURE_AND_ENCODE
		(
			HANDLE hResourceContext, unsigned long iQuality, unsigned short iFormat,
			unsigned long* piPicDataSize, unsigned short* piCameraStatus
		);

	/******************************************************************************/
	/**
	Factory Test Mode Camera, 2.3.8 Camera Get Picture
		This command retrieves raw or JPEG-encoded picture data from the allocated memory space
		used in the Camera Take Picture and Encode command, based on a data offset and size. Given the
		data offset and size, this command will need to be executed a number of times until all picture
		data is retrieved.
		The recommended size to retrieve at one time is 512 bytes. The picture data format is based on
		the format parameter configured in the Camera Take Picture and Encode command.
		NOTE When retrieving the picture data, the picture will not be displayed on the phones LCD.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iDataOffset - The DATA_OFFSET is the offset in which to start retrieving picture data from memory.
	\param iDataSize - The size of picture data in bytes to retrieve from memory during this transaction.
	\param piPicData - The actual picture data is returned into this buffer, the number of bytes is DATA_SIZE.

	\param  iCameraStatus - Camera services status, returns code from calling camera services API:
	\code
       0 = CAMERA_SUCCESS
       1 = CAMERA_INVALID_STATE
       2 = CAMERA_INVALID_PARM
       3 = CAMERA_INVALID_FORMAT
       4 = CAMERA_NO_SENSOR
       5 = CAMERA_NO_MEMORY
       6 = CAMERA_NOT_SUPPORTED
       7 = CAMERA_FAILED
       8 = CAMERA_INVALID_STAND_ALONE_FORMAT
       9 = CAMERA_MALLOC_FAILED_STAND_ALONE
	\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CAMERA_GET_PICTURE
		(
			HANDLE hResourceContext, unsigned long iDataOffset, unsigned short iDataSize,
			unsigned char* piPicData, unsigned short* piCameraStatus
		);

	/******************************************************************************/
	/**
	Factory Test Mode Camera, 2.3.9 Camera Get Parm
		This command retrieves the operational parameters of the camera sensor. For a list of possible
		parameter identifiers, refer to Camera Services Interface Specification and Operational
		Description (80-V5310-1).

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iParmID - Camera parameter identifier. Refer to 80-V5310-1 for definitions of parameter identifiers.
	\code
        0 = CAMERA_PARM_STATE (Read Only)
        1 = CAMERA_PARM_ACTIVE_CMD (Read Only)
        2 = CAMERA_PARM_ZOOM
        3 = CAMERA_PARM_ENCODE_ROTATION
        4 = CAMERA_PARM_SENSOR_POSITION
        5 = CAMERA_PARM_CONTRAST
        6 = CAMERA_PARM_BRIGHTNESS
        7 = CAMERA_PARM_SHARPNESS
        8 = CAMERA_PARM_EXPOSURE
        9 = CAMERA_PARM_WB
        10 = CAMERA_PARM_EFFECT
        11 = CAMERA_PARM_AUDIO_FMT
        12 = CAMERA_PARM_FPS
        13 = CAMERA_PARM_FLASH
        14 = CAMERA_PARM_RED_EYE_REDUCTION
        15 = CAMERA_PARM_NIGHTSHOT_MODE
        16 = CAMERA_PARM_REFLECT
        17 = CAMERA_PARM_PREVIEW_MODE
        18 = CAMERA_PARM_ANTIBANDING
        19 = CAMERA_PARM_THUMBNAIL_WIDTH
        20 = CAMERA_PARM_THUMBNAIL_HEIGHT
        21 = CAMERA_PARM_THUMBNAIL_QUALITY
	\endcode


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piMinimumValue - Returns the minimum value of the operational parameter.
	\param piMaximumValue - Returns the maximum value of the operational parameter.
	\param piStepValue    - Returns the step value of the operational parameter.
	\param piDefaultValue - Returns the default value of the operational parameter.
	\param piCurrentValue - Returns the current value of the operational parameter.

	\param  piCameraStatus - Camera services status, returns code from calling camera services API:
	\code
       0 = CAMERA_SUCCESS
       1 = CAMERA_INVALID_STATE
       2 = CAMERA_INVALID_PARM
       3 = CAMERA_INVALID_FORMAT
       4 = CAMERA_NO_SENSOR
       5 = CAMERA_NO_MEMORY
       6 = CAMERA_NOT_SUPPORTED
       7 = CAMERA_FAILED
       8 = CAMERA_INVALID_STAND_ALONE_FORMAT
       9 = CAMERA_MALLOC_FAILED_STAND_ALONE
	\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CAMERA_GET_PARM
		(
			HANDLE hResourceContext, unsigned short iParmId, unsigned long* piMinimumValue,
			unsigned long* piMaximumValue, unsigned long* piStepValue, unsigned long* piDefaultValue,
			unsigned long* piCurrentValue, unsigned short* piCameraStatus
		);

	/******************************************************************************/
	/**
	Factory Test Mode Camera, 2.3.10 Camera Get Info
		This command retreives camera information such as the sensor width, height, rotation and
		orientation. Refer to Chapter 3 for possible sensor resolutions.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piSensorWidth  - Returns the sensor width.
	\param piSensorHeight - Returns the sensor height.
	\param piFPS          - Returns the frames per second.
	\param piSensorRotationSensing  - Returns whether the sensor can sense when it is rotated (0 = not rotated, 1=Rotated)
	\param piDefaultRotation        - Returns the default rotation value when the sensor is not rotated.
	\param piDefaultOrientation     - Returns orientation (landscape or portrait):
	\code
        0 = CAMERA_ORIENTATION_LANDSCAPE
        1 = CAMERA_ORIENTATION_PORTRAIT
	\endcode

	\param  iCameraStatus - Camera services status, returns code from calling camera services API:
	\code
       0 = CAMERA_SUCCESS
       1 = CAMERA_INVALID_STATE
       2 = CAMERA_INVALID_PARM
       3 = CAMERA_INVALID_FORMAT
       4 = CAMERA_NO_SENSOR
       5 = CAMERA_NO_MEMORY
       6 = CAMERA_NOT_SUPPORTED
       7 = CAMERA_FAILED
       8 = CAMERA_INVALID_STAND_ALONE_FORMAT
       9 = CAMERA_MALLOC_FAILED_STAND_ALONE
	\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CAMERA_GET_INFO
			(	HANDLE hResourceContext,
				unsigned short* piSensorWidth, unsigned short* piSensorHeight,
				unsigned short* piFPS, unsigned char* piSensorRotationSensing,
				unsigned short* piDefaultRotation,  unsigned short* piDefaultOrientation,
				unsigned short* piCameraStatus
			);

	/******************************************************************************/
	/**
	Factory Test Mode Camera, Select camera sensor
		This command selects which camera sensor will be used for subsequent calls
		to the FTM Camera API.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSensorID  - Sensor number to select.  The sensor number is the same ID number used
	                    in the embedded source code, specifically to the call to
						camera_select_sensor().  If you are unsure of the sensor ID, then ask
						the embedded developers.

	\param  iCameraStatus - Camera services status, returns code from calling camera services API:
	\code
       0 = CAMERA_SUCCESS
       1 = CAMERA_INVALID_STATE
       2 = CAMERA_INVALID_PARM
       3 = CAMERA_INVALID_FORMAT
       4 = CAMERA_NO_SENSOR
       5 = CAMERA_NO_MEMORY
       6 = CAMERA_NOT_SUPPORTED
       7 = CAMERA_FAILED
       8 = CAMERA_INVALID_STAND_ALONE_FORMAT
       9 = CAMERA_MALLOC_FAILED_STAND_ALONE
	\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CAMERA_SET_SENSOR_ID
			(	HANDLE hResourceContext,
				unsigned char iSensorID,
				unsigned short* piCameraStatus
			);

	/******************************************************************************/
	/**
	Factory Test Mode Camera, FTM_CAMERA_PerformTakePictureSequencePicture

		This command will sequence several steps in the FTM Camera API to take a picture.
		After this command is issued, the FTM_CAMERA_GetEntirePicture() can be called to return
		the picture data to the PC memory.

		The steps taken are documented in Section A.1 in the FTM Camera API document:
			1) FTM_START_CAMERA
			2) FTM_CAMERA_SET_PARM(  CAMERA_PARM_PREVIEW_MODE, CAMERA_PREVIEW_MODE_SNAPSHOT )
			3) FTM_CAMERA_SET_DIMENSIONS( x, y)
			4) FTM_CAMERA_START_PREVIEW()
			5) Delay delay_ms
			6) FTM_CAMERA_STOP_PREVIEW()
			7) image_size = FTM_CAMERA_TAKE_PICTURE_AND_ENCODE( quality, format )
			8) Return image_size


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param bAudioPictureWidth - 1=Determine picture dimentions automatically, by using the largest size possible
	                            for the installed sensor.  If this value == 1, then the iPictureWidth and iPictureHeight
								values are ignored.

	                            0=Use the dimensions specified in iPictureWidth and iPictureHeight
	\param iPictureWidth - This is the horizontal width of the picture in number of pixels.
	\param iPictureHeight- This is the Vertical height of the picture in number of pixels.
	\param iDelay_ms - delay in milliseconds between the Send Request and the Receive Response operations
	\param	iQuality - This is the compression ratio or quality factor (valid range of [1:99],
	                   with 1 as the lowest quality and 99 as the highest quality).
	\param iFormat   - Format of picture data:
	\code
               0 = CAMERA_RAW
               1 = CAMERA_JPEG
	\endcode

	\param piPicDataSize = This is the size of the entire picture in bytes.

	\param  iCameraStatus - Camera services status, returns code from calling camera services API:
	\code
       0 = CAMERA_SUCCESS
       1 = CAMERA_INVALID_STATE
       2 = CAMERA_INVALID_PARM
       3 = CAMERA_INVALID_FORMAT
       4 = CAMERA_NO_SENSOR
       5 = CAMERA_NO_MEMORY
       6 = CAMERA_NOT_SUPPORTED
       7 = CAMERA_FAILED
       8 = CAMERA_INVALID_STAND_ALONE_FORMAT
       9 = CAMERA_MALLOC_FAILED_STAND_ALONE
	\endcode

	\return true if successful, false if fail.

	\warning FTM_STOP_CAMERA() must be called after this function is called.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CAMERA_PerformTakePictureSequence
		(
		HANDLE hResourceContext,
		unsigned char bAutoPictureSize, unsigned short iPictureWidth, unsigned short iPictureHeight,
		unsigned short iDelay_ms, unsigned long iQuality, unsigned short iFormat,
		unsigned long* piPicDataSize, unsigned short* piCameraStatus
		);

	/******************************************************************************/
	/**
	Factory Test Mode Camera, FTM_CAMERA_GetEntirePicture

		This function calls the FTM_CAMERA_GET_PICTURE funciton as many times as
		necessary to return the entire picture from the phone to the PC.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iDataSize - The size of picture data in bytes to retrieve from memory during per transaction.
	\param piPicData - The actual picture data is returned into this buffer, the number of bytes is DATA_SIZE.

	\param  iCameraStatus - Camera services status, returns code from calling camera services API:
	\code
       0 = CAMERA_SUCCESS
       1 = CAMERA_INVALID_STATE
       2 = CAMERA_INVALID_PARM
       3 = CAMERA_INVALID_FORMAT
       4 = CAMERA_NO_SENSOR
       5 = CAMERA_NO_MEMORY
       6 = CAMERA_NOT_SUPPORTED
       7 = CAMERA_FAILED
       8 = CAMERA_INVALID_STAND_ALONE_FORMAT
       9 = CAMERA_MALLOC_FAILED_STAND_ALONE
	\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_CAMERA_GetEntirePicture
		(
			HANDLE hResourceContext, unsigned long iPicDataSize, unsigned short iDataTransferSize,
			unsigned char* piPicData, unsigned short* piCameraStatus
		);


/******************************************************************************
						FTM Log
*******************************************************************************/
	/******************************************************************************/
	/**
	FTM Log, 3.1 FTM enable log

		FTM log packets are enabled with the FTM_LOG_ENABLE request. The parameters to this
		request are the ID of the FTM log to enable, the periodicity of log packet generation, and the
		number of readings to be included in each log packet. To reduce log bandwidth, several readings
		can be buffered into a single log packet and sent as a single burst.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iLogCode - FTM Log packet number
	\param iInterval - Time (in ms) between subsequent log packets
	\param iNumBuffers - Number of buffers per log packet

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LOG_ENABLE(
		HANDLE hResourceContext, unsigned short iLogCode, unsigned long iInterval, unsigned long iNumBuffers  );


	/******************************************************************************/
	/**
	FTM Log, 3.2 FTM disable log
		An FTM log is disabled with the FTM_LOG_DISABLE command.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iLogCode - FTM Log packet number

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LOG_DISABLE( HANDLE hResourceContext, unsigned short iLogCode );

	/******************************************************************************/
	/**
	High level function to activate logging for a specific FTM2 log.  This function
	also turns on QMSL logging and sets up the phone's log filter to allow
	the FTM2 log to be generated.

	The operations called are:
		QLIB_FTM_LOG_ENABLE
		QLIB_DIAG_SetExtendedLogCode
		QLIB_DIAG_SetPhoneLoggingState
		QLIB_DIAG_ClearPhoneLogQueue

	\param iFTM_LogCode = FTM Log code, such as LOG_FTM2_LOG_WCDMA_BER or LOG_FTM2_LOG_PRINTF

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LOG_StartFTM_Log( HANDLE hResourceContext, unsigned short iFTM_LogCode);

	/******************************************************************************/
	/**
	High level function to set the number of buffers to be used for all FTM LOG ENABLE
	operations which call QLIB_FTM_LOG_StartFTM_Log().  This includes:
	\code
        QLIB_FTM_CDMA2000_NS_Start()
        QLIB_FTM_EVDO_NS_Start()
        QLIB_FTM_WCDMA_BER_StartSession()
        QLIB_FTM_GSM_BER_StartSession()
	\endcode

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iNumBuffersPerLog = Number of buffers per log packet

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LOG_SetFTM_LogBufferCount( HANDLE hResourceContext, unsigned long iNumBuffersPerLog );

	/******************************************************************************/
	/**
	High level function to disable logging for a specific FTM2 log.  This function
	also turns off QMSL logging.

	The operations called are:
		FTM_LOG_DISABLE
		DIAG_SetPhoneLoggingState
		DIAG_ClearPhoneLogQueue

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iFTM_LogCode = FTM Log code, such as LOG_FTM2_LOG_WCDMA_BER or LOG_FTM2_LOG_PRINTF

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LOG_StopFTM_Log( HANDLE hResourceContext, unsigned short iFTM_LogCode);

	/******************************************************************************/
	/**
	High level function to return the most recently received log report, or if no report
	is in the async queue, then the function will wait up-to a specified amount of time
	for a report to be received.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iFTM_LogCode = FTM Log code, such as LOG_FTM2_LOG_WCDMA_BER or LOG_FTM2_LOG_PRINTF
	\param pFTM2LogMessage = pointer to a structure of FTM2LogMessage type (defined in QLib_Defines.h).
	       If a lot message is found, the FTM2-specific section will be copied into this
		   structure.
	\param piLogSize = number of bytes copied into the pFTM2LogMessage structure

	\param iTimeOut_ms = millisecond time-out. If not log code is detected by the time this
	                     expires, then the return value will be false.


	\return true if a log was found, false if one was not found.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LOG_WaitForNextLog(
					HANDLE hResourceContext,
					unsigned short iFTM_LogCode,
					void* pFTM2LogMessage,
					unsigned short* piLogSize,
					unsigned long iTimeOut_ms );



/******************************************************************************
						WCDMA BER FTM
*******************************************************************************/

	/******************************************************************************/
	/**
	WCDMA BER, Start a WCDMA BER session. After this function is called, the acquisition
	function will need to be called, FTM_WCDMA_BER_Acquire.

		This function calls these operations and checks for errors:
			QLIB_FTM_WCDMA_BER_ClearStatus

		These low-level FTM operations are called and the associated events are verifed:
			START_WCDMA_MODE_REQ

		If the first START_WCDMA_MODE_REQ call fails, because a physical channel is
		already setup, then the function will call STOP_WCDMA_MODE_REQ and try to
		re-start the WCDMA non-signaling session.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iTimeOut_ms = millisecond timeout for all WCDMA BER operations.  This should
						 be long enough that all operations will return the desired
						 events before the timeout is complete.

						 If the command response events occur before the timeout is
						 complete then the program flow will continue immediately, so there
						 is no penalty for having a long time-out, unless an error occurs.

						 FTM_NONSIG_DEFAULT_TIMEOUT to use the system's default timeout.

						 Will only be updated when a session is being intilalized.

	\return true if network session is setup successful, false if there are any failures

	\warning The active log mask will be changed to log only log FTM2 log packets.
	         When the function is completed, the state of ASYNC logging will be enabled.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_StartSession(	HANDLE hResourceContext, unsigned long iTimeOut_ms );

	/******************************************************************************/
	/**
	WCDMA BER, acquire a downlink pilot.  Before this function is called,
	FTM_WCDMA_BER_StartSession must be called.  When the function is completed, the
	phone will be in the IDLE state.


	These low-level FTM operations are called and the associated events are verifed:
		ACQUIRE_REQ

		START_WCDMA_IDLE_REQ - will be called if any RMC channels have been setup sinc
		the last time that ACQUIRE_REQ has been called.

	This function will automatically retry the downlink acquisition up to 5 times, for the
	very first acquisition after the QLIB_FTM_WCDMA_BER_StartSession() is called.
	This is necessary because there are some layer 1 reasons why the first acquisition
	may not be successful immediately. In testing of 1000 attempts, it was to not
	explicitly issue an WCDMA_BER_IDLE command because this command is not necessary.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iChannel = WCDMA RF channel

	\return true if network session is setup successful, false if there are any failures

	\warning Default values are used for the following:
		\code
          iAcqType = FTM_WCDMA_BER_AcqTypeFreqOnly
          iAcqMode = FTM_WCDMA_BER_AcqModeFull
          iScrCode = 0
          iPN_Pos  = 0
		\endcode

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_AcquirePilot( HANDLE hResourceContext, unsigned short iChannel );

	/******************************************************************************/
	/**
	WCDMA BER, go to IDLE mode.

		This function calls these operations and checks for errors:
			FTM_WCDMA_START_IDLE_MODE_REQ

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if idle mode has been entered successfully, false if there are any failures

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_Idle( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	WCDMA BER, Setup a RMC DCH channel.  This must be done after the
	FTM_WCDMA_BER_AcquirePilot function has completed successfully.

		This low-level FTM operation is called and the associated event is verifed:
			RMC_DCH_SETUP_REQ

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRMC_Type (refer to FTM_WCDMA_BER_RMC_Type_Enum)
		\code
			FTM_WCDMA_BER_RMC_Type12_2kpbs				= 0,	//<!' RMC 12.2 kbps channel
			FTM_WCDMA_BER_RMC_Type64kbps				= 1,	//<!' RMC 64 kbps channel
			FTM_WCDMA_BER_RMC_Type384kpbs				= 2,	//<!' RMC 384 kbps channe (Not currently supported)
			FTM_WCDMA_BER_RMC_Type12_2kpbs_Symmetric	= 3,	//<!' RMC 12.2 kbps channel, block size in the DL and UL is the same
			FTM_WCDMA_BER_RMC_Type64kbps_Symmetric		= 4,	//<!' RMC 64 kbps channel, block size in the DL and UL is the same
			FTM_WCDMA_BER_RMC_Type384kbps_Symmetric		= 5		//<!' RMC 384 kbps channel, block size in the DL and UL is the same
			Note: For first 3 data rate enumeration, UL CRC bits are looped back from DL
			Note: For last  3 data rate enumeration, UL CRC is valid and computed based on Rx data bits
		\endcode
	\param iUL_MaxTxPwr = Maximum transmit power in dBm.

	\param iUL_DPCH_ScrCode = Scrambling code to use for the uplink.
	\param iUL_PCA (refer FTM_WCDMA_BER_PCA_Size_Enum)
		\code
          FTM_WCDMA_BER_PCA_Type_Alg1 = 0 = Power control algorithm 1
          FTM_WCDMA_BER_PCA_Type_Alg2 = 1 = Power control algorithm 2
		\endcode
	\param iUL_TPC_StepSize
		\code
         FTM_WCDMA_BER_PCA_Size_1dB = 0 = Stepsize 1 dB
         FTM_WCDMA_BER_PCA_Size_2dB = 1 = Stepsize 2 dB
		\endcode
	\param iDL_PriCPICH_Scr_Code = Primary CPICH downlink scrambling code.
	\param iDL_ChanCode = Downlink DPCH channelization code.

	\return true if all operations succeeded and the correct event messages were received

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_SetupRMC_DCH(
			HANDLE hResourceContext,
			unsigned char iRMC_Type, unsigned char iUL_MaxTxPwr, unsigned long iUL_DPCH_ScrCode, unsigned char iUL_PCA,
			unsigned char iUL_TPC_StepSize, unsigned short iDL_PriCPICH_Scr_Code, unsigned short iDL_ChanCode );

	/******************************************************************************/
	/**
	WCDMA BER, handover to a new RMC DCH channel.  This must be done after the
	QLIB_FTM_WCDMA_BER_SetupRMC_DCH function has completed successfully.

		This low-level FTM operation is called and the associated event is verifed:
			RMC_DCH_SETUP_REQ_V2

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRMC_Type (refer to FTM_WCDMA_BER_RMC_Type_Enum)
		\code
			FTM_WCDMA_BER_RMC_Type12_2kpbs				= 0,	//<!' RMC 12.2 kbps channel
			FTM_WCDMA_BER_RMC_Type64kbps				= 1,	//<!' RMC 64 kbps channel
			FTM_WCDMA_BER_RMC_Type384kpbs				= 2,	//<!' RMC 384 kbps channe (Not currently supported)
			FTM_WCDMA_BER_RMC_Type12_2kpbs_Symmetric	= 3,	//<!' RMC 12.2 kbps channel, block size in the DL and UL is the same
			FTM_WCDMA_BER_RMC_Type64kbps_Symmetric		= 4,	//<!' RMC 64 kbps channel, block size in the DL and UL is the same
			FTM_WCDMA_BER_RMC_Type384kbps_Symmetric		= 5		//<!' RMC 384 kbps channel, block size in the DL and UL is the same
			Note: For first 3 data rate enumeration, UL CRC bits are looped back from DL
			Note: For last  3 data rate enumeration, UL CRC is valid and computed based on Rx data bits
		\endcode
	\param iUL_MaxTxPwr = Maximum transmit power in dBm.

	\param iUL_DPCH_ScrCode = Scrambling code to use for the uplink.
	\param iUL_PCA (refer FTM_WCDMA_BER_PCA_Size_Enum)
		\code
          FTM_WCDMA_BER_PCA_Type_Alg1 = 0 = Power control algorithm 1
          FTM_WCDMA_BER_PCA_Type_Alg2 = 1 = Power control algorithm 2
		\endcode
	\param iUL_TPC_StepSize
		\code
         FTM_WCDMA_BER_PCA_Size_1dB = 0 = Stepsize 1 dB
         FTM_WCDMA_BER_PCA_Size_2dB = 1 = Stepsize 2 dB
		\endcode
	\param iDL_PriCPICH_Scr_Code = Primary CPICH downlink scrambling code.
	\param iDL_ChanCode = Downlink DPCH channelization code.
	\param iBetaC = Gain factor for DPCCH
	\param iBetaD = Gain factor for DPDCH
	\param iChannel = WCDMA RF Channel (downlink)

	\return true if all operations succeeded and the correct event messages were received

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_Handover(
			HANDLE hResourceContext,
			unsigned char iRMC_Type, unsigned char iUL_MaxTxPwr, unsigned long iUL_DPCH_ScrCode, unsigned char iUL_PCA,
			unsigned char iUL_TPC_StepSize, unsigned short iDL_PriCPICH_Scr_Code, unsigned short iDL_ChanCode,
			unsigned char iBetaC, unsigned char iBetaD, unsigned short iChannel);

	/******************************************************************************/
	/**
	WCDMA BER, handover to a new RMC DCH channel.  This must be done after the
	FTM_WCDMA_BER_SetupRMC_DCH function has completed successfully.

	This low-level FTM operation is called and the associated events are verifed:
	of the embedded function RMC_DCH_SETUP_REQ_V2.

	For the timer values (Txxx) refer to the 3GPP standard 25.331, section 8
	For the counter values (Nxxx) refer to section "13.3 - UE constants and parameters"

		This low-level FTM operation is called and the associated event is verifed:
			RMC_DCH_SETUP_REQ_V2B

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRMC_Type (refer to FTM_WCDMA_BER_RMC_Type_Enum)
		\code
			FTM_WCDMA_BER_RMC_Type12_2kpbs				= 0,	//<!' RMC 12.2 kbps channel
			FTM_WCDMA_BER_RMC_Type64kbps				= 1,	//<!' RMC 64 kbps channel
			FTM_WCDMA_BER_RMC_Type384kpbs				= 2,	//<!' RMC 384 kbps channe (Not currently supported)
			FTM_WCDMA_BER_RMC_Type12_2kpbs_Symmetric	= 3,	//<!' RMC 12.2 kbps channel, block size in the DL and UL is the same
			FTM_WCDMA_BER_RMC_Type64kbps_Symmetric		= 4,	//<!' RMC 64 kbps channel, block size in the DL and UL is the same
			FTM_WCDMA_BER_RMC_Type384kbps_Symmetric		= 5		//<!' RMC 384 kbps channel, block size in the DL and UL is the same
			Note: For first 3 data rate enumeration, UL CRC bits are looped back from DL
			Note: For last  3 data rate enumeration, UL CRC is valid and computed based on Rx data bits
		\endcode
	\param iUL_MaxTxPwr = Maximum transmit power in dBm.

	\param iUL_DPCH_ScrCode = Scrambling code to use for the uplink.
	\param iUL_PCA (refer FTM_WCDMA_BER_PCA_Size_Enum)
		\code
          FTM_WCDMA_BER_PCA_Type_Alg1 = 0 = Power control algorithm 1
          FTM_WCDMA_BER_PCA_Type_Alg2 = 1 = Power control algorithm 2
		\endcode
	\param iUL_TPC_StepSize
		\code
         FTM_WCDMA_BER_PCA_Size_1dB = 0 = Stepsize 1 dB
         FTM_WCDMA_BER_PCA_Size_2dB = 1 = Stepsize 2 dB
		\endcode
	\param iDL_PriCPICH_Scr_Code = Primary CPICH downlink scrambling code.
	\param iDL_ChanCode = Downlink DPCH channelization code.
	\param iBetaC = Gain factor for DPCCH. Default is 8.
	\param iBetaD = Gain factor for DPDCH. Default is 15.
    \param iDPCCH_PowerOffset = DPCCH Power Offset, default is -60
    \param n_312 = Maximum number of "in sync" received from L1.  Default is 0 (s1).
		\code
           FTM_WCDMA_BER_N312_s1    = 0
           FTM_WCDMA_BER_N312_s50   = 1
           FTM_WCDMA_BER_N312_s100  = 2
           FTM_WCDMA_BER_N312_s200  = 3
           FTM_WCDMA_BER_N312_s400  = 4
           FTM_WCDMA_BER_N312_s600  = 5
           FTM_WCDMA_BER_N312_s800  = 6
           FTM_WCDMA_BER_N312_s1000 = 7
		\endcode
    \param n_313 = Maximum number of successive "out of sync" received from L1. Default is 4 (s20).
		\code
           FTM_WCDMA_BER_N313_s1   = 0,
           FTM_WCDMA_BER_N313_s2   = 1,
           FTM_WCDMA_BER_N313_s4   = 2,
           FTM_WCDMA_BER_N313_s10  = 3,
           FTM_WCDMA_BER_N313_s20  = 4,
           FTM_WCDMA_BER_N313_s50  = 5,
           FTM_WCDMA_BER_N313_s100 = 6,
           FTM_WCDMA_BER_N313_s200 = 7
		\endcode
    \param n_315 = Maximum number of successive "in sync" received from L1 during T313 is activated. Default is 0 (s1).
		\code
           FTM_WCDMA_BER_N315_s1   = 0,
           FTM_WCDMA_BER_N315_s50  = 1,
           FTM_WCDMA_BER_N315_s100 = 2,
           FTM_WCDMA_BER_N315_s200 = 3,
           FTM_WCDMA_BER_N315_s400 = 4,
           FTM_WCDMA_BER_N315_s600 = 5,
           FTM_WCDMA_BER_N315_s800 = 6,
           FTM_WCDMA_BER_N315_s1000 = 7
		\endcode
    \param t_312 = T312: Timer in seconds for physical channel establishment procedure.  Refer to 25.331 Section 8 for
	                     explicit definition.  Default is 1.
    \param t_313 = T313: Timer in seconds for radio link failure detection.  Refer to 25.331 Section 8 for explicit definition.
	               Default is 3.
	\param iChannel = WCDMA RF Channel (downlink).

	\return true if all operations succeeded and the correct event messages were received

	\warning The active log mask will be changed to log only log FTM2 log packets.
	         When the function is completed, the state of ASYNC logging will be enabled.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_Handover_V2B(
			HANDLE hResourceContext,
			unsigned char iRMC_Type, unsigned char iUL_MaxTxPwr, unsigned long iUL_DPCH_ScrCode, unsigned char iUL_PCA,
			unsigned char iUL_TPC_StepSize, unsigned short iDL_PriCPICH_Scr_Code, unsigned short iDL_ChanCode,
			unsigned char iBetaC, unsigned char iBetaD,
			short iDPCCH_PowerOffset,
			unsigned char n_312,
			unsigned char n_313,
			unsigned char n_315,
			unsigned char t_312,
			unsigned char t_313,
			unsigned short iChannel );

	/******************************************************************************/
	/**
	WCDMA BER, Setup a default RMC DCH channel.  This function calls
	QLIB_FTM_WCDMA_BER_SetupRMC_DCH() with the following parameters:


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	iRMC_Type =  RMC 12.2 kbps channel
	iRMC_Type =  24dBm.
	iUL_DPCH_ScrCode = 0 = Scrambling code to use for the uplink.
	iUL_PCA =  Power Control Algorithm 1
	iUL_TPC_StepSize  = Stepsize 1 dB
	iDL_PriCPICH_Scr_Code = 0 = Primary CPICH downlink scrambling code.
	iDL_ChanCode = 3 = Downlink DPCH channelization code.

	\return true if all operations succeeded and the correct event messages were received

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_SetupDefaultRMC_DCH( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	WCDMA BER, 3.8 FTM WCDMA TFCS Configuration request

	The tfcs_config table must be 4 unique numbers, all between 0 and 3.
	This defines how the TFCI values should be mapped to each Transport Format
	Combination.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param aiTFCS_Config=

		To solve the Agilent issue you would send the command using tfcs_select =
		FTM_WCDMA_BER_UL_TFCS_CONFIG, and tfcs_config = {0,2,1,3}.

		If you don't send the command the default behavior is tfcs_config = {0,1,2,3}.
		Subtle difference, enough to break the Agilent.  Right now we don't really
		need to send a DL_TFCS_CONFIG since other the equipment are flexible or adhere
		to the standard RMC config.

	\param eTFCS_Select = specifies configuration of UL or DL, defined by
		\code
           FTM_WCDMA_BER_UL_TFCS_CONFIG = 0,
           FTM_WCDMA_BER_DL_TFCS_CONFIG = 1
		\endcode

	\param iStatus
		\code
          0 = Success (COMMAND_SUCCESS)
          1 = Failure (COMMAND_FAILED)
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_RMC_DCH_TFCS_CONFIG_REQ(
		HANDLE hResourceContext,
		unsigned char eTFCS_Select,
		unsigned char aiTFCS_Config[ 4] );

		/******************************************************************************/
	/**
	WCDMA BER, Clear BER event status, Section 3.9 FTM Reset Event Status

		This command send FTM command to clear the event status.

		This command clears event status that is used for QLIB_FTM_WCDMA_BER_EVENT_STATUS_REQ function,

		This function could be called before the WCDMA BER function that generates the event.
		For example, QLIB_FTM_WCDMA_BER_AcquirePilot

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

		\param iStatus = 0 - COMMAND_SUCCESS
						 1 - COMMAND_FAILED
		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_EVENT_STATUS_CLEAR_REQ(HANDLE hResourceContext, unsigned short* iStatus);

	/******************************************************************************/
	/**
	WCDMA BER, Wait for event, Section 3.10

		This command allows the user to wait for a specific WCDMA BER non-signaling event. By
		using this command it is possible to avoid using the asynchronous events for the most common
		event types.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

		\param iEventType = See FTM_WCDMA_BER_EVENT_STATUS_Enum in QLib_Defines.h

							0 -	FTM_WCDMA_BER_START_WCDMA_MODE_CNF
							1 - FTM_WCDMA_BER_STOP_WCDMA_MODE_CNF
							2 - FTM_WCDMA_BER_IDLE_MODE_CNF
							3 - FTM_WCDMA_BER_ACQ_CNF
							4 -	FTM_WCDMA_BER_CPHY_SETUP_CNF
							5 - FTM_WCDMA_PHYCHAN_ESTABLISHED_IND

		\param iTimeOut_ms = Timeout to use for waiting for the event. Units are milliseconds.

		\param iStatus =	0  FTM_WCDMA_BER_SYNC_STATUS_SUCCESS
							1  FTM_WCDMA_BER_SYNC_STATUS_GEN_FAILURE
							2  FTM_WCDMA_BER_SYNC_STATUS_TIMEOUT_EXPIRED
							3  FTM_WCDMA_BER_SYNC_STATUS_EVENT_STATUS_FAILED

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_EVENT_STATUS_REQ(HANDLE hResourceContext, unsigned char iEventType, unsigned long iTimeOut_MS, unsigned short* iStatus );


	/******************************************************************************/
	/**
	WCDMA BER, Tx Power Override, Section 3.11

		This command allows user to overrie Tx power in non-signaling mode

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

		\param byte = 1 = ON (override)
		              0 = OFF

		\param iUL_Pwr_dBm10 =	Power (dBm) x 10
		                        For example: 22dBm = 220

		\param iStatus = 0 = COMMAND_SUCCESS
		                 1 = COMMAND_FAIL

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_SET_UL_POWER(HANDLE hResourceContext, unsigned char bOverride, unsigned short iUL_Pwr_dBm10, unsigned short* iStatus);

	/******************************************************************************/
	/**
	WCDMA BER, Rx Level Report, Section 3.12

		This command returns the current receive power in RX_AGC and dBm for a selected receive chain.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

		\param iRxChain = 0 - Primary Rx
		                  1 - Secondary Rx


		\param iRxAGC  = Rx AGC

		\param iRxPowerdBm  = Rx power in 1/10 dBm units
		                      This value is signed

		\param iStatus = 0 = COMMAND_SUCCESS
		                 1 = COMMAND_FAIL

		\warning

		\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_RX_LEVEL_REQ(HANDLE hResourceContext, unsigned char iRxChain, unsigned short* iStatus, short*iRxAGC, short* iRxPowerdBm);
	/******************************************************************************/
	/**
	WCDMA BER, TPC Control, Section 3.13
	
		This function sends FTM_WCDMA_BER_TPC_CONTROL command which simulates all up or all down bits.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

		\param iOverride_Enabled	=	0  Up down bits from generator; TCP_Pattern ignored
										1  Override enabled; simulate all up or all down bits

		\param iTCP_Pattern  = Pattern per channel; example below sets all channels:
					   	 
							   0 - All Down Power Control Bits
 							   1 - All Up Power Control Bits

		\param iStatus = 0 = COMMAND_SUCCESS
		                 1 = COMMAND_FAIL

		
		\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_TPC_CONTROL(HANDLE hResourceContext, unsigned short iOverride_Enabled, unsigned long iTCP_Pattern, unsigned short* iStatus);

	/******************************************************************************/
	/**
	WCDMA BER, Clear the internal status of the WCDMA BER structure

		Resets the contents of all fields in the internal WCDMA_BER_State state structure.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if all operations succeeded and the correct event messages were received

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_ClearStatus( HANDLE hResourceContext );


	/******************************************************************************/
	/**
	WCDMA BER, Returns a copy of the internal WCDMA BER state. On the internal copy
	         it clears the "updated" fields for each message type so that the
			 next time this funciton is called. Only items that been received
			 since the first function call are marked as "updated."


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pWCDMA_BER_State = reference to a WCDMA_BER_State structure that will be
	                        filled in with the state information

	\return true if all operations succeeded and the correct event messages were received

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_GetStatus( HANDLE hResourceContext, unsigned char* pWCDMA_BER_State );

	/******************************************************************************/
	/**
	WCDMA BER, Returns a simplified status of whether a specified event has occured.

	The function operations upon the bHasUpdated array held in the WCDMA BER status
	structure (data type WCDMA_BER_State, as defined in QLib_Defines.h).

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param eEventID = The input parameter is an index into this array, and the function
	                   returns a true if the event has occured and false if it has not.

		Data type is log_FTM2_WCDMA_BER_log_id_enum, defined in QLib_Defines.h

		Values are:
		\code
         LOG_FTM2_WCDMA_START_MODE_CNF          = 0 = FTM WCDMA BER start WCDMA mode confirmation
         LOG_FTM2_WCDMA_STOP_MODE_CNF           = 1 = FTM WCDMA BER stop WCDMA mode confirmation
         LOG_FTM2_WCDMA_START_IDLE_MODE_REQ     = 2 = FTM WCDMA BER start idle mode confirmation
         LOG_FTM2_WCDMA_ACQUIRE_CNF             = 3 = FTM WCDMA BER acquire confirmation
         LOG_FTM2_WCDMA_CPHY_SETUP_CNF	        = 4 = FTM WCDMA BER CPHY setup confirmation
         LOG_FTM2_WCDMA_PHYCHAN_ESTABLISHED_IND = 5 = FTM WCDMA BER physical channel established confirmation
         LOG_FTM2_WCDMA_CPHY_ERROR_IND          = 6 = FTM WCDMA BER pyhsical channel error
         LOG_FTM2_WCDMA_RL_FAILURE_IND          = 7 = FTM WCDMA BER Reverselink error
		\endcode


	\param pWCDMA_BER_State = reference to a WCDMA_BER_State structure that will be
	                        filled in with the state information

	\return true the event type has occurred, false if it has not.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_GetEventStatus( HANDLE hResourceContext, unsigned char eEventID );

	/******************************************************************************/
	/**
	WCDMA BER, close the WCDMA Non-signaling session.

		This low-level FTM operation is called and the associated event is verifed:
 			STOP_WCDMA_MODE_REQ

		This function also calls QLIB_FTM_LOG_StopFTM_Log( HANDLE, LOG_FTM2_LOG_WCDMA_BER )
		to disable the FTM log that was started in QLIB_FTM_WCDMA_BER_StartSession


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\return true if all operations succeeded and the correct event messages were received

	\warning This function will disable async logging and clear the async queue.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_BER_StopSession( HANDLE hResourceContext );

	/******************************************************************************/
	/**

	Start logging of WCDMA AGC packets.

	This command calls the FTM_LOG_ENABLE() function with the proper settings.
	Subsequently the function WaitForNextWCDMA_AGC_Log() can be called to wait
	for the next WCDMA log message and have the values returned.

	Note QLIB_FTM_WCDMA_BER_StartSession() automatically calls this function when
	it begins.

	\return true if successful, false if fail.

	\warning

        1. Before this function is called, the phone must be set in a WCDMA FTM mode, by
           calling either QLIB_FTM_SET_MODE() for basic RF testing, or by calling
				QLIB_FTM_WCDMA_BER_StartSession() for WCDMA BER testing.

		2. This function will set the async messasge logging status to ON, to
           turn off async messages, QLIB_DIAG_SetPhoneLoggingState() should be called.



	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_AGC_Start_Log( HANDLE hResourceContext );

	/******************************************************************************/
	/**

	Wait a specified number of milliseconds for the next WCMA AGC log message.

	If the message is found, then the contents of the message are copied into

	This command calls the FTM_LOG_ENABLE() function with the proper settings.
	Subsequently the function WaitForNextWCDMA_AGC_Log() can be called to wait
	for the next WCDMA log message and have the values returned.

	\param pWCDMA_AGC_Log = pointer to the are to store the WCDMA AGC log information.
	                        This is of type "FTM2LogMessage_WCDMA_AGC" defined in
							QLIB_Defines.h

	\param iTimeout_ms = # of milliseconds to wait for the AGC.  Default is 300ms

	\return true if a valid WCDMA log was found within the specified timeout, false if not.

	\warning Before this function is called, StartWCDMA_AGC_Log() must be called to setup
	         capturing of WCDMA AGC messages.


	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_AGC_WaitForNextLog(
					HANDLE hResourceContext,  void* pWCDMA_AGC_Log, unsigned long iTimeout_ms );

	/******************************************************************************/
	/**

	Stop logging of WCDMA AGC packets.  This is important to do before changing
	RF modes or starting/stopping WCDMA BER

	This command calls the FTM_LOG_DISABLE() function with the proper settings.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning This function will set the async messasge logging status to OFF.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_AGC_Stop_Log( HANDLE hResourceContext  );

	/******************************************************************************/
	/**

	Starts logging WCDMA AGC (LOG_FTM2_LOG_WCDMA_AGC_V2) packets.

	This command calls the FTM_LOG_ENABLE() function with the proper settings.
	Subsequently the function QLIB_FTM_WCDMA_AGC_WaitForNextLog_V2() can be called
	to wait for the next WCDMA log message and have the values returned.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\return true if successful, false if fail.

	\warning

        1. Before this function is called, the phone must be set in a WCDMA FTM mode,
		   by calling either QLIB_FTM_SET_MODE() for basic RF testing, or by calling
		   QLIB_FTM_WCDMA_BER_StartSession() for WCDMA BER testing.

		2. This function will set the async messasge logging status to ON, to
           turn off async messages, QLIB_DIAG_SetPhoneLoggingState() should be called.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_AGC_Start_Log_V2( HANDLE hResourceContext );

	/******************************************************************************/
	/**

	Wait a specified number of milliseconds for the next WCMA AGC log message.

	If the message is found, then the contents of the message are copied into a
	FTM2LogMessage_WCDMA_AGC_V2 structure.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pWCDMA_AGC_Log = pointer to the area to store the WCDMA AGC log information.
	                        This is of type "FTM2LogMessage_WCDMA_AGC_V2" defined in
							QLIB_Defines.h
	\param iTimeout_ms = # of milliseconds to wait for the WCDMA log.  Default is 300ms

	\return true if a valid WCDMA log was found within the specified timeout, false if not.

	\warning Before this function is called, QLIB_FTM_WCDMA_AGC_Start_Log_V2() must be
			 called to setup capturing of WCDMA AGC messages.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_AGC_WaitForNextLog_V2( HANDLE hResourceContext,
		                                                         void* pWCDMA_AGC_Log,
																 unsigned long iTimeout_ms );

	/******************************************************************************/
	/**

	Stop logging WCDMA AGC (LOG_FTM2_LOG_WCDMA_AGC_V2) packets.  This is important
	to do before changing RF modes or starting/stopping WCDMA BER.

	This command calls the FTM_LOG_DISABLE() function with the proper settings.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning This function will set the async message logging status to OFF.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_AGC_Stop_Log_V2( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	UMTS non-signaling, ensure mobile phone is in a "stopped" state for all
	UMTS non-signlaing modes (WCDMA/GSM).

	The procedure used is:
		1) Call STOP_WCDMA_MODE_REQ
		2) If the status code is successful, then this indicates the mobile was in
		   the WCDMA mode, so the function will wait for the corresponding event.

		3) Call STOP_GSM_MODE_REQ
		4) If the status code is successful, then this indicates the mobile was in
		   the GSM mode, so the function will wait for the corresponding event.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if the commands were executed without a device communication failure.

	\warning The mobile phone must be in FTM mode before this function is called.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UMTS_BER_ForceStopped(	HANDLE hResourceContext );

	/******************************************************************************/
	/**
	WCDMA BER API, 80-V9698-1, START_WCDMA_MODE_REQUEST command

	This command starts the WCDMA Layer 1 task from an Inactive state. This will initialize the
	4 Layer 1 subsystem and the necessary driver

	This function can be used in FTM Sequencing mode operation.
	
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if the commands were executed without a device communication failure.

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_START_MODE_REQ(HANDLE hResourceContext, unsigned char* iStatus);

	/******************************************************************************/
	/**
	WCDMA BER API, 80-V9698-1, ACQUIRE_REQ command

	TThis command starts a cell search acquisition procedure. Currently, the user may only specify an
	3 ARFCN to perform the cell search procedure..

	This function can be used in FTM Sequencing mode operation.
	
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iChannel = WCDMA RF channel

	\param iAcqType =   0  Frequency valid only
						1  Frequency and scrambling code valid only (not supported)
						2  Frequency, scrambling code, and PN position valid (not supported)

						Frequency valid only(0) should be used for this parameter

	\param iAcqType =	0  Micro acquisition (not supported)
						1  Full acquisition

						Full acquisition (1) should be used for this parameter.
					  
	\param iFreq	=	ARFCN to attempt acquisition
						Required for acq_type  0, 1, or 2

	\param iScrCode =   DL scrambling code to acquire; used in conjunction with freq; only valid for acq_type  1 or 2
						This field may be ignored for certain values of acq_mode, even if acq_type indicates to use this field

	\param iPN_Pos =	Used to search for pilot at a known PN position; used in conjunction with scr_code and freq; only valid for acq_type  2
						This field may be ignored for certain values of acq_mode, even if acq_type indicates to use this field
	
	\param iStatus =    0 == command success 
	                    1 == command fail

	\return true if the commands were executed without a device communication failure.

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_ACQUIRE_REQ( HANDLE hResourceContext, unsigned char iAcqType, unsigned char iAcqMode, unsigned short iFreq, unsigned short iScrCode, unsigned long iPN_Pos, unsigned char* iStatus );

	/******************************************************************************/
	/**
	WCDMA BER API, 80-V9698-1, RMC_DCH_RECONFIGURE command

	This request attempts to reconfigure the RMC DCH call when a call is already established. 
	Some platforms may be able to use this command to initially establish the RMC call directly after performing an acquisition step

	For the timer values (Txxx) refer to the 3GPP standard 25.331, section 8
	For the counter values (Nxxx) refer to section "13.3 - UE constants and parameters"

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	
	\param iRMC_Type (refer to FTM_WCDMA_BER_RMC_Type_Enum)
		\code
			FTM_WCDMA_BER_RMC_Type12_2kpbs				= 0,	//<!' RMC 12.2 kbps channel
			FTM_WCDMA_BER_RMC_Type64kbps				= 1,	//<!' RMC 64 kbps channel
			FTM_WCDMA_BER_RMC_Type384kpbs				= 2,	//<!' RMC 384 kbps channe (Not currently supported)
			FTM_WCDMA_BER_RMC_Type12_2kpbs_Symmetric	= 3,	//<!' RMC 12.2 kbps channel, block size in the DL and UL is the same
			FTM_WCDMA_BER_RMC_Type64kbps_Symmetric		= 4,	//<!' RMC 64 kbps channel, block size in the DL and UL is the same
			FTM_WCDMA_BER_RMC_Type384kbps_Symmetric		= 5		//<!' RMC 384 kbps channel, block size in the DL and UL is the same
			Note: For first 3 data rate enumeration, UL CRC bits are looped back from DL
			Note: For last  3 data rate enumeration, UL CRC is valid and computed based on Rx data bits
		\endcode
	\param iUL_MaxTxPwr = Maximum transmit power in dBm.

	\param iUL_DPCH_ScrCode = Scrambling code to use for the uplink.
	
	\param iUL_PCA (refer FTM_WCDMA_BER_PCA_Size_Enum)
		\code
          FTM_WCDMA_BER_PCA_Type_Alg1 = 0 = Power control algorithm 1
          FTM_WCDMA_BER_PCA_Type_Alg2 = 1 = Power control algorithm 2
		\endcode
	
	\param iUL_TPC_StepSize
		\code
         FTM_WCDMA_BER_PCA_Size_1dB = 0 = Stepsize 1 dB
         FTM_WCDMA_BER_PCA_Size_2dB = 1 = Stepsize 2 dB
		\endcode
	
	\param iDL_PriCPICH_Scr_Code = Primary CPICH downlink scrambling code.
	
	\param iDL_ChanCode = Downlink DPCH channelization code.
	
	\param iBetaC = Gain factor for DPCCH. Default is 8.
	
	\param iBetaD = Gain factor for DPDCH. Default is 15.
    
	\param iDPCCH_PowerOffset = DPCCH Power Offset, default is -60
    
	\param n_312 = Maximum number of "in sync" received from L1.  Default is 0 (s1).
		\code
           FTM_WCDMA_BER_N312_s1    = 0
           FTM_WCDMA_BER_N312_s50   = 1
           FTM_WCDMA_BER_N312_s100  = 2
           FTM_WCDMA_BER_N312_s200  = 3
           FTM_WCDMA_BER_N312_s400  = 4
           FTM_WCDMA_BER_N312_s600  = 5
           FTM_WCDMA_BER_N312_s800  = 6
           FTM_WCDMA_BER_N312_s1000 = 7
		\endcode
    \param n_313 = Maximum number of successive "out of sync" received from L1. Default is 4 (s20).
		\code
           FTM_WCDMA_BER_N313_s1   = 0,
           FTM_WCDMA_BER_N313_s2   = 1,
           FTM_WCDMA_BER_N313_s4   = 2,
           FTM_WCDMA_BER_N313_s10  = 3,
           FTM_WCDMA_BER_N313_s20  = 4,
           FTM_WCDMA_BER_N313_s50  = 5,
           FTM_WCDMA_BER_N313_s100 = 6,
           FTM_WCDMA_BER_N313_s200 = 7
		\endcode
    
	\param n_315 = Maximum number of successive "in sync" received from L1 during T313 is activated. Default is 0 (s1).
		\code
           FTM_WCDMA_BER_N315_s1   = 0,
           FTM_WCDMA_BER_N315_s50  = 1,
           FTM_WCDMA_BER_N315_s100 = 2,
           FTM_WCDMA_BER_N315_s200 = 3,
           FTM_WCDMA_BER_N315_s400 = 4,
           FTM_WCDMA_BER_N315_s600 = 5,
           FTM_WCDMA_BER_N315_s800 = 6,
           FTM_WCDMA_BER_N315_s1000 = 7
		\endcode
    
	\param t_312 = T312: Timer in seconds for physical channel establishment procedure.  Refer to 25.331 Section 8 for
	                     explicit definition.  Default is 1.
    
	\param t_313 = T313: Timer in seconds for radio link failure detection.  Refer to 25.331 Section 8 for explicit definition.
	               Default is 3.
	
	\param iChannel = WCDMA RF Channel (downlink).

	\param iStatus =    0 == command success 
	                    1 == command fail

	\return true if all operations succeeded and the correct event messages were received

	\return true if the commands were executed without a device communication failure.

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_RMC_DCH_SETUP_REQ_V2B( HANDLE hResourceContext,
													unsigned char iRMC_Type, 
													unsigned char iUL_MaxTxPwr, 
													unsigned long iUL_DPCH_ScrCode, 
													unsigned char iUL_PCA,
													unsigned char iUL_TPC_StepSize, 
													unsigned short iDL_PriCPICH_Scr_Code, 
													unsigned short iDL_ChanCode,
													unsigned char iBetaC, 
													unsigned char iBetaD,
													short iDPCCH_PowerOffset,
													unsigned char n_312,
													unsigned char n_313,
													unsigned char n_315,
													unsigned char t_312,
													unsigned char t_313,
													unsigned short iChannel,
													unsigned char *iStatus);

	/******************************************************************************/
	/**
	WCDMA BER API, 80-V9698-1, STOP_WCDMA_MODE_REQ command

	This command stops the WCDMA Layer 1 services and returns to the inactive state. 
	If the user has previously given a Start WCDMA mode request, the user must issue this command before proceeding to other FTM tests, or entering Online mode.
	
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	
	\param iStatus =    0 == command success 
	                    1 == command fail

	\return true if the commands were executed without a device communication failure.

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WCDMA_STOP_MODE_REQ(HANDLE hResourceContext, unsigned char* iStatus);

/*******************************************************************************************
	HSDPA BER FTM
/*******************************************************************************************/

	/******************************************************************************/
	/**
	HSDPA BER, Start a HSDPA BER session. Before this operation is called, a valid
	WCDMA BER session must be started by calling QLIB_FTM_WCDMA_BER_StartSession().

		This function calls these operations and checks for errors:
			FTM_HSDPA_BER_ClearStatus

		This low-level FTM operation is called and the associated event is verifed:
			START_HSDPA_REQ

		If the first START_HSDPA_REQ call fails, because a mode is already started then the
		function will stop HSDPA using STOP_HSDPA_REQ and try to re-start using START_HSDPA_REQ
		again.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if network session is setup successful, false if there are any failures

	\warning The active log mask will be changed to log only log FTM2 log packets.
	         When the function is completed, the state of ASYNC logging will be enabled.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_HSDPA_BER_StartSession( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	High level command for HSDPA BLER, calls RECONFIG_HSDPA_REQ and
	handles all related embedded events.

	While an HSDPA link is active, it is possible to dynamically reconfigure any or all of the high
	speed channels. The user should send updated channel configurations using the appropriate
	configuration commands in Sections 2.4 through 2.7, and then use this command to indicate
	which channels should be reconfigured by Layer 1. Note the reconfiguration happens using an
	activation time of now.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iReconfigBitmask - This bitmask represents which channels should be reconfigured by L1. It is possible
	                          to reconfigure one or many channels by setting the appropriate bit in this 8 bit field. It
	                          is assumed that the actual updated channel configurations have already been sent
	                          down using the configuration commands. At least one of the channels must be
	                          specified for reconfiguration using this bitmask. The user should not set any of the
	                          upper 4 bits.
		\code
          Bit 0 = Reconfigure HS-DSCH channel
          Bit 1 = Reconfigure HS-PDSCH
          Bit 2 = Reconfigure HS-SCCH
          Bit 3 = Reconfigure HS-DPCCH
          Bits 4-7 = Reserved. Set to 0.

          Example: If the user wants to reconfigure both HS-DSCH and HS-DPCCH, the
                   reconfig_bitmask should be set to 0x09.
		\endcode


	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_HSDPA_BLER_Reconfigure_HS( HANDLE hResourceContext, unsigned char iReconfigBitmask );

	/******************************************************************************/
	/**
	High level command for HSDPA BLER, calls CONFIG_HS_PDSCH_REQ and verifies the
	return status.

	This command configures the HS-PDSCH. All configurations are buffered by the FTM software.
	This command is used when the user sends the start HSDPA command (if HSDPA is inactive) or
	reconfigure command (if HSDPA is active).

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iHS_PDSCH_RadioLink_PCS Primary scrambling code for the HS radio link.


	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_HSDPA_BLER_Configure_PDSCH( HANDLE hResourceContext, unsigned short iHS_PDSCH_RadioLink_PCS );

	/******************************************************************************/
	/**
	High level command for HSDPA BLER, calls CONFIGURE_HS_SCCH_REQ  and verifies the
	return status.

	This command configures the HS-SCCH. The user can indicate to L1 the HS-SCCH
	channelisation code set. Up to four codes can be monitored at once by the UE.
	All configurations are buffered by the FTM software. This command is used when the user sends
	the start HSDPA command (if HSDPA is inactive) or reconfigure command (if HSDPA is
	active).

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iNumCodes - Number of channelisation codes in the HS-SCCH code set. Range is from 1-4

	\param aiCodes[4] - Array of 4 bytes, which represent the code numbers in the code set. Only num_codes
                      bytes need to be valid. For example, if num_codes is 3, the 4 bytes in the codes field
                      can be set to [ 12, 13, 14, X], where the first 3 bytes dictates the code set, and X is
                      dont care.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_HSDPA_BLER_Configure_HS_SCCH( HANDLE hResourceContext, unsigned char iNumCodes, unsigned char aiCodes[4] );

	/******************************************************************************/
	/**
	High level command for HSDPA BLER, calls CONFIGURE_HS_DSCH_REQ and
	handles all related embedded events.

	This command configures the HS-DSCH. The user can indicate the H-RNTI identifier, the
	number of HARQ processes, and explicitly declare the Virtual IR buffer memory partition for
	each process. Up to eight HARQ processes can be configured. Note the total amount of Virtual IR
	buffer space that can be defined is limited by the UE category. If the user tries to configure the
	HS-DSCH for more soft memory than allowable by the UE, the UE will reject the configuration,
	and will result in an error in the HSDPA log events that results from the start or reconfigure
	HSDPA operation.

	All configurations are buffered by the FTM software. This command is used when the user sends
	the start HSDPA command (if HSDPA is inactive) or reconfigure command (if HSDPA is
	active).

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iH_RNTI - 16 bit UE ID for use during HSDPA session.

	\param iNum_HARQ_Processes - Number of HARQ processes to define. Range is from 1-8.

	\param bMemPartitionValid - unsigned char, set to indicate the mem_partition_info field contains valid data.

	\param aiMemPartitionInfo[8] Array of 8 bytes that represent the number of soft bits to define for each HARQ
                                 process. This array is only valid if mem_partition_valid field is set to TRUE. If
                                 so, only num_harq_processes elements of this array need to be valid. The rest
                                 can be dont care values. Each valid element should take on one of the
                                 following values:
		\code
           0 = HMS800 (indicates 800 soft bits for the HARQ process)
           1 = HMS1600
           2 = HMS2400
           3 = HMS3200
           4 = HMS4000
           5 = HMS4800
           6 = HMS5600
           7 = HMS6400
           8 = HMS7200
           9 = HMS8000
           10 = HMS8800
           11 = HMS9600
           12 = HMS10400
           13 = HMS11200
           14 = HMS12000
           15 = HMS12800
           16 = HMS13600
           17 = HMS14400
           18 = HMS15200
           19 = HMS16000
           20 = HMS17600
           21 = HMS19200
           22 = HMS20800
           23 = HMS22400
           24 = HMS24000
           25 = HMS25600
           26 = HMS27200
           27 = HMS28800
           28 = HMS30400
           29 = HMS32000
           30 = HMS36000
           31 = HMS40000
           32 = HMS44000
           33 = HMS48000
           34 = HMS52000
           35 = HMS56000
           36 = HMS60000
           37 = HMS64000
           38 = HMS68000
           39 = HMS72000
           40 = HMS76000
           41 = HMS80000
           42 = HMS88000
           43 = HMS96000
           44 = HMS104000
           45 = HMS112000
           46 = HMS120000
           47 = HMS128000
           48 = HMS136000
           49 = HMS144000
           50 = HMS152000
           51 = HMS160000
           52 = HMS176000
           53 = HMS192000
           54 = HMS208000
           55 = HMS224000
           56 = HMS240000
           57 = HMS256000
           58 = HMS272000
           59 = HMS288000
           60 = HMS304000

		   Example: For Fixed Reference Channel HSET5 QPSK, the mem_partition_info
		   is set up as [ 11, 11, 11, X, X, X, X, X] where 11 represents 9600 soft bits for
		   HARQ processes 0-2, and X is dont care value.
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_HSDPA_BLER_Configure_HS_DSCH(
			HANDLE hResourceContext,
			unsigned short iH_RNTI,
			unsigned char iNum_HARQ_Processes,
			unsigned char bMemPartitionValid,
			unsigned char aiMemPartitionInfo[8]
			);

	/******************************************************************************/
	/**
	High level command for HSDPA BLER, calls QLIB_FTM_HSDPA_BLER_Configure_HS_DSCH
	with a specific HSET configuration.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iH_RNTI - 16 bit UE ID for use during HSDPA session.

	\param eHSET = parameter of type ftm_hsdpa_ber_hset_type (defined in QLib_Defines.h)
		\code
          HSDPA_HSET_1_QPSK = 1,		//!< ' HSET 1, QPSK
          HSDPA_HSET_1_16QAM,			//!< ' HSET1, 16QAM
          HSDPA_HSET_2_QPSK,			//!< ' HSET2, QPSK
          HSDPA_HSET_2_16QAM,			//!< ' HSET2, 16QAM
          HSDPA_HSET_3_QPSK,			//!< ' HSET3, QPSK
          HSDPA_HSET_3_16QAM,			//!< ' HSET3, 16QAM
          HSDPA_HSET_4_QPSK,			//!< ' HSET4, QPST
          HSDPA_HSET_5_QPSK,			//!< ' HSET5, QPST
          HSDPA_HSET_6_QPSK = 0xFF		//!< ' HSET6, QPST
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_HSDPA_BLER_Configure_HS_DSCH_HSET( HANDLE hResourceContext, unsigned short iH_RNTI, unsigned char eHSET );

	/******************************************************************************/
	/**
	High level command for HSDPA BLER, calls CONFIGURE_HS_DPCCH_REQ and
	handles all related embedded events.

	This command configures the HS-DPCCH. All configurations are buffered by the FTM software.
	This command is used when the user sends the start HSDPA command (if HSDPA inactive) or
	reconfigure command (if HSDPA active).

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iCPICH_PowerOffset- Power offset of HS-PDSCH relative to serving CPICH. Values can be -12
                              to 26, indicating -6 dB to 13 dB, in 0.5 dB steps

	\param iCQI_FeedbackCycle - Period for CQI reports. Range is from 0-160 with units in milliseconds. 0
                              indicates CQI reporting is to be turned off. Valid values between 0 and
                              160 are defined in the 3GPP specifications

	\param iCQI_RepetitionFactor - Parameter that controls if CQI reports are to be repeated. Valid range is 1-4

	\param iDeltaCQI- Parameter that controls power adjustment for CQI reports. Valid range is 0-8.

	\param iDeltaACK - Parameters that controls power adjustments for ACK indications. Valid range is 0-8.

	\param iDeltaNACK - Parameter that controls power adjustments for NACK indications. Valid range is 0-8

	\param iACK_NACK_RepetitionFactor - Parameter that controls repetition of ACK/NACK indications. Valid range is 1-4.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_HSDPA_BLER_Configure_HS_DPCCH(
				HANDLE hResourceContext,
				unsigned char iCPICH_PowerOffset,
				unsigned char iCQI_FeedbackCycle,
				unsigned char iCQI_RepetitionFactor,
				unsigned char iDeltaCQI,
				unsigned char iDeltaACK,
				unsigned char iDeltaNACK,
				unsigned char iACK_NACK_RepetitionFactor
				);

    /******************************************************************************/
	/**
	HSDPA BLER, Clear BLER event status, Section 3.9 FTM Reset Event Status

		This command send FTM command to clear the event status.

		This command clears event status that is used for QLIB_FTM_HSDPA_BLER_EVENT_STATUS_REQ function,

		This function could be called before the HSDPA BLER function that generates the event.
		For example, QLIB_FTM_HSDPA_BER_StartSession

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

		\param iStatus = 0 - COMMAND_SUCCESS
						 1 - COMMAND_FAILED
		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_HSDPA_BLER_EVENT_STATUS_CLEAR_REQ(HANDLE hResourceContext, unsigned short* iStatus);

	/******************************************************************************/
	/**
	HSDPA BLER, Wait for event, Section 3.10

		This command allows the user to wait for a specific HSDPA BLER non-signaling event. By
		using this command it is possible to avoid using the asynchronous events for the most common
		event types.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

		\param iEventType = See FTM_HSDPA_BLER_EVENT_STATUS_Enum in QLib_Defines.h

							0 - FTM_HSDPA_BLER_HS_CHANNEL_START_SYNC_STATUS
							1 - FTM_HSDPA_BLER_HS_CHANNEL_STOP_SYNC_STATUS
							2 - FTM_HSDPA_BLER_HS_CHANNEL_RECFG_SYNC_STATUS

		\param iTimeOut_ms = Timeout to use for waiting for the event. Units are milliseconds.

		\param iStatus =	0  FTM_HSDPA_BLER_SYNC_STATUS_SUCCESS
							1  FTM_HSDPA_BLER_SYNC_STATUS_GEN_FAILURE
							2  FTM_HSDPA_BLER_SYNC_STATUS_TIMEOUT_EXPIRED
							3  FTM_HSDPA_BLER_SYNC_STATUS_EVENT_STATUS_FAILED

		\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_HSDPA_BLER_EVENT_STATUS_REQ(HANDLE hResourceContext, unsigned char iEventType, unsigned long iTimeOut_MS, unsigned short* iStatus );



	/******************************************************************************/
	/**
	WCDMA BER, Clear the internal status of the WCDMA BER structure

		Resets the contents of all fields in the internal WCDMA_BER_State state structure.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if all operations succeeded and the correct event messages were received

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_HSDPA_BER_ClearStatus( HANDLE hResourceContext );


	/******************************************************************************/
	/**
	HSDPA BER, Returns a copy of the internal WCDMA BER state. On the internal copy
	         it clears the "updated" fields for each message type so that the
			 next time this funciton is called. Only items that been received
			 since the first function call are marked as "updated."

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pWCDMA_BER_State = reference to a WCDMA_BER_State structure that will be
	                        filled in with the state information.  Structure type is
							HSDPA_BER_State.

	\return true if all operations succeeded and the correct event messages were received

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_HSDPA_BER_GetStatus( HANDLE hResourceContext, unsigned char* pHSDPA_BER_State );

	/******************************************************************************/
	/**
	HSDPA BER, close the HSDPA Non-signaling session by calling this function and
	checking for the corresponding event:
		STOP_HSDPA_REQ

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if all operations succeeded and the correct event messages were received

	\warning This function will disable async logging and clear the async queue.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_HSDPA_BER_StopSession( HANDLE hResourceContext );

/******************************************************************************
						GSM BER FTM
*******************************************************************************/

	/******************************************************************************/
	/**
	GSM BER, Start a GSM BER session. After this function is called, the BCCH acquistion
	will need to be setup using FTM_GSM_BER_AssignBCCH.

		This function calls these operations and checks for errors:
			FTM_GSM_BER_ClearStatus

		This low-level FTM operation is called and the associated event is verifed:
			START_GSM_MODE_REQ

		\param iTimeOut_ms = millisecond timeout for all GSM BER operations.  This should
							 be long enough that all operations will return the desired
							 events before the timeout is complete.

							 If the command response events occur before the timeout is
							 complete then the program flow will continue immediately, so there
							 is no penalty for having a long time-out, unless an error occurs.

							 FTM_NONSIG_DEFAULT_TIMEOUT to use the system's default timeout.

							 Will only be updated when a session is being intilalized.

	\return true if network session is seutp successful, false if there are any failures

	\warning The active log mask will be changed to log only log FTM2 log packets.
	         When the function is completed, the state of ASYNC logging will be enabled.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_StartSession(
			HANDLE hResourceContext, unsigned long iTimeOut_ms );

	/******************************************************************************/
	/**
	GSM BER, Assign a BCC.  Before this function is called, FTM_GSM_BER_StartSession
	must be called.  When the function is completed, the phone will be in the IDLE
	state.

	If using a CMU-200, the "connect" command should not be sent until after this function
	is executed.  Before this calling this function though, the BCCH channel should be
	established so that the phone can successfully acquire.


		These low-level FTM operations are called and the associated events are verifed:
			SELECT_SPECIFIC_BCCH_REQ
			START_IDLE_MODE_REQ

		\param iChannel = RF channel. Valid range depends on band.
		\param iBand
			\code
			  0 = PGSM 900 = FTM_GSM_BER_PGSM_900
			  1 = EGSM 900 = FTM_GSM_BER_EGSM_900
			  2 = PCS 1900 = FTM_GSM_BER_PCS_1900
			  3 = DCS 1800 = FTM_GSM_BER_DCS_1800
			  4 = CELL 850 = FTM_GSM_BER_CELL_850
			\endcode

	\return true if network session is seutp successful, false if there are any failures

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_AssignBCCH(
		HANDLE hResourceContext, unsigned short iChannel, unsigned char iBand);

	/******************************************************************************/
	/**
	GSM BER, Assign a GSM traffic channel and configure a loopback.  Before using this
	function, FTM_GSM_BER_AssignBCCH() should be completed successfully and if a CMU-200
	is being used, the "connect" command should be sent it.

		These low-level FTM operations are called and the associated events are verifed:
			CHANNEL_ASSIGN_REQ
			CONFIG_LOOPBACK_TYPE_REQ


		\param iLoopbackType (uses FTM_GSM_BER_LoopbackType_Enum)
		\code
          0 = Disable Loopback = FTM_GSM_BER_Disable_Loopback
          1 = Loopback Type A  = FTM_GSM_BER_Loopback_Type_A
          2 = Loopback Type B  = FTM_GSM_BER_Loopback_Type_B
          3 = Loopback Type C  = FTM_GSM_BER_Loopback_Type_C
		\endcode
		\param iSlot = Slot - TCH slot:
		\code
          0 = Slot 0
          1 = Slot 1
          2 = Slot 2
          3 = Slot 3
          4 = Slot 4
          5 = Slot 5
          6 = Slot 6
          7 = Slot 7
		\endcode
		NOTE: NOTE When using a BCCH+TCH simultaneous configuration (required), not all slots
		will be available for the TCH.

		\param iMode
		\code
          0 = SPEECH - FULL RATE = FTM_GSM_BER_SPEECH_FULL_RATE
          1 = SPEECH - HALF RATE = FTM_GSM_BER_SPEECH_HALF_RATE
          2 = SPEECH - ENHANCED FULL RATE = FTM_GSM_BER_SPEECH_ENHANCED_FULL_RATE
          3 = AMR - FULL RATE = FTM_GSM_BER_AMR_FULL_RATE
          4 = AMR - HALF RATE = FTM_GSM_BER_AMR_HALF_RATE
          5 = DATA - 14.4 KBPS FULL RATE = FTM_GSM_BER_DATA_14_4_KBPS_FULL_RATE
          6 = DATA - 9.6 KBPS FULL RATE FTM_GSM_BER_DATA_9_6_KBPS_FULL_RATE
		\endcode
			NOTE: Options 1-6 may not be supported by the FTM software.

	\param iStatus
		\code
          0 = Success (DIAG_FTM_STATUS_SUCCESS)
          1 = Failure (DIAG_FTM_STATUS_FAIL)
		\endcode

	\return true if network session is seutp successful, false if there are any failures

	\warning The active log mask will be changed to log only log FTM2 log packets.
	         When the function is completed, the state of ASYNC logging will be enabled.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_AssignTraffic(
			HANDLE hResourceContext, unsigned short iLoopbackType,
			unsigned char iSlot, unsigned char iMode );

	/******************************************************************************/
	/**
	GSM BER, 2.4 FTM configuration loopback type request
		This command calls CONFIG_LOOPBACK_TYPE_REQ and checks the return status.

		This used to set the UE to one of the supported loopback modes.
		Currently the supported modes are Loopback A (TCH loop with signalling of
		erased frames), Loopback B (TCH loop without signalling of erased frames),
		and Loopback C (TCH burst by burst). The user should be able to change
		loopback modes directly (example: Loopback C to Loopback A) at any time on
		the TCH.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iLoopbackType (uses FTM_GSM_BER_LoopbackType_Enum)
		\code
          0 = Disable Loopback = FTM_GSM_BER_Disable_Loopback
          1 = Loopback Type A  = FTM_GSM_BER_Loopback_Type_A
          2 = Loopback Type B  = FTM_GSM_BER_Loopback_Type_B
          3 = Loopback Type C  = FTM_GSM_BER_Loopback_Type_C
		\endcode

	\return true if successful, false if fail.

	\warning The status return value in the FTM response packet will not be evaluated.  This is
	         because some early versions of embedded software were not initializing this status
			 response value.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_ConfigLoopbackType(
			HANDLE hResourceContext, unsigned short iLoopbackType );

	/******************************************************************************/
	/**
	GSM BER, perform a handover operation.  Before using this function, FTM_GSM_BER_StartCall()
	should be completed successfully and if a CMU-200 is being used, the "connect"
	command should be sent it.

	This command can e used in place of FTM_GSM_BER_AssignBCCH() and FTM_GSM_BER_AssignTraffic()
	within the same session, in order to begin a traffic connection for the 1st time in a session.

	It can also be used to perform a handover to a new band, once the first channel of GSM non-signaling
	traffic has been setup.

		These low-level FTM operations are called and the associated events are verifed:
			CHANNEL_ RECONFIGURE_REQ

	Note: even though the loopback type is a parameter, it is not used right now for optimization
	      reasons.  If a loopback is assigned before the handover it will be kept active after the
		  handover is completed.  QLIB_FTM_GSM_ConfigLoopbackType() can be used to control the
		  loopback separately from this handover command.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iChannel = RF channel. Valid range depends on band.
	\param iBand
		\code
          0 = PGSM 900 = FTM_GSM_BER_PGSM_900
          1 = EGSM 900 = FTM_GSM_BER_EGSM_900
          2 = PCS 1900 = FTM_GSM_BER_PCS_1900
          3 = DCS 1800 = FTM_GSM_BER_DCS_1800
          4 = CELL 850 = FTM_GSM_BER_CELL_850
		\endcode
	\param iTSC = Training Sequence number (0-7).  The same number is used for both UL and DL.
	\param iSlot = Slot - TCH slot:
		\code
          0 = Slot 0
          1 = Slot 1
          2 = Slot 2
          3 = Slot 3
          4 = Slot 4
          5 = Slot 5
          6 = Slot 6
          7 = Slot 7
		\endcode
		NOTE: NOTE When using a BCCH+TCH simultaneous configuration (required), not all slots
		will be available for the TCH.

	\param iMode
		\code
          0 = SPEECH - FULL RATE = FTM_GSM_BER_SPEECH_FULL_RATE
          1 = SPEECH - HALF RATE = FTM_GSM_BER_SPEECH_HALF_RATE
          2 = SPEECH - ENHANCED FULL RATE = FTM_GSM_BER_SPEECH_ENHANCED_FULL_RATE
          3 = AMR - FULL RATE = FTM_GSM_BER_AMR_FULL_RATE
          4 = AMR - HALF RATE = FTM_GSM_BER_AMR_HALF_RATE
          5 = DATA - 14.4 KBPS FULL RATE = FTM_GSM_BER_DATA_14_4_KBPS_FULL_RATE
          6 = DATA - 9.6 KBPS FULL RATE FTM_GSM_BER_DATA_9_6_KBPS_FULL_RATE
		\endcode
		NOTE: Options 1-6 may not be supported by the FTM software.

	\param iPowerLevel = the new PCL to set the Tx level to
		\param iLoopbackType (uses FTM_GSM_BER_LoopbackType_Enum)
			\code
			  0 = Disable Loopback = FTM_GSM_BER_Disable_Loopback
			  1 = Loopback Type A  = FTM_GSM_BER_Loopback_Type_A
			  2 = Loopback Type B  = FTM_GSM_BER_Loopback_Type_B
			  3 = Loopback Type C  = FTM_GSM_BER_Loopback_Type_C
			\endcode

	\param iStatus
		\code
          0 = Success (DIAG_FTM_STATUS_SUCCESS)
          1 = Failure (DIAG_FTM_STATUS_FAIL)
		\endcode

	\return true if all operations succeeded and the correct event messages were received

	\warning The active log mask will be changed to log only log FTM2 log packets.
	         When the function is completed, the state of ASYNC logging will be enabled.

			 In an automated sequence, if a call has already been established one time then
			 QLIB_FTM_GSM_BER_IsTrafficValid should be called after issuing this command
			 in order to verify that the traffic channel is currently active.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_Handover(
			HANDLE hResourceContext,
			unsigned short iChannel, unsigned char iBand, unsigned char iTSC, unsigned char iSlot,
			unsigned char iMode, unsigned char iPowerLevel,
			unsigned char  iLoopbackType
			);


	/******************************************************************************/
	/**
	GSM BER, perform a handover operation.  Before using this function, FTM_GSM_BER_StartCall()
	should be completed successfully and if a CMU-200 is being used, the "connect"
	command should be sent it.

	This command must also be preceded by successful calls to both FTM_GSM_BER_AssignBCCH() and
	FTM_GSM_BER_AssignTraffic() within the same session, in order to perform a handover to a new
	band, once the first channel of GSM non-signaling has been setup.

		This function calls these operations and checks for errors:
			FTM_GSM_CHANNEL_ASSIGN_REQ
			FTM_GSM_CONFIG_LOOPBACK_TYPE_REQ( DISABLE )
			FTM_CONFIG_LOOPBACK_TYPE_REQ( iLoopBackType )

	This version of the handover function does not change the loopback configuration.  This is an
	optimization for builds of AMSS for which the embedded software automatically handles the loopback
	configuration when the channel is reassigned.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iChannel = RF channel. Valid range depends on band.
	\param iBand
		\code
          0 = PGSM 900 = FTM_GSM_BER_PGSM_900
          1 = EGSM 900 = FTM_GSM_BER_EGSM_900
          2 = PCS 1900 = FTM_GSM_BER_PCS_1900
          3 = DCS 1800 = FTM_GSM_BER_DCS_1800
          4 = CELL 850 = FTM_GSM_BER_CELL_850
		\endcode
	\param iSlot = Slot - TCH slot:
		\code
          0 = Slot 0
          1 = Slot 1
          2 = Slot 2
          3 = Slot 3
          4 = Slot 4
          5 = Slot 5
          6 = Slot 6
          7 = Slot 7
		\endcode
		NOTE: NOTE When using a BCCH+TCH simultaneous configuration (required), not all slots
		will be available for the TCH.

	\param iMode
		\code
          0 = SPEECH - FULL RATE = FTM_GSM_BER_SPEECH_FULL_RATE
          1 = SPEECH - HALF RATE = FTM_GSM_BER_SPEECH_HALF_RATE
          2 = SPEECH - ENHANCED FULL RATE = FTM_GSM_BER_SPEECH_ENHANCED_FULL_RATE
          3 = AMR - FULL RATE = FTM_GSM_BER_AMR_FULL_RATE
          4 = AMR - HALF RATE = FTM_GSM_BER_AMR_HALF_RATE
          5 = DATA - 14.4 KBPS FULL RATE = FTM_GSM_BER_DATA_14_4_KBPS_FULL_RATE
          6 = DATA - 9.6 KBPS FULL RATE FTM_GSM_BER_DATA_9_6_KBPS_FULL_RATE
		\endcode
		NOTE: Options 1-6 may not be supported by the FTM software.

	\param iPowerLevel = the new PCL to set the Tx level to
		\param iLoopbackType (uses FTM_GSM_BER_LoopbackType_Enum)
			\code
			  0 = Disable Loopback = FTM_GSM_BER_Disable_Loopback
			  1 = Loopback Type A  = FTM_GSM_BER_Loopback_Type_A
			  2 = Loopback Type B  = FTM_GSM_BER_Loopback_Type_B
			  3 = Loopback Type C  = FTM_GSM_BER_Loopback_Type_C
			\endcode

	\param iStatus
		\code
          0 = Success (COMMAND_SUCCESS)
          1 = Failure (COMMAND_FAILED)
		\endcode

	\return true if all operations succeeded and the correct event messages were received

	\warning The active log mask will be changed to log only log FTM2 log packets.
	         When the function is completed, the state of ASYNC logging will be enabled.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_Handover_NoLoopbackConfig(
			HANDLE hResourceContext,
			unsigned short iChannel, unsigned char iBand, unsigned char iTSC, unsigned char iSlot,
			unsigned char iMode, unsigned char iPowerLevel
			);

	/******************************************************************************/
	/**
	GSM BER, Clear the internal status of the GSM BER structure

		Resets the contents of all fields in the internal GSM_BER_State state structure.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_ClearStatus( HANDLE hResourceContext );


	/******************************************************************************/
	/**
	GSM BER, Returns a copy of the internal GSM BER state. On the internal copy
	         it clears the "updated" fields for each message type so that the
			 next time this funciton is called. Only items that been received
			 since the first function call are marked as "updated."

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pGSM_BER_State = reference to a GSM_BER_State structure that will be  filled in with
	                        the state information

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_GetStatus( HANDLE hResourceContext, unsigned char* pGSM_BER_State );

	/******************************************************************************/
	/**
	GSM BER, Returns a simplified status of whether a specified event has occured.

	The function operations upon the bHasUpdated array held in the GSM BER status
	structure (data type GSM_BER_State, as defined in QLib_Defines.h).

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param eEventID = The input parameter is an index into this array, and the function
	                   returns a true if the event has occured and false if it has not.

		Data type is log_FTM2_GSM_BER_log_id_enum, defined in QLib_Defines.h

		Values are:
		\code
          LOG_FTM2_START_GSM_MODE_CNF       = 0 = Start GSM confirm
          LOG_FTM2_SELECT_SPECIFIC_BCCH_CNF = 1 = FTM GSM BER select specific BCCH confirmation
          LOG_FTM2_START_IDLE_MODE_CNF      = 2 = FTM GSM BER start idle mode confirmation
          LOG_FTM2_CHANNEL_ASSIGN_CNF       = 3 = FTM GSM BER channel assign confirmation
          LOG_FTM2_CHANNEL_RELEASE_CNF      = 4 = FTM GSM BER channel release confirmation
          LOG_FTM2_STOP_GSM_MODE_CNF        = 5 = FTM GSM BER stop GSM mode confirmation
          LOG_FTM2_PH_DATA_IND              = 6 = FTM GSM BER Ph data indication
          LOG_FTM2_FTM_LOG_GSM_BER_DED_RPT  = 7 = FTM GSM BER dedicated measurement report
		\endcode


	\param pGSM_BER_State = reference to a GSM_BER_State structure that will be
	                        filled in with the state information

	\return true the event type has occurred, false if it has not.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_GetEventStatus( HANDLE hResourceContext, unsigned char eEventID );

	/******************************************************************************/
	/**
	GSM BER, Returns the current Layer 1, RX Level.

	This function will wait until the next FTM_LOG_GSM_BER_DED_RPT message arrives,
	then return the status of that message.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piDED_RPtRxLev_Full = RxLev_Full as reported by Layer 1
	\param piDED_RPtRxQual_Full = RxQual_Full as reported by Layer 1


	More information about RX_QUAL:

	In brief, the mobile measures the Rx qual as defined in 3GPP 45.08.

	There are two rx qual thresholds calculated namely rx qual full and rx qual sub on the downlink
	radio bursts. These two measure the radio's downlink quality over a single reporting period and
	report the measurements to the network ( measurement reporting period is104 frames for tch channel)
	so that the network has some information as to 'how the mobile see's the downlink radio quality'.

	Rx qual full is where the mobile makes quality threshold measurements on all downlink burst, ie tch,
	facch and sacch blocks utilizing burst information from the equalizer output for all 104 bursts
	on the downlink.

	Rx Qual Sub is a sub set of these 104 bursts. This is where the mobile only uses for quality
	measurements the SACCH blocks and the Silent Identifier (SID) frames. This is the scenario where
	there is no speech or signaling frames on the downlink to measure the downlink quality. The mobile
	will always have information in these frames as the network will always send SACCH frames and if no
	signaling or speech frames to transmit then it sends SID frames at specific radio blocks instead of
	signaling or speech frames, these frames are identified as SID frames. This Rx Qual sub is therefore
	an accurate measure of the quality of the downlink on a subset of the 104 burst.

	Therefore in a measurement report from the mobile to the network, the rx qual full might be 7
	(ie poor) and the rx sub might be 0 (ie good) when no signaling/speech information is on the downlink.

	PRBS would imply signal being generated all the time and hence the rx qual full would be 0, ie a
	full set of downlink bursts to process.

	ECHO would imply some silence in the downlink and hence the rx qual full would be 7 as
	there is poor data to measure quality on

	\return true if all operations succeeded and the correct event messages were received

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_GetRxMetrics(
		HANDLE hResourceContext, unsigned char* piDED_RPtRxLev_Full, unsigned char* piDED_RPtRxQual_Full );

	/******************************************************************************/
	/**
	GSM BER, Returns the status of the GSM traffic channel

	Use this function after GSM TCH has been assigned.

	Will return true if the last PH_DATA_IND message for the SACCH type had a valid CRC_PASS
	AND if the SACCH accumulator is > 0.

	The SACCH accumulator begins at a value of 40 when QLIB_FTM_GSM_BER_ClearStatus() is
	called.  It is then decremented by 1 if an invalid SACCH CRC is reported and incremented
	by 2 for each valid SACCH CRC.  The accumulator will saturate at 0 on the low end
	and 40 on the high end.

	The user can change the maximum value (normally 40) by calling QLIB_FTM_GSM_BER_SetSACCH_AccumulatorMax()

	This specification for this logic comes from the 3GPP document 45.008, in the
	"radio link failure" section.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return pass/fail according to the rules above.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_IsTrafficValid(	HANDLE hResourceContext );

	/******************************************************************************/
	/**
	GSM BER, Sets the maximum value for the SACCH accumulator.

	See the description for QLIB_FTM_GSM_BER_IsTrafficValid() for how the accumulator
	works

	Default value in the system is 40.  This function does not need to be called unless
	the user desires a value other than 40.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSACCH_AccumulatorMax = new SACCH accumulator maximum value to be used for QLIB_FTM_GSM_BER_IsTrafficValid()

	\return true if successful, false if failure

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_SetSACCH_AccumulatorMax( HANDLE hResourceContext, short iSACCH_AccumulatorMax );

	/******************************************************************************/
	/**
	GSM BER, Release the GSM channel and optionally stop a GSM Non-signaling session.

		This low-level FTM operation is called and the associated event are verifed:
			CHANNEL_RELEASE_REQ

	\return true if all operations succeeded and the correct event messages were received

	\warning If further GSM BER sessions will occur before the phone is reset, then
	         the traffic loopback should be disabled using QLIB_FTM_GSM_ConfigLoopbackType()

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_ReleaseTCH( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	GSM BER, close the GSM Non-signaling session.

		This low-level FTM operation is called and the associated event are verifed:
			STOP_GSM_MODE_REQ

		Note: this command does not wait for the asynchronous stop responds because
		      some versions of software do not have this enabled and the response
			  is low priority for this commands, compared to other commands such
			  as traffice assign and handover.

		This function also calls QLIB_FTM_LOG_StopFTM_Log( HANDLE, LOG_FTM2_LOG_GSM_BER )
		to disable the FTM log that was started in QLIB_FTM_GSM_BER_StartSession

	\return true if all operations succeeded and the correct event messages were received

	\warning 1. This function will disable async logging and clear the async queue.
	         2. If further GSM BER sessions will occur before the phone is reset, then
	            the traffic loopback should be disabled using QLIB_FTM_GSM_ConfigLoopbackType()


	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_StopSession( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	GSM BER, Clear BER event status, Section 3.9 FTM Reset Event Status

		This command send FTM command to clear the event status.

		This command clears event status that is used for QLIB_FTM_GSM_BER_EVENT_STATUS_REQ function,

		This function could be called before the GSM BER function that generates the event.
		For example, QLIB_FTM_GSM_BER_AssignBCCH

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

		\param iStatus = 0 - COMMAND_SUCCESS
						 1 - COMMAND_FAILED
		\warning

		\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_EVENT_STATUS_CLEAR_REQ( HANDLE hResourceContext, unsigned short* iStatus );


	/******************************************************************************/
	/**
	GSM BER, Wait for event, Section 3.10

		This command waits for a specified GSM Layer 1 event to occur or until a timeout expires.
		This command is used to synchronize events so that use of the asynchronous messages are not required

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

		\param iEventType = See FTM_GSM_BER_EVENT_STATUS_Enum in QLib_Defines.h

							0 - FTM_GSM_BER_START_GSM_MODE_SYNC_STATUS
							1 - FTM_GSM_BER_SELECT_SPECIFIC_BCCH_CNF_SYNC_STATUS
							2 - FTM_GSM_BER_START_IDLE_MODE_SYNC_STATUS
							3 - FTM_GSM_BER_CHANNEL_ASSIGN_SYNC_STATUS
							4 - FTM_GSM_BER_CHANNEL_RELEASE_SYNC_STATUS
							5 - FTM_GSM_BER_STOP_GSM_MODE_SYNC_STATUS
							6 - FTM_GSM_BER_SACCH_SYNC_STATUS

		\param iTimeOut_ms = Timeout to use for waiting for the event. Units are milliseconds.

		\param iStatus =	0  FTM_GSM_BER_SYNC_STATUS_SUCCESS
							1  FTM_GSM_BER_SYNC_STATUS_GEN_FAILURE
							2  FTM_GSM_BER_SYNC_STATUS_TIMEOUT_EXPIRED
							3  FTM_GSM_BER_SYNC_STATUS_EVENT_STATUS_FAILED

		\warning

		\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_EVENT_STATUS_REQ(HANDLE hResourceContext,unsigned char iEventType, unsigned long iTimeOut_MS, unsigned short* iStatus);

	/******************************************************************************/
	/**
	GSM BER, Wait for event, Section 3.11

	This command returns the current receive power in RSSI and dBm.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iStatus =	0  Command Success
						1  Command Fail

	\param iRSSI	= RSSI value

	\param iRxPwr_in10dBm = Rx power in 1/10 dBm units.
	                        this is a signed number

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_BER_RX_LEVEL_REQ(HANDLE hResourceContext, unsigned short* iStatus, unsigned short *iRSSIValue, short* iRxPwr_in10dBm);


/******************************************************************************
						High level EGPRS BER FTM
*******************************************************************************/

	/******************************************************************************/
	/**
	The only difference	between this function and FTM_GSM_BER_AssignBCCH is that
	this function goes into EGRPS IDLE mode instead of GSM Idle mode.

    Before this function is called, FTM_GSM_BER_StartSession
	must be called.  When the function is completed, the phone will be in the IDLE
	state.

	This function must be called before FTM_EGPRS_BER_StartIdleMode

		These low-level FTM operations are called and the associated events are verifed:
			SELECT_SPECIFIC_BCCH_REQ
			FTM_EGPRS_BER_START_GPRS_IDLE_MODE_REQ

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iChannel = RF channel. Valid range depends on band.
		\param iBand
			\code
			  0 = PGSM 900 = FTM_GSM_BER_PGSM_900
			  1 = EGSM 900 = FTM_GSM_BER_EGSM_900
			  2 = PCS 1900 = FTM_GSM_BER_PCS_1900
			  3 = DCS 1800 = FTM_GSM_BER_DCS_1800
			  4 = CELL 850 = FTM_GSM_BER_CELL_850
			\endcode

	\return true if network session is setup successful, false if there are any failures

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_AssignBCCH(
		HANDLE hResourceContext, unsigned short iChannel, unsigned char iBand );

	/******************************************************************************/
	/**
	EGPRS BER, Start a EGPRS BER session by putting the phone into EGPRS Idle mode.
	Before this function is called, a valid	GSM BER session must be active.

		These low-level FTM operations are called and the associated events are verifed:
			FTM_EGPRS_BER_START_GPRS_IDLE_MODE_REQ

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if network session is setup successful, false if there are any failures

	\warning The active log mask will be changed to log only log FTM2 log packets.
	         When the function is completed, the state of ASYNC logging will be enabled.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_StartIdleMode( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	High level EGPRS BER, calls FTM_EGPRS_BER_CONFIGURE_DL_TBF, and checks the status of
	the command response.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iDL_TSC - Training sequence code for use on DL PDCH
	\param iDL_TFI - Expected temporary flow ID for use on DL PDCH. During the
	                SRB loop the UE actually ignores the received TFI, so this can
	                be fixed to 0.
	\param iChannel - Channel number for both downlink and uplink TBFs. Valid
	                  range depends on band.
	\param iBand - Band information for both downlink and uplink TBFs
		\code
           0 = PGSM 900
           1 = EGSM 900
           2 = PCS 1900
           3 = DCS 1800
           4 = CELL 850
		\endcode


	\param bFirstSlotActive - First active slot flag. unsigned charean to indicate if the timeslot configuration is valid.
	                          This should always be TRUE, since the feature currently supports	only one DL slot.

	\param iFirstSlotNum - First active timeslot number - Valid range is 0-7. This indicates the timeslot of the DL PDCH,
	                             and will only be read if first active slot flag is TRUE.

	\param bSecondSlotActive - Second active slot flag - unsigned charean to indicate if the timeslot configuration is valid. This
	                           should always be FALSE, since the feature does not currently
	                           support a 2 DL configuration.
	\param bSecondSlotNum - Second active timeslot number - Valid range is 0-7. This indicates the timeslot of the DL PDCH,
	                        and will only be read if second active slot flag is TRUE.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_Configure_DL_TBF(
				HANDLE hResourceContext,
				unsigned char iDL_TSC,
				unsigned char iDL_TFI,
				unsigned short iChannel,
				unsigned char iBand,
				unsigned char bFirstSlotActive,
				unsigned char iFirstSlotNum,
				unsigned char bSecondSlotActive,
				unsigned char iSecondSlotNum
				);


	/******************************************************************************/
	/**
	High level EGPRS BER, calls FTM_EGPRS_BER_CONFIGURE_UL_TBF, and checks the status of
	the command response.

	This command sends the configuration for the UL TBF to the UE. The embedded software will
	store this configuration for use when the SRB loop is established.

  	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iUL_TSC - Training sequence code for use on UL PDCH

	\param iUSF - Uplink state flag assigned to the UE. During the SRB loop the
	              UE actually ignores the received USF, so this can be set to 0.

	\param iGamma - GAMMA_TN value.  It is a basically sets the attenuation level relative to max power
	                for a band, in unts of 2dB.

				   Valid range is 0-31. This maps to the GAMMA_TN value in
	               3GPP TS 44.060. This sets the uplink power level based on the
                   equation given in 3GPP TS 45.008, section 10.2. The embedded software
                   uses an gamma parameter of 0.

                   The GAMMA_TN field is the binary representation of the parameter *CH for MS output
				   power control in units of 2 dB, see 3GPP TS 45.008. The GAMMA_TN field is coded
				   according to the following table:
		\code
         bit
         5 4 3 2 1
         0 0 0 0 0	*CH = 0 dB
         0 0 0 0 1	*CH = 2 dB
         : : : :
         1 1 1 1 0	*CH = 60 dB
         1 1 1 1 1	*CH = 62 dB
		\endcode

	\param bFirstSlotActive - First active slot flag. unsigned charean to indicate if the timeslot configuration is valid.
	                          This should always be TRUE, since the feature currently supports	only one DL slot.

	\param iFirstSlotNum - First active timeslot number - Valid range is 0-7. This indicates the timeslot of the DL PDCH,
	                             and will only be read if first active slot flag is TRUE.

	\param bSecondSlotActive - Second active slot flag - unsigned charean to indicate if the timeslot configuration is valid.
	                           This should always be FALSE, since the feature does not currently
	                           support a 2 DL configuration.
	\param bSecondSlotNum - Second active timeslot number - Valid range is 0-7. This indicates the timeslot of the DL PDCH,
	                        and will only be read if second active slot flag is TRUE.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_Configure_UL_TBF(
				HANDLE hResourceContext,
				unsigned char iUL_TSC,
				unsigned char iUSF,
				unsigned char iGamma,
				unsigned char bFirstSlotActive,
				unsigned char iFirstSlotNum,
				unsigned char bSecondSlotActive,
				unsigned char iSecondSlotNum
				);


	/******************************************************************************/
	/**
	High level EGPRS BER, calls FTM_EGPRS_BER_ESTABLISH_SRB_LOOPBACK, and handles all
	related events.

	After the DL and UL TBFs have been configured, the user should issue this command to establish
	the TBFs and close the SRB loop.

	Also calls QLIB_FTM_EGPRS_BER_ClearStatus() to clear all EGPRS status.

  	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_Establish_SRB_LOOPBACK( HANDLE hResourceContext );


	/******************************************************************************/
	/**
	High level EGPRS BER, calls FTM_EGPRS_BER_RELEASE_ALL_TBF, and handles all
	related events.

	This command directs the UE to release the UL and DL TBFs. This should only be issued when
	the UE is connected to the PDCH.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_Release_All_TBF( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	EGPRS BER, Clear the internal status of the EGPRS BER structure

		Resets the contents of all fields in the internal EGPRS_BER_State state structure.

  	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if all operations succeeded and the correct event messages were received

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_ClearStatus( HANDLE hResourceContext );


	/******************************************************************************/
	/**
	EGPRS BER, Returns a copy of the internal EGPRS BER state. On the internal copy
	         it clears the "updated" fields for each message type so that the
			 next time this funciton is called. Only items that been received
			 since the first function call are marked as "updated."

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pEGPRS_BER_State = reference to a EGPRS_BER_State structure that will be
	                        filled in with the state information.
							The structure type pointed to is EGPRS_BER_State

	\return true if all operations succeeded and the correct event messages were received

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_GetStatus(HANDLE hResourceContext, unsigned char* pEGPRS_BER_State );

   /******************************************************************************/
   /**
   High level EGPRS BER, calls FTM_EGPRS_BER_EXEC_VFS_REQ, and checks the status of
   the command response.

   \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

   \param  iNumSegments = Input, Number of segments
   \param  aiNumFramesInSeg = Input, List of Number of frames in segments
   \param  aiSegGamma = Input, List of Gamma of segments
   \param  aiSegBand = Input, List of Bands of Segments
   \param  aiSegChan = Input, List of Channel numbers of segments.

   \return true if successful, false if fail.

   \warning

   *******************************************************************************/
   QLIB_API unsigned char QLIB_FTM_EGPRS_BER_EXEC_VFS(
      HANDLE hResourceContext,
      unsigned char iNumSegments,
      unsigned char* aiNumFramesInSeg,
      unsigned char* aiSegGamma,
      unsigned char* aiSegBand,
      unsigned short*  aiSegChan
      );

   /******************************************************************************/
	/**
	EGPRS BER, Returns the current Layer 1, RX Level.

	This function will wait until the next FTM_LOG_EGPRS_BER_DED_RPT message arrives,
	then return the status of that message.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRxLev_average = RxLev_average as reported by Layer 1. Range should be 0-63.

	\return true if all operations succeeded and the correct event messages were received

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_GetRxMetrics( HANDLE hResourceContext, unsigned char* piRxLev_average );

   /******************************************************************************/
	/**
	EGPRS BER (80-V5529-1), Section 2.3.8, FTM Reset Event Status

	This command clears event status that is used for the FTM Wait For Event function.

	This function could be called before the EDGE BER function that generates the event. For
	example, before the FTM_EGPRS_BER_CONFIGURE_DL_TBF function described in section

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iStatus = 0 - COMMAND_SUCCESS
	                 1 - COMMAND_FAILED

	\return true if all operations succeeded and the correct event messages were received

	\warning

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_EVENT_STATUS_CLEAR_REQ ( HANDLE hResourceContext, unsigned short *iStatus);

  /******************************************************************************/
	/**
	EGPRS BER (80-V5529-1), Section 2.3.8, FTM Wait For Event

	This command waits for a specified GSM Layer 1 event to occur or until a timeout expires. This
	command is used to synchronize events so that use of the asynchronous messages are not
	required

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iEventType = Event for establishing/releasing UL/DL TBF
						
						See FTM_EGRPS_BER_EVENT_STATUS_Enum in QLib_Defines.h

						0  FTM_EGPRS_BER_UL_TBF_ESTABLISHED_SYNC_STATUS
						1  FTM_EGPRS_BER_UL_TBF_RELEASED_SYNC_STATUS
						2  FTM_EGPRS_BER_DL_TBF_ESTABLISHED_SYNC_STATUS
						3  FTM_EGPRS_BER_DL_TBF_RELEASED_SYNC_STATUS

    \param iTimeout_ms = Timeout to use for waiting for the event. Units are milliseconds.

	\param iStatus = Status whether the wait of success or not

						0 - FTM_EGPRS_BER_SYNC_STATUS_SUCCESS
						1  FTM_EGPRS_BER_SYNC_STATUS_GEN_FAILURE
						2  FTM_EGPRS_BER_SYNC_STATUS_TIMEOUT_EXPIRED
						3  FTM_EGPRS_BER_SYNC_STATUS_EVENT_STATUS_FAILED

	\return true if all operations succeeded and the correct event messages were received

	\warning

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_EVENT_STATUS_REQ ( HANDLE hResourceContext,
																 unsigned char iEvent_Type,
																 unsigned long iTimeout_ms,
																 unsigned short *iStatus);
	/******************************************************************************/
	/**
	GSM BER, Start a GSM BER session. (80-V3951-1, START_GSM_MODE_REQ)

	This function sends START_GSM_MODE_REQ command to mobile

	This command starts the GSM Layer 1 task from an inactive state. This initializes the Layer 1 subsystem and the drivers

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iStatus 0 == Command Success
				   1 == Command Failed

	\return	

	\note This function can be used in QMSL FTM Sequencer operation

	\wanrning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_START_MODE_REQ (HANDLE hResourceContext, unsigned short *iStatus);
	/******************************************************************************/
	/**
	GSM BER, Acquire BCCH (80-V3951-1, SELECT_SPECIFIC_BCCH_REQ)

	This function sends START_GSM_MODE_REQ command to mobile

	This command allows the user to acquire timing and decode BCCH data on a specific RF channel.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iStatus 0 == Command Success
				   1 == Command Failed

	\param iChannel = RF channel. Valid range depends on band.
		\param iBand
			\code
			  0 = PGSM 900 = FTM_GSM_BER_PGSM_900
			  1 = EGSM 900 = FTM_GSM_BER_EGSM_900
			  2 = PCS 1900 = FTM_GSM_BER_PCS_1900
			  3 = DCS 1800 = FTM_GSM_BER_DCS_1800
			  4 = CELL 850 = FTM_GSM_BER_CELL_850
			\endcode

	\return	

	\wanrning

	\note This function can be used in QMSL FTM Sequencer operation

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GSM_SELECT_SPECIFIC_BCCH_REQ(HANDLE hResourceContext, unsigned short iChannel, unsigned char iBand, unsigned short *iStatus);

	/******************************************************************************/
	/**
	EGPRS(EDGE) BER, Acquire BCCH (80-V5529-1, FTM_EGPRS_BER_START_GPRS_IDLE_MODE_REQ)

	This function sends FTM_EGPRS_BER_START_GPRS_IDLE_MODE_REQ command to mobile

	This command directs the UE to enter GPRS Idle mode. This should be done after the UE has successfully started GSM services and acquired the BCCH

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iStatus 0 == Command Success
				   1 == Command Failed

	\return	

	\wanrning

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/	
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_START_GPRS_IDLE_MODE_REQ(HANDLE hResourceContext, unsigned char* iStatus);
	/******************************************************************************/
	/**
	GSM BER, Stop a GSM BER session. (80-V3951-1, STOP_GSM_MODE_REQ)

	This function sends STOP_GSM_MODE_REQ to mobile

	This command stops the GSM Layer 1 services and returns the UE to the Inactive state. If the user has previously given a Start GSM mode request, the user must issue this command before proceeding to other FTM tests

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iStatus 0 == Command Success
				   1 == Command Failed

	\return	

	\wanrning

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/	
	QLIB_API unsigned char QLIB_FTM_GSM_STOP_GSM_MODE_REQ (HANDLE hResourceContext, unsigned short *iStatus);

	/******************************************************************************/
	/**
	EGPRS (EDGE) BER, 80-V5529-1, FTM_EGPRS_BER_CONFIGURE_DL_TBF

	This function sends FTM_EGPRS_BER_CONFIGURE_DL_TBF command to mobile

	This command sends the configuration for the DL TBF to the UE. The embedded software stores this configuration for use when the SRB loop is established using the FTM_EGPRS_BER_ESTABLISH_SRB_LOOPBACK command. This command must be sent before the FTM_EGPRS_BER_ESTABLISH_SRB_LOOPBACK command is sent. The channel selected should match the PDCH configuration on the test box and does not need to match the BCCH channel.
	This command should also be used to buffer a DL TBF configuration when the user needs to reconfigure the SRB loop (handover).

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iDL_TSC - Training sequence code for use on DL PDCH
	\param iDL_TFI - Expected temporary flow ID for use on DL PDCH. During the
	                SRB loop the UE actually ignores the received TFI, so this can
	                be fixed to 0.
	\param iChannel - Channel number for both downlink and uplink TBFs. Valid
	                  range depends on band.
	\param iBand - Band information for both downlink and uplink TBFs
		\code
           0 = PGSM 900
           1 = EGSM 900
           2 = PCS 1900
           3 = DCS 1800
           4 = CELL 850
		\endcode


	\param bFirstSlotActive - First active slot flag. unsigned charean to indicate if the timeslot configuration is valid.
	                          This should always be TRUE, since the feature currently supports	only one DL slot.

	\param iFirstSlotNum - First active timeslot number - Valid range is 0-7. This indicates the timeslot of the DL PDCH,
	                             and will only be read if first active slot flag is TRUE.

	\param bSecondSlotActive - Second active slot flag - unsigned charean to indicate if the timeslot configuration is valid. This
	                           should always be FALSE, since the feature does not currently
	                           support a 2 DL configuration.
	\param bSecondSlotNum - Second active timeslot number - Valid range is 0-7. This indicates the timeslot of the DL PDCH,
	                        and will only be read if second active slot flag is TRUE.

	\param iStatus 0 == Command Success
				   1 == Command Failed

	\return true if successful, false if fail.

	\warning

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/	
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_CONFIGURE_DL_TBF(			HANDLE hResourceContext,
																		unsigned char iDL_TSC,
																		unsigned char iDL_TFI,
																		unsigned short iChannel,
																		unsigned char iBand,
																		unsigned char bFirstSlotActive,
																		unsigned char iFirstSlotNum,
																		unsigned char bSecondSlotActive,
																		unsigned char iSecondSlotNum,
																		unsigned char* iStatus );
	/******************************************************************************/
	/**
	EGPRS (EDGE) BER, 80-V5529-1. FTM_EGPRS_BER_CONFIGURE_UL_TBF

	This function sends FTM_EGPRS_BER_CONFIGURE_UL_TBF command to mobile

	This command sends the configuration for the UL TBF to the UE. The embedded software stores this configuration for use when the SRB loop is established using the FTM_EGPRS_BER_ESTABLISH_SRB_LOOPBACK command. This command must be sent before the FTM_EGPRS_BER_ESTABLISH_SRB_LOOPBACK command is sent.
	This command should also be used to buffer a UL TBF configuration when the user needs to reconfigure the SRB loop (handover).

  	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iUL_TSC - Training sequence code for use on UL PDCH

	\param iUSF - Uplink state flag assigned to the UE. During the SRB loop the
	              UE actually ignores the received USF, so this can be set to 0.

	\param iGamma - GAMMA_TN value.  It is a basically sets the attenuation level relative to max power
	                for a band, in unts of 2dB.

				   Valid range is 0-31. This maps to the GAMMA_TN value in
	               3GPP TS 44.060. This sets the uplink power level based on the
                   equation given in 3GPP TS 45.008, section 10.2. The embedded software
                   uses an gamma parameter of 0.

                   The GAMMA_TN field is the binary representation of the parameter *CH for MS output
				   power control in units of 2 dB, see 3GPP TS 45.008. The GAMMA_TN field is coded
				   according to the following table:
		\code
         bit
         5 4 3 2 1
         0 0 0 0 0	*CH = 0 dB
         0 0 0 0 1	*CH = 2 dB
         : : : :
         1 1 1 1 0	*CH = 60 dB
         1 1 1 1 1	*CH = 62 dB
		\endcode

	\param bFirstSlotActive - First active slot flag. unsigned charean to indicate if the timeslot configuration is valid.
	                          This should always be TRUE, since the feature currently supports	only one DL slot.

	\param iFirstSlotNum - First active timeslot number - Valid range is 0-7. This indicates the timeslot of the DL PDCH,
	                             and will only be read if first active slot flag is TRUE.

	\param bSecondSlotActive - Second active slot flag - unsigned charean to indicate if the timeslot configuration is valid.
	                           This should always be FALSE, since the feature does not currently
	                           support a 2 DL configuration.
	\param bSecondSlotNum - Second active timeslot number - Valid range is 0-7. This indicates the timeslot of the DL PDCH,
	                        and will only be read if second active slot flag is TRUE.

	\param iStatus 0 == Command Success
				   1 == Command Failed

	\return true if successful, false if fail.

	\warning

	\note This function can be used in QMSL FTM Sequencer operation

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_CONFIGURE_UL_TBF(	HANDLE hResourceContext,
																unsigned char iUL_TSC,
																unsigned char iUSF,
																unsigned char iGamma,
																unsigned char bFirstSlotActive,
																unsigned char iFirstSlotNum,
																unsigned char bSecondSlotActive,
																unsigned char iSecondSlotNum,
																unsigned char* iStatus );
	/******************************************************************************/
	/**
	EGPRS (EDGE) BER, 80-V5529-1, FTM_EGPRS_BER_CONFIGURE_DL_TBF_V2

	This function sends FTM_EGPRS_BER_CONFIGURE_DL_TBF_V2 command to mobile

	This command sends the configuration for the DL TBF to the UE. This is Ver 2 of the configure DL TBF command, 
	which allows the configuration of more slots to support different EGPRS multislot classes. 
	The user must configure a valid DL and UL TBF according to the UEs multislot capability. 
	For example, in a class 10 UE, the user may not enable more than 4 DL slots using this command or more than 5 total slots (UL and DL).

	The embedded software stores this configuration for use when the SRB loop is established using the FTM_EGPRS_BER_ESTABLISH_SRB_LOOPBACK command. This command must be sent before the FTM_EGPRS_BER_ESTABLISH_SRB_LOOPBACK command is sent. The channel selected should match the PDCH configuration on the test box and does not need to match the BCCH channel.
	This command should also be used to buffer a DL TBF configuration when the user needs to reconfigure the SRB loop (handover).

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iDL_TSC - Training sequence code for use on DL PDCH
	\param iDL_TFI - Expected temporary flow ID for use on DL PDCH. During the
	                SRB loop the UE actually ignores the received TFI, so this can
	                be fixed to 0.
	\param iChannel - Channel number for both downlink and uplink TBFs. Valid
	                  range depends on band.
	\param iBand - Band information for both downlink and uplink TBFs
		\code
           0 = PGSM 900
           1 = EGSM 900
           2 = PCS 1900
           3 = DCS 1800
           4 = CELL 850
		\endcode

	\param pSlotConfiguration, pointer to the GSM_EGPRS_CONFIGURE_DL_TBF_V2_Slot_Configuration defined in QLib_Defines.h

	\param iStatus 0 == Command Success
				   1 == Command Failed

	\return true if successful, false if fail.

	\warning

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/	
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_CONFIGURE_DL_TBF_V2(		HANDLE hResourceContext,
																		unsigned char iDL_TSC,
																		unsigned char iDL_TFI,
																		unsigned short iChannel,
																		unsigned char iBand,
																		void * pSlotConfiguration,
																		unsigned short* iStatus );

	/******************************************************************************/
	/**
	EGPRS (EDGE) BER, 80-V5529-1, FTM_EGPRS_BER_CONFIGURE_UL_TBF_V2
	
	This function send FTM_EGPRS_BER_CONFIGURE_UL_TBF_V2 to the mobile

	This command sends the configuration for the UL TBF to the UE. This is Ver 2 of the configure UL TBF command, which allows the configuration of more slots to support different EGPRS multislot classes. 
	The user must configure a valid DL and UL TBF according to the UEs multislot capability.

	The embedded software stores this configuration for use when the SRB loop is established using the FTM_EGPRS_BER_ESTABLISH_SRB_LOOPBACK command. 
	This command must be sent before the FTM_EGPRS_BER_ESTABLISH_SRB_LOOPBACK command is sent.
	This command should also be used to buffer a UL TBF configuration when the user needs to reconfigure the SRB loop (handover).

  	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	
	\param iUL_TSC - Training sequence code for use on UL PDCH

	\param iUSF - Uplink state flag assigned to the UE. During the SRB loop the
	              UE actually ignores the received USF, so this can be set to 0.

	\param pSlotConfiguration, pointer to the GSM_EGPRS_CONFIGURE_UL_TBF_V2_Slot_Configuration defined in QLib_Defines.h

	\param iStatus 0 == Command Success
				   1 == Command Failed

	\return true if successful, false if fail.

	\warning

	\note This function can be used in QMSL FTM Sequencer operation

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_CONFIGURE_UL_TBF_V2(	HANDLE hResourceContext,
																unsigned char iUL_TSC,
																unsigned char iUSF,
																void * pSlotConfiguration,
																unsigned short* iStatus );

	/******************************************************************************/
	/**
	EGPRS (EDGE) BER, 80-V5529-1, FTM_EGPRS_BER_ESTABLISH_SRB_LOOPBACK
	
	This function sends FTM_EGPRS_BER_ESTABLISH_SRB_LOOPBACK command to mobile

	After the DL and UL TBFs have been configured, the user should issue this command to establish the TBFs and close the SRB loop

	\param iStatus 0 == Command Success
				   1 == Command Failed

	\return true if successful, false if fail.

	\warning

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_ESTABLISH_SRB_LOOPBACK (HANDLE hResourceContext, unsigned char* iStatus);

	/******************************************************************************/
	/**
	EGPRS (EDGE) BER, 80-V5529-1, FTM_EGPRS_BER_RELEASE_ALL_TBF
	
	This function send FTM_EGPRS_BER_RELEASE_ALL_TBF to the mobile

	This command directs the UE to release the UL and DL TBFs. This should only be issued when the UE is connected to the PDCH

	\param iStatus 0 == Command Success
				   1 == Command Failed

	\return true if successful, false if fail.

	\warning

	\note This function can be used in QMSL FTM Sequencer operation

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_EGPRS_BER_RELEASE_ALL_TBF(HANDLE hResourceContext, unsigned char* iStatus);
	
	
	/******************************************************************************
	UMTS Single Ended BER FTM
	*******************************************************************************/
	/******************************************************************************/
	/**
	Factory Test Mode Commands to start the SE BER logging

	This command starts the SE BER Logging.
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iFramesPerLog  = Number of Frames per each log.
	The UE will send a BER log packet every time it has processed iFramesPerLog number of received data blocks.
	8 -- Send a BER log packet every 8 data blocks processed.
	16 -- Send a BER log packet every 16 data blocks processed.
	32 -- Send a BER log packet every 32 data blocks processed.
	64 -- Send a BER log packet every 64 data blocks processed.

	\return true if successful, false if fail.

	\warning It is preferable to use the high-level function, QLIB_FTM_SE_BER_Start_Log(), which also handles changing the Log mask

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SE_BER_START_LOG_REQUEST( HANDLE hResourceContext,unsigned short iFramesPerLog );

	/******************************************************************************/
	/**
	Factory Test Mode UMTS Commands Stop BER Logging

	This command stops BER Logging.
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning It is preferable to use the high-level function, QLIB_FTM_SE_BER_Stop_Log(), which also handles changing the Log mask

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SE_BER_STOP_LOG_REQUEST( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Factory Test Mode UMTS Commands Configure SE BER Log Request

	This command sets the required parameters to configure the Log request.
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iPnSeqType  =
	PN sequence sent over DL traffic channel by test box.  The UE uses the ITU-T O.150 recommendation for
	generation of PN data, and assumes the test box does as well.
	\code
	1 - PN9 sequence (length 511)
	2 - PN11 sequence (length 2047)
	3 - PN15 sequence (length 32767)
	\endcode

	\param ber_mode (Hard Coded to 3) in the command
	\code
	0 -- Reserved
	1 - ACQUIRE_RUN.  The UE will perform the acquisition step on every received data block from
	the physical layer.	If acquisition is successful, the UE will compute BER statistics on the
	remaining bits in the block.  This is a test feature only.
	2 - Reserved
	3 - AUTO.  The UE will perform acquisition, and then operate in steady state BER calculation
	mode.  The UE will also perform sync-loss detection, and automatically return to the acquisition
	state if necessary
	\endcode

	\param bPnInverted = Is the output of the shift register inverted.
	\code
	0 - Do not invert PN sequence (typical for PN9 and PN11)
	1 - Invert PN sequence.  The ITU-T O.150 recommendation indicates that for PN15, the output
	of the shift register, which defines the actual PN sequence, should be inverted.  Not all
	test boxes conform to this recommendation.  If the test box conforms for PN15, this field
	should be 1.  If the test box does not conform, this field should be 0.
	\endcode

	\param iAcqThreshold = Number of error free bits that must be detecting before acquire is a success.

	During acquisition, the UE will seed a local PN generator with the received data, and attempt to
	correlate the next set of received bits with the output of the local PN generator.  This exploits
	the properties of PN sequences generated by a shift register.  The acq_threshold defines the number
	of error free bits that must be detected before declaring the acquisition process successful and the
	UE to be synchronized to the PN stream. The UE will perform acquisition on a single data block at
	a time, so it is important that the user understand the data sizes for different non-signaling test cases.
	GSM Loop A/B (Full Rate speech): data block size = 260 bits
	GSM Loop C: data block size = 114 bits
	EGPRS SRB, MCS1-4: data block size = 114 bits
	EGPRS SRB, MCS5-6: data block size = 312 bits
	The FTM SE BER module does not support MCS7-9.   This is because there are only 306 usable data bits
	per burst.  Since the modulation type is the same (8PSK), it is therefore better to use MCS5/6
	exclusively.  The FTM SE BER module will always assume a MCS5/6 burst structure when 8PSK modulation
	is used.
	WCDMA RMC 12.2K: data block size = 244 bits

	\param iAcqLostWm  = Watermark for losing synchronization.
	If the number of errors in a received data block exceeds this threshold, the SE BER module will
	declare a sync lost condition and return to the acquisition state.  The SE BER log packet will
	indicate whether the module is in sync or not for each data block received.

	\return true if successful, false if fail.

	\warning It is preferable to use the high-level function, QLIB_FTM_SE_BER_Start_Log(), which also handles changing the Log mask

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SE_BER_CONFIGURE_REQUEST(
								HANDLE hResourceContext,
								unsigned short iPnSeqType,
								unsigned char bPnInverted,
								unsigned short iAcqThreshold,
								unsigned short iAcqLostWm );

	/******************************************************************************/
	/**
	This command clears the SE BER status vector for a given Loopback Type and zeroes the SE_BER_State structure .
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iSE_BER_Loopback_Type = SE_BER_LoopbackType
	\code
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_WCDMA_RMC122K,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_WCDMA_RMC64K,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_GSM_C,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_EGPRS_SRB_1_4,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_EGPRS_SRB_5_6,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_GSM_A,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_GSM_B
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_WCDMA_RMC384K
	\endcode
	Types are supported.

	\return true if successful, false if fail.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SE_BER_ClearStatus(
								HANDLE hResourceContext,
								unsigned long iSE_BER_Loopback_Type );

	/******************************************************************************/
	/**
	This command Measures the SE BER value for a given Loopback Type and updates the pSE_BER_State pointer instantaneously.
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pSE_BER_State  = Pointer the SE_BER_State structure

	\param iSE_BER_Loopback_Type = SE_BER_LoopbackType
	\code
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_WCDMA_RMC122K,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_WCDMA_RMC64K,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_GSM_C,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_EGPRS_SRB_1_4,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_EGPRS_SRB_5_6,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_GSM_A,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_GSM_B,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_WCDMA_RMC384K
	\endcode
	Types are supported.

	\return true if successful, false if fail.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SE_BER_GetStatus(
								HANDLE hResourceContext,
								void* pSE_BER_State,
								unsigned long iSE_BER_Loopback_Type );

	/******************************************************************************/
	/**
	This command Measures the SE BER value for a give Loopback Type and updates the pSE_BER_State pointer.
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pSE_BER_State  = Pointer the SE_BER_Status structure defined in QLib_Defines.h

	\param iSE_BER_Loopback_Type = SE_BER_LoopbackType
	\code
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_WCDMA_RMC122K,  (12.2k)
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_WCDMA_RMC64K,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_GSM_C,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_EGPRS_SRB_1_4,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_EGPRS_SRB_5_6,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_GSM_A,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_GSM_B,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_WCDMA_RMC384K
	\endcode
	Types are supported.

	\param iMeasurementCount = Number of bits to be collected for each SE BER measurement.

	\param iTimeOut_ms =  Time out duration before exiting the SE BER measurement.

	\return true if successful, false if fail.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SE_BER_DoMeasurement(
								HANDLE hResourceContext,
								void *pSE_BER_State,
								unsigned long iSE_BER_Loopback_Type,
								unsigned long iMeasurementCount,
								unsigned long iTimeOut_ms );

	/******************************************************************************/
	/**
	High level function to start SE BER Logs, including setting the diagnostic log mask

	Calls these functions:
	\code
        QLIB_FTM_SE_BER_ClearStatus()
        QLIB_FTM_SE_BER_START_LOG_REQUEST()
        QLIB_FTM_SE_BER_CONFIGURE_REQUEST()
        QLIB_FTM_LOG_StartFTM_Log()
	\endcode


	\param iFramesPerLog  = Number of Frames per each log.
	The UE will send a BER log packet every time it has processed iFramesPerLog number of received data blocks.
	8 -- Send a BER log packet every 8 data blocks processed.
	16 -- Send a BER log packet every 16 data blocks processed.
	32 -- Send a BER log packet every 32 data blocks processed.
	64 -- Send a BER log packet every 64 data blocks processed.

	\param iPnSeqType  =
	PN sequence sent over DL traffic channel by test box.  The UE uses the ITU-T O.150 recommendation for
	generation of PN data, and assumes the test box does as well.
	\code
	1 - PN9 sequence (length 511)
	2 - PN11 sequence (length 2047)
	3 - PN15 sequence (length 32767)
	\endcode

	\param ber_mode (Hard Coded to 3) in the command
	\code
	0 -- Reserved
	1 - ACQUIRE_RUN.  The UE will perform the acquisition step on every received data block from
	the physical layer.	If acquisition is successful, the UE will compute BER statistics on the
	remaining bits in the block.  This is a test feature only.
	2 - Reserved
	3 - AUTO.  The UE will perform acquisition, and then operate in steady state BER calculation
	mode.  The UE will also perform sync-loss detection, and automatically return to the acquisition
	state if necessary
	\endcode

	\param bPnInverted = Is the output of the shift register inverted.
	\code
	0 - Do not invert PN sequence (typical for PN9 and PN11)
	1 - Invert PN sequence.  The ITU-T O.150 recommendation indicates that for PN15, the output
	of the shift register, which defines the actual PN sequence, should be inverted.  Not all
	test boxes conform to this recommendation.  If the test box conforms for PN15, this field
	should be 1.  If the test box does not conform, this field should be 0.
	\endcode

	\param iAcqThreshold = Number of error free bits that must be detecting before acquire is a success.

	During acquisition, the UE will seed a local PN generator with the received data, and attempt to
	correlate the next set of received bits with the output of the local PN generator.  This exploits
	the properties of PN sequences generated by a shift register.  The acq_threshold defines the number
	of error free bits that must be detected before declaring the acquisition process successful and the
	UE to be synchronized to the PN stream. The UE will perform acquisition on a single data block at
	a time, so it is important that the user understand the data sizes for different non-signaling test cases.
	GSM Loop A/B (Full Rate speech): data block size = 260 bits
	GSM Loop C: data block size = 114 bits
	EGPRS SRB, MCS1-4: data block size = 114 bits
	EGPRS SRB, MCS5-6: data block size = 312 bits
	The FTM SE BER module does not support MCS7-9.   This is because there are only 306 usable data bits
	per burst.  Since the modulation type is the same (8PSK), it is therefore better to use MCS5/6
	exclusively.  The FTM SE BER module will always assume a MCS5/6 burst structure when 8PSK modulation
	is used.
	WCDMA RMC 12.2K: data block size = 244 bits

	\param iAcqLostWm  = Watermark for losing synchronization.
	If the number of errors in a received data block exceeds this threshold, the SE BER module will
	declare a sync lost condition and return to the acquisition state.  The SE BER log packet will
	indicate whether the module is in sync or not for each data block received.

	\param iSE_BER_Loopback_Type = SE_BER_LoopbackType
	\code
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_WCDMA_RMC122K,  (12.2k)
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_WCDMA_RMC64K,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_GSM_C,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_EGPRS_SRB_1_4,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_EGPRS_SRB_5_6,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_GSM_A,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_GSM_B,
	LOG_FTM2_FTM_LOG_SE_BER_LB_TYPE_WCDMA_RMC384K
	\endcode


	\param iMCS = expected MCS
	\code
	0 - Reserved
	1 - MCS1 (invalid for SE BER)
	2 - MCS2 (invalid for SE BER)
	3 - MCS3 (invalid for SE BER)
	4 - MCS4 (invalid for SE BER)
	5 - MCS5 (UE Default Case)
	6 - MCS6
	7 - MCS7
	8 - MCS8
	9 - MCS9
	\endcode

	Clears SE BER STATUS
	Configures SE BER MEASUREMENT
	Sends SE BER LOG REQUEST
	Sends FTM LOG REQUEST
	\return true if successful, false if fail.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SE_BER_Start_Log(
								HANDLE hResourceContext,
								unsigned short iFramesPerLog,
								unsigned short iPnSeqType,
								unsigned char bPnInverted,
								unsigned short iAcqThreshold,
								unsigned short iAcqLostWm,
								unsigned long iSE_BER_Loopback_Type,
								unsigned short iMCS );

	/******************************************************************************/
	/**
	High level function to stop SE BER Logs.

	Calls QLIB_FTM_SE_BER_STOP_LOG_REQUEST and sets up diagnostic log mask to enable the FTM log

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SE_BER_Stop_Log( HANDLE hResourceContext);

	/******************************************************************************/
	/**
	High Level function which calls FTM_SE_BER_CONFIGURE_BIT_REORDERING to configure the
	bit re-ordering based the Call box.
	The user must select which ordering the test box uses, so FTM can properly
	arrange the bits for PN synchronization and classify the bits for Loop A/B
	processing.  This command should be sent prior to using the FTM SE BER Configure command.
	\param iBitOrder
	0 - Indicates to FTM that the test box applies the PN data at the input to the channel
	codec stage (after bit rearranging).  FTM treats this case as the default.
	1 - Indicates to FTM that the test box applies the PN data at the output of the vocoder
	(prior to bit rearranging)

	\return true if successful, false if fail.
	*******************************************************************************/
	QLIB_API unsigned char  QLIB_FTM_SE_BER_Configure_Bit_Reordering(
									HANDLE hResourceContext,
									unsigned short iBitOrder);

	/******************************************************************************/
	/**
	High Level function which calls FTM_SE_BER_CONFIGURE_EDGE_EXPECTED_MCS to set the
	expected EDGE MCS.
	\param iMCS = expected MCS
	\code
	0 - Reserved
	1 - MCS1 (invalid for SE BER)
	2 - MCS2 (invalid for SE BER)
	3 - MCS3 (invalid for SE BER)
	4 - MCS4 (invalid for SE BER)
	5 - MCS5 (UE Default Case)
	6 - MCS6
	7 - MCS7
	8 - MCS8
	9 - MCS9
	\endcode

	\return true if successful, false if fail.

	\note This function can be used in QMSL FTM Sequencer operation

	*******************************************************************************/
	QLIB_API unsigned char  QLIB_FTM_SE_BER_Configure_EDGE_Expected_MCS(
								HANDLE hResourceContext,
								unsigned short iMCS);

	/******************************************************************************/
	/**
	FTM Single-Ended BER API (80-VG331-1), Section 3.6, FTM SE BER Clear Synchronous Status

	This command clears the synchronous status of SE BER. The synchronous status is a simplified
	version of the SE BER, which stores BER/BLER failure statistics without context of the data
	channel configuraiton

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
	QLIB_API unsigned char  QLIB_FTM_SE_BER_CLEAR_SYNC_STATUS( HANDLE hResourceContext, unsigned short* iStatus );

	/******************************************************************************/
	/**
	FTM Single-Ended BER API (80-VG331-1), Section 3.7, FTM SE BER Get Synchronous Status

	This command returns the synchronous status of SE BER.
	The synchronous status is a simplified version of the SE BER, which stores BER/BLER failure
	statistics without context of the data channel configuration. For example BER from all GSM
	loops are handled by a single set of accumulators for the number of bits and the number of bit
	errors.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param dBER = Bit Error Rate (iTotal_Bit_Errors/iTotal_Bits * 100)
	              999.0 is returned if the target does not support the command

	\param iTotal_Bits = Total number of bits that have occurred since FTM_SE_BER_CLEAR_SYNC_STATUS was called

	\param iTotal_Bit_Errors = Total number of bit errors that have occurred since FTM_SE_BER_CLEAR_SYNC_STATUS was called.

	\param iStatus =	0 -COMMAND_SUCCESS
						1 -COMMAND_FAILED

	\return true if successful, false if fail.

	\note This function can be used in QMSL FTM Sequencer operation

	In Sequencer operation, dBER is not updated.  User must calculate dBER based on iTotal_Bits and iTotal_Bits_Errors
	*******************************************************************************/
	QLIB_API unsigned char  QLIB_FTM_SE_BER_GET_SYNC_STATUS (HANDLE hResourceContext,
															 unsigned long *iTotal_Bits,
															 unsigned long *iTotal_Bit_Errors,
															 double* dBER,
															 unsigned short *iStatus);

/******************************************************************************

GSDI Diag
*******************************************************************************/

	/******************************************************************************/
	/**
	GDSI ICD, 4.16  DELAYED RESPONSE: GSDIDIAG_ROOT_KEY_WRITE_CMD

	This function is used to write the root key to the FLASH.

	This function handles the delayed response message and the return values are
	taken from delayed asynchronous message, not the first response message.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = Input, SLOT_ID - Slot number for the SIM for which this information
	                 needs retrieved. Values applicable to dual slot targets are:
		\code
            0x01 - SLOT 1
            0x02 - SLOT 2
		\endcode
		For single slot targets, slot number should be None.

	\param iSIM_AppIdLen = Input, Length of the Application ID from which to retrieve information;
	                      set to Length = 0 when not used. Be sure to set this to 0 when not
                          used. Optional and applicable only to USIM. For a USIM, this implies
						  that the USIM ADF is to be selected by default as necessary.
						  Note: When using GSM cards and RUIM cards, set this to 0.

	\param piSIM_AppId = Input, Optional and applicable only to USIM.
					   USIM application identifier (APP ID); should only be used when the
					   Card is a UICC with application directory files (ADFs)
					   The APP IDs are retrieved from the USIM file EF-DIR.
					   Set bytes [1 to 16] to 0x00 for GSM cards and RUIM cards.

					   If this is not used, then set value to NULL, otherwise, must be 16 bytes long.


  	\param iRootKeyLen = Input, # of bytes used by the root key,
	\param piRootKeyData = Input, storage area of the root key, must be a valid pointer to
	                       "iRootKeyLen" number of bytes.

	\param piCommandStatus = Output, Command status is set to GSDI_SUCCESS if APS_AS_TRANSPORT is
	                        set to 1.Otherwise it is set to the status returned by GSDI

							This value is not valid if the function returns a false.


	\param piStatus = Output, status code returned by the delayed response GSDI.
                     These are the codes returned in the CDM_STATUS fields of Events.

                     This value is not valid if the function returns a false.
	\code
         0	- COMMAND COMPLETED SUCCESSFULLY
         1	- GENERAL ERROR:  No other information specified
         2	- ACCESS DENIED:  Security Procedures performed thus far don't satisfy restrictions
         3	- NOT FOUND:  SIM Elementary File or Directory File was not found.
         4	- INCOMPATIBLE PIN STATUS:  Trying to perform a PIN Action for a PIN that is not in the correct state.
		      For example, trying to Disable an already Disabled PIN.
         5	- INCORRECT CODE:  The Code provided is incorrect for the PIN ID used.
         6	- CODE BLOCKED:  The Number of retries has been exceeded and the PIN is now blocked.
         7	- INCREASE IMPOSSIBLE:  The INCREASE Command has failed due to a Bad Value
         8	- INCORRECT PARAMETERS:  The SIM detected an incorrect parameter for the action performed.
         9	- NOT SUPPORTED:  Not allowed by GSDI due to Service Table Values
         10	- NOT INIT:  Cache has not been INIT
         11	- SUCCESS BUT ILLEGAL SIM:  The SIM has been marked as an illegal SIM for the network,
		      but the actions are succeeding on the SIM.
         12	- RESERVED
         13	- RESERVED
         14	- SIM TECHNICAL PROBLEMS:  The SIM malfunctioned.
         15	- NO EF SELECTED:  Attempted to read a file without fist selecting it.
         16	- EF INCONSISTENT:  Trying to Read a Record when the file is a Binary or similar type error.
         17	- RESERVED
         18	- UNKNOWN INST CLASS:  Trying to send a UICC Command to a GSM/RUIM Card or vice versa.
         19	- RESERVED
         20	- RESERVED
         21	- INCORRECT LENGTH:  A Bad length was provided in the command.
         22	- DRIVERS TIMED OUT:  The Drivers communicating with the Card Timed Out.
         23	- CODE PERM BLOCKED:  The Unblock Code has been blocked.  Need Administrative assistance to unblock it.
         24	- RESERVED
         25	- RESERVED
         26	- RESERVED
	\endcode


	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_ROOT_KEY_WRITE_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_AppIdLen,
			unsigned char * piSIM_AppId,
			unsigned long iRootKeyLen,
			unsigned char * piRootKeyData,
			unsigned long* piCommandStatus,
			unsigned long* piStatus
		);

	/******************************************************************************/
	/**
	GDSI ICD, 4.17  DELAYED RESPONSE: GSDIDIAG_ROOT_KEY_READ_CMD

	This function is used to read the root key from the FLASH.

	This function handles the delayed response message and the return values are
	taken from delayed asynchronous message, not the first response message.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_AppIdLen = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param piSIM_AppId = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>

  	\param piRootKeyLen = Output, # of bytes used by the root key,
	\param piRootKeyData = Output, storage area of the root key, must be a valid pointer to
	                       at least 260 bytes.

	\param piCommandStatus = Output, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param piStatus = Output, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_ROOT_KEY_READ_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId, unsigned char iSIM_AppIdLen,
			unsigned char* piSIM_AppId,
			unsigned long* piRootKeyLen,
			unsigned char* piRootKeyData,
			unsigned long* piCommandStatus,
			unsigned long* piStatus
		);

	/******************************************************************************/
	/**
	GDSI ICD, 1.2.17  DELAYED RESPONSE: GSDIDIAG_SECURE_DEVICE_INFO_CMD

	This function is used to save IMEI, Serial Number to the Flash and perform
	the activation procedure.

	This function handles the delayed response message and the return values are
	taken from delayed asynchronous message, not the first response message.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_AppIdLen = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param piSIM_AppId = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>

	\param piCommandStatus = Output, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param piStatus = Output, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_SECURE_DEVICE_INFO_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_AppIdLen,
			unsigned char* piSIM_AppId,
			unsigned long* piCommandStatus,
			unsigned long* piStatus
		);

	/******************************************************************************/
	/**
	GDSI ICD, 4.15  DELAYED RESPONSE: GSDIDIAG_SIM_SECURE_STORE_CMD

	This function is used to store encrypted SIM lock data.

	This function handles the delayed response message and the return values are
	taken from delayed asynchronous message, not the first response message.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_AppIdLen = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param piSIM_AppId = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_SecureDataLen = input, size of sim secure buffer.  At most 1360 bytes
	\param piSIM_SecureData = input, buffer of SIM secure data, must be a minimum of
	                          "iSIM_SecureDataLen" bytes, at most 1360 bytes

	\param piCommandStatus = Output, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param piStatus = Output, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_SIM_SECURE_STORE_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_AppIdLen,
			unsigned char* piSIM_AppId,
			unsigned long iSIM_SecureDataLen,
			unsigned char* piSIM_SecureData,
			unsigned long* piCommandStatus,
			unsigned long* piStatus
		);

	/******************************************************************************/
	/**
	GDSI ICD, 4.18.2 GSDIDIAG_SECURE_READ_CMD response

	This function is used to read the encrypted SIM lock data.

	This function handles the delayed response message and the return values are
	taken from delayed asynchronous message, not the first response message.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_AppIdLen = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param piSIM_AppId = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>

	\param piSIM_SecureDataLen = output, return value of the number of bytes in the SIM secure data
	\param piSIM_SecureData = output, buffer to store the contents of the SIM secure data, at most 1360 bytes.

	\param piCommandStatus = Output, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param piStatus = Output, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_SIM_SECURE_READ_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_AppIdLen,
			unsigned char * piSIM_AppId,
			unsigned long*piSIM_SecureDataLen,
			unsigned char * piSIM_SecureData,
			unsigned long* piCommandStatus,
			unsigned long* piStatus
		);

	/******************************************************************************/
	/**
	GDSI ICD, 4.25  DELAYED RESPONSE: GSDIDIAG_ACTIVATE_ONCHIP_SIM_CMD

	ICD description:
	This function is used to activate Virtual SIM.

	This function handles the delayed response message and the return values are
	taken from delayed asynchronous message, not the first response message.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_AppIdLen = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param piSIM_AppId = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>

	\param piCommandStatus = Output, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param piStatus = Output, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\return true if successful, false if fail.

	\warning The SPC code must be sent to the phone first, using QLIB_DIAG_SPC_F()

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_ACTIVATE_ONCHIP_SIM_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_AppIdLen,
			unsigned char* piSIM_AppId,
			unsigned long* piCommandStatus,
			unsigned long* piStatus
		);

	/******************************************************************************/
	/**
	MMGDSI ICD, TBD Section,  DELAYED RESPONSE: MMGSDIDIAG_ACTIVATE_ONCHIP_SIM_CMD

	ICD description:
	This function is used to activate Virtual SIM.  There is a difference between the
	"GSDIDIAG" and "MMGSDIDIAG" commands.  The MMGSDI command also allows specifying
	the IMSI, Access Class, Admin data, LOCI, FPLMN, SST, and Phase.

	This function sends a fixed configuration on the data.  This is done because
	the ICD definition was not completed at the time of the function writing and
	it is a standard configuration, which can be used to make a call on most call processing
	equipment

	Then send the Activate ONCHIP SIM Data.
	\code
      send_data 0x80 0x21 0x48 0x00 0x01 0x00 0x00 0x00 0x83 0x00 0x00 0x00 0x01 0x10 0x00 0x00 0x00 0x00 0x00
                0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xbc 0xda 0xcd 0xab 0xcd 0xab 0xba 0xdc
				0x30 0x00 0x00 0x00 0x00 0x2D 0x00 0x02 0x09 0x08 0x09 0x10 0x10 0x10 0x32 0x54 0x76 0x98 0x07
				0x02 0xFB 0xF8 0x0A 0x04 0x81 0x00 0x01 0x02 0x03 0x0B 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x00
				0x00 0xFF 0x01 0x08 0x03 0xFF 0xFF 0xFF 0x06 0x04 0xFF 0xFF 0xFF 0xFF 0x09 0x01 0x03
      About the data:

      0x30 0x00 0x00 0x00           : Total length of the Activate ONCHIP SIM Payload data
      0x2D 0x00                     : Total Length of the TLV Data
      0x02 0x09 0x08 0x09 0x10 0x10 0x10 0x32 0x54 0x76 0x98               :  IMSI:  0x001 01 0123456789
      0x07 0x02 0xFB 0xF8           :  Access Class:
      0x0A 0x04 0x81 0x00 01 02     :  Administrative Data:
      0x03 0x0B 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x0x00 0x0x00 0xFF 0x01 :  LOCI
      0x08 0x03 0xFF 0xFF 0xFF      :  FPLMN
      0x06 0x04 0xFF 0xFF 0xFF 0xFF :  SST
      0x09 0x01 0x03                :  Phase

	\endcode


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\return true if successful, false if fail.

	\warning The SPC code must be sent to the phone first, using QLIB_DIAG_SPC_F()

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MMGSDIDIAG_ACTIVATE_ONCHIP_SIM_CMD_FixedConfig
		(
			HANDLE hResourceContext
		);

	/*
		GSDI commands with Event response.

		This group of commands has response packets which are in the form of "event"
		responses, rather than "delayed" responses.  The difference has to do with the
		type of packet that contains the response information.

		For this group, the process of getting response data is different from
		the delayed response types.  In addition to calling the GSDI request command,
		the function QLIB_GSDIDIAG_GetEventResponse() must be called to get the request
		response information.

		An example of this can be seen in QLibDemo.cpp, in the function Test_Security(),
		which calls QLIB_GSDIDIAG_GET_FEATURE_INDICATION_CMD()

		If the request command is not directly available in QMSL, it is possible to send
		the request directly using QLIB_GSDIDIAG_SendRequestWithEventResponse().  Then
		any command can be requested and the response can be captured with
		QLIB_GSDIDIAG_GetEventResponse().
	*/
	/******************************************************************************/
	/**

	Function to send any user defined "event response GSDI function"
	This funtion will enable the event capturing and prepare the proper header
	for the request packet:
		CMD_CODE
		SUBSYS_CODE
		SUBSYS_CMD_CODE
		SIM_SLOT_NUMBER

	The user must supply the remaining request parameters in the data buffer, pUserRequestData

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSUBSYS_CMD_CODE = GSDI command number, to be used for the field, SUBSYS_CMD_CODE, refer to
	                          enumeration, GSDI_DIAG_CMD_Enum.
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param pUserRequestData = all data after the SIM_SLOT_NUMBER field, NULL if there are no parameters
	\param iUserRequestDataSize = number of bytes to be sent in pUserRequestData, 0 if there are no parameters
	\param piTransactionID = Output, returned in order to identify the related event
	\param piCommandStatus = Output, result of CMD_STATUS field, if not GSDI_SUCCESS then the function returns a false.

	\return true if a valid event was found, matching the transaction ID and the event
			which were specified in iTransactionID and iEventID.


	\warning Before this function, one of the specific GSDI requests should be made
			(e.g. GSDIDIAG_VERIFY_PIN_CMD), or the generic event-based GSDI request
			should be made QLIB_GSDIDIAG_SendRequestWithEventResponse()



	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_SendUserDefineEventResponseCommand(
			HANDLE hResourceContext,
			unsigned short iSUBSYS_CMD_CODE,
			unsigned char iSlotId,
			void* pUserRequestData,
			unsigned short iUserRequestDataSize,
			unsigned short* piTransactionID,
			unsigned long* piCommandStatus
			);

	/******************************************************************************/
	/**

	Function used to get the event response for all GSDI functions which result
	in event responses.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iTransactionID = Input, the transaction ID returned by the request
	\param iEventID = Input, the event ID to wait for, e.g. EVENT_GSDI_GET_FEATURE_IND. For
	                  a wildcard event type, use QMSL_EVENT_ID_WILDCARD and any event will be
					  returned
	\param pEvent = a pointer to an event structure, QMSL_Event_Element_Struct.

					They "payload" field of this structure maps to a GSDIDIAG_EventHeader structure.


	\return true if a valid event was found, matching the transaction ID and the event
			which were specified in iTransactionID and iEventID.


	\warning Before this function, one of the specific GSDI requests should be made
			(e.g. GSDIDIAG_VERIFY_PIN_CMD), or the generic event-based GSDI request
			should be made QLIB_GSDIDIAG_SendRequestWithEventResponse()



	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_GetEventResponse(
			HANDLE hResourceContext,
			unsigned short iTransactionID,
			unsigned short iEventID,
			void* pEvent
			);

	/******************************************************************************/
	/**
	GDSI ICD, 2.6 GSDIDIAG_VERIFY_PIN_CMD

	ICD description:
		This command is used to verify the requested PIN. Currently used to verify PIN1/CHV1 or
		PIN2/CHV2. When the proper ID is supplied, it can be used to verify other PINs.
		This command will not need to Read/Write to EFS. Upon completion of this command, the result
		in EVENT_GSDI_SIM_VERIFY_PIN will send a status as well as the number of retries
		remaining.

	Related script command:  SIMVerifyPin

	  The QMSL function will currently >>not<< process the event that results from this
	  function call.  Use QLIB_GSDIDIAG_GetEventResponse() to get the response data, see
	  QLibDemo.cpp ->Test_Security() for an example of this.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_AppIdLen = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param piSIM_AppId = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_PIN_ID = input,
	  \code
       - 0x00 = PIN1 (SIM/RUIM) PIN1 Application 1 (USIM)
       - 0x01 = PIN2 (SIM/RUIM) PIN1 Application 2 (USIM)
       - 0x02 = PIN1 Application 3 (USIM)
       - 0x03 = PIN1 Application 4 (USIM)
       - 0x04 = PIN1 Application 5 (USIM)
       - 0x05 = PIN1 Application 6 (USIM)
       - 0x06 = PIN1 Application 7 (USIM)
       - 0x07 = PIN1 Application 8 (USIM)
       - 0x0A = ADM1
       - 0x0B = ADM2
       - 0x0C = ADM3
       - 0x0D = ADM4
       - 0x0E = ADM5
       - 0x11 = UNIVERSAL PIN
       - 0x81 = PIN2 Application 1 (USIM)
       - 0x82 = PIN2 Application 2 (USIM)
       - 0x83 = PIN2 Application 3 (USIM)
       - 0x84 = PIN2 Application 4 (USIM)
       - 0x85 = PIN2 Application 5 (USIM)
       - 0x86 = PIN2 Application 6 (USIM)
       - 0x87 = PIN2 Application 7 (USIM)
       - 0x88 = PIN2 Application 8 (USIM)
       - 0x8A = ADM6
       - 0x8B = ADM7
       - 0x8C = ADM8
       - 0x8D = ADM9
       - 0x8E = ADM10-
	 \endcode
	 \param sSIM_PIN = input, NULL terminated string containing pin
	\param piTransactionID = Output, returned in order to identify the related event
	\param piCommandStatus = Output, result of CMD_STATUS field, if not GSDI_SUCCESS then the function returns a false.

	\return true if successful, false if fail.

	\warning Will activate event messages and clear the current event queue

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_VERIFY_PIN_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_AppIdLen,
			unsigned char* piSIM_AppId,
			unsigned char iSIM_PIN_ID,
			char* sSIM_PIN,
			unsigned short* piTransactionID,
			unsigned long* piCommandStatus
		);

	/******************************************************************************/
	/**
	GDSI ICD, 2.3 GSDIDIAG_SIM_READ_CMD

	ICD description:
		This is used to retrieve information from a Cyclic/Binary/Record Elementary Files from SIM.
		The data retrieved will be in a raw and unparsed format. It is up to the user to parse the data per
		the following specification. All fields are mandatory unless they specifically indicate that they
		are optional.
		The command is processed and put onto the GSDI Task Command Queue. If the queuing of the
		command is successful, a response with a valid Transaction ID is provided. Check the Command
		Status and verify that it is non-zero before accepting the Transaction ID.
		At the completion of the Command Processing in the GSDI Task, an event is generated to notify
		the client that the contents of the request can now be accessed from the filename provided in the
		request.
		Disclaimer: The client must maintain the EFS filenames and ensure that the same filenames are
		not used without first retrieving the data.

	Related script command:  READ_BINARY

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_AppIdLen = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param piSIM_AppId = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_ElementaryFile = input, see enumeration defintion, GSDI_DIAG_SIM_ElementaryFile_Enum
	\param iSIM_SimpleReq = input, Represents if write parameters are user specified values, or
							the phone calculates appropriate values; also represents if the
							user has to deal with chunking:
	  \code
        0 = GSDIDIAG_SIM_SIMPLE_REQ_ONE_STEP, User specified values for SIM_INDEX_MODE, SIM_
            OFFSET, SIM_REC_NUM, SIM_DATA_LEN: user has to
            deal with chunking: for record based files, user has to
            specify SIM_REC_NUM
        1 = GSDIDIAG_SIM_SIMPLE_REQ_ALL_STEPS, Phone uses appropriate values; also returns the
            complete data in a file; user is transparent to chunking
	  \endcode
	\param iSIM_IndexMode = input, See GSDI_DIAG_IndexModes_Enum
	\param iSIM_Offset = Input, Range = 0 to 256, Set to 0 when an offset is not to be specified
	\param iSIM_RecNum = Input, Range = 0 to 500.  Set to 0 when a Record Number is not required;
							this will be the case when the file is either Cyclical or Binary/Transparent
	\param iSIM_DataLen = Input, Number of bytes to write
	\param sEFS_Filename = Input, Range = Variable; must be Null Terminated. File on EFS that the read data is to be stored in

	\param piTransactionID = Output, returned in order to identify the related event
	\param piCommandStatus = Output, result of CMD_STATUS field, if not GSDI_SUCCESS then the function returns a false.

	\return true if successful, false if fail.

	\warning Will activate event messages and clear the current event queue

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_SIM_READ_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_AppIdLen,
			unsigned char* piSIM_AppId,
			unsigned long iSIM_Elementary_File,
			unsigned char iSIM_SimpleReq,
			unsigned char iSIM_IndexMode,
			unsigned short iSIM_Offset,
			unsigned short iSIM_RecNum,
			unsigned short iSIM_DataLen,
			char* sEFS_Filename,
			unsigned short* piTransactionID,
			unsigned long* piCommandStatus
		);

	/******************************************************************************/
	/**

	GDSI ICD, 2.3.4 GSDIDIAG_SIM_WRITE_CMD

	ICD description:
	This command is used to store information on a Binary/Record Elementary Files in the
	SIM/USIM/RUIM. It is important that all relevant CHV/PIN(s) are considered and that all PIN
	Verification Procedures are performed prior to attempting a write. Otherwise, the write request
	will fail.
	The Command will result in a write to the EFS filename provided. The interface will then
	retrieve this information and write it to the SIM. EVENT_GSDI_SIM_WRITE is generated as a
	result of completion of this command.

	Related script command:  WRITE_BINARY

	  The QMSL function will currently >>not<< process the event that results from this
	  function call. Use QLIB_GSDIDIAG_GetEventResponse() to get the response data, see
	  QLibDemo.cpp ->Test_Security() for an example of this.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_AppIdLen = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param piSIM_AppId = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_ElementaryFile = input, see enumeration defintion, GSDI_DIAG_SIM_ElementaryFile_Enum
	\param iSIM_SimpleReq = input, Represents if write parameters are user specified values, or
							the phone calculates appropriate values; also represents if the
							user has to deal with chunking:
	  \code
        0 = User specified values for SIM_INDEX_MODE, SIM_
            OFFSET, SIM_REC_NUM, SIM_DATA_LEN: user has to
            deal with chunking: for record based files, user has to
            specify SIM_REC_NUM
        1 = Phone uses appropriate values; also returns the
            complete data in a file; user is transparent to chunking
	  \endcode
	\param iSIM_IndexMode = input, See GSDI_DIAG_IndexModes_Enum
	\param iSIM_Offset = Input, Range = 0 to 256, Set to 0 when an offset is not to be specified
	\param iSIM_RecNum = Input, Range = 0 to 500.  Set to 0 when a Record Number is not required;
							this will be the case when the file is either Cyclical or Binary/Transparent
	\param iSIM_DataLen = Input, Number of bytes to write
	\param sEFS_Filename = Input, Range = Variable; must be Null Terminated. File on EFS that the data is taken from.
	\param piTransactionID = Ouptut, returned in order to identify the related event
	\param piCommandStatus = Output, result of CMD_STATUS field, if not GSDI_SUCCESS then the function returns a false.

	\return true if successful, false if fail.

	\warning Will activate event messages and clear the current event queue

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_SIM_WRITE_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_AppIdLen,
			unsigned char* piSIM_AppId,
			unsigned long iSIM_Elementary_File,
			unsigned char iSIM_SimpleReq,
			unsigned char iSIM_IndexMode,
			unsigned short iSIM_Offset,
			unsigned short iSIM_RecNum,
			unsigned short iSIM_DataLen,
			char* sEFS_Filename,
			unsigned short* piTransactionID,
			unsigned long* piCommandStatus
		);

	/******************************************************************************/
	/**

	GDSI ICD, 2.4 GSDIDIAG_GET_FILE_ATTRIBUTES_CMD

	ICD description:
		This command, when called, will get an immediate response based on whether the command was
		successfully queued. The Command contents are as follows:

	Related script command:  GET_FILE_ATTR

 	  The QMSL function will currently >>not<< process the event that results from this
	  function call. Use QLIB_GSDIDIAG_GetEventResponse() to get the response data, see
	  QLibDemo.cpp ->Test_Security() for an example of this.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_AppIdLen = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param piSIM_AppId = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_ElementaryFile = input, see enumeration defintion, GSDI_DIAG_SIM_ElementaryFile_Enum

	\param sEFS_Filename = Input, Range = Variable; must be Null Terminated. File on EFS that the read data is to be stored in

	\param piTransactionID = Ouptut, returned in order to identify the related event
	\param piCommandStatus = Output, result of CMD_STATUS field, if not GSDI_SUCCESS then the function returns a false.

	\return true if successful, false if fail.

	\warning Will activate event messages and clear the current event queue

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_GET_FILE_ATTRIBUTES_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_AppIdLen,
			unsigned char* piSIM_AppId,
			unsigned long iSIM_Elementary_File,
			char* sEFS_Filename,
			unsigned short* piTransactionID,
			unsigned long* piCommandStatus
		);

	/******************************************************************************/
	/**

	GDSI ICD, 2.10 QLIB_GSDIDIAG_GET_AVAILABLE_APPS

	ICD description:
		This command is used to get applications available on a SIM card.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piNumSlots = number of slots reported
	\param pbSlot1Inserted = true if slot 1 has a card
	\param piSlot1Apps = bit mask of applications enabled on the slot 1 card,
						GSDI_DIAG_SIM_AppsList defines the bit mask values
	\param pbSlot2Inserted = true if slot 2 has a card
	\param piSlot2Apps = bit mask of applications enabled on the slot 2 card
						GSDI_DIAG_SIM_AppsList defines the bit mask values

	\return true if successful, false if fail.

	\warning The Slot 2 report has not been verified yet.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_GET_AVAILABLE_APPS
			(
				HANDLE hResourceContext,
				unsigned char* piNumSlots,
				unsigned char* piSlot1Inserted,
				unsigned char* piSlot1Apps,
				unsigned char* pbSlot2Inserted,
				unsigned char* piSlot2Apps
			);

	/******************************************************************************/
	/**

	GDSI ICD, 3.9 GSDIDIAG_ACTIVATE_FEATURE_INDICATOR_CMD

	ICD description:
		This command is used to activate the personalization feature indicator in SIM Lock feature. All
		fields are mandatory unless they specifically indicate that they are optional.
		The command is processed and put onto the GSDI Task Command Queue. So long as the
		queuing of the command is successful, a response with a valid Transaction ID is provided. Check
		the Command Status and verify it is successful before accepting the Transaction ID.
		At the completion of the Command Processing in the GSDI Task, an event is generated to notify
		the client.

	Related script command:  SIMActivateFeature

 	  The QMSL function will currently >>not<< process the event that results from this
	  function call. Use QLIB_GSDIDIAG_GetEventResponse() to get the response data, see
	  QLibDemo.cpp ->Test_Security() for an example of this.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_PersoFeature = input, see description of GSDI_DIAG_PersoFeature_Enum
	\param sSIM_PersoKey = input, Personalization Key Value; Input is in string format, NULL terminated

  	\param piTransactionID = Ouptut, returned in order to identify the related event
	\param piCommandStatus = Output, result of CMD_STATUS field, if not GSDI_SUCCESS then the function returns a false.

	\return true if successful, false if fail.

	\warning Will activate event messages and clear the current event queue

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_ACTIVATE_FEATURE_INDICATOR_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_PersoFeature,
			char* sSIM_PersoKey,
			unsigned short* piTransactionID,
			unsigned long* piCommandStatus
		);

	/******************************************************************************/
	/**

	GDSI ICD, 3.10 GSDIDIAG_DEACTIVATE_FEATURE_INDICATOR_CMD

	ICD description:
		This request message is used to deactivate the personalization feature indicator in SIM Lock
		feature. All fields are mandatory unless they specifically indicate that they are optional.
		The command is processed and put onto the GSDI Task Command Queue. So long as the
		queuing of the command is successful, a response with a valid Transaction ID is provided. Check
		the Command Status and verify it is successful before accepting the Transaction ID.
		At the completion of the Command Processing in the GSDI Task, an event is generated to notify
		the client.

	Related script command:  SIMDeactivateFeature

 	  The QMSL function will currently >>not<< process the event that results from this
	  function call. Use QLIB_GSDIDIAG_GetEventResponse() to get the response data, see
	  QLibDemo.cpp ->Test_Security() for an example of this.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_PersoFeature = input, see description of GSDI_DIAG_PersoFeature_Enum
	\param sSIM_PersoKey = input, Personalization Key Value; Input is in string format, NULL terminated

	\param piTransactionID = Ouptut, returned in order to identify the related event
	\param piCommandStatus = Output, result of CMD_STATUS field, if not GSDI_SUCCESS then the function returns a false.

	\return true if successful, false if fail.

	\warning Will activate event messages and clear the current event queue

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_DEACTIVATE_FEATURE_INDICATOR_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_PersoFeature,
			char* sSIM_PersoKey,
			unsigned short* piTransactionID,
			unsigned long* piCommandStatus
		);

	/******************************************************************************/
	/**

	GDSI ICD, 3.11 GSDIDIAG_GET_FEATURE_INDICATION_CMD

	ICD Description:
		This request message is used to get the various personalization feature indication with respect to
		SIM Lock feature. All fields are mandatory unless they specifically indicate that they are
		optional.
		The command is processed and put onto the GSDI Task Command Queue. So long as the
		queuing of the command is successful, a response with a valid Transaction ID is provided. Check
		the Command Status and verify it is successful before accepting the Transaction ID.
		At the completion of the Command Processing in the GSDI Task, an event is generated to notify
		the client.

	Related script command:  SIMGetFeatureIndicators

 	  The QMSL function will currently >>not<< process the event that results from this
	  function call. Use QLIB_GSDIDIAG_GetEventResponse() to get the response data, see
	  QLibDemo.cpp ->Test_Security() for an example of this.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>

	\param piTransactionID = Ouptut, returned in order to identify the related event
	\param piCommandStatus = Output, result of CMD_STATUS field, if not GSDI_SUCCESS then the function returns a false.

	\return true if successful, false if fail.

	\warning Will activate event messages and clear the current event queue

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_GET_FEATURE_INDICATION_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned short* piTransactionID,
			unsigned long* piCommandStatus
		);

	/******************************************************************************/
	/**

	GDSI ICD, 3.12 GSDIDIAG_SET_FEATURE_INDICATOR_DATA_CMD

	ICD Description:
		This request message is used to set the data for the corresponding personalization feature
		indicator that the mobile is required to compare to the SIM with. All fields are mandatory unless
		they specifically indicate that they are optional.
		The command is processed and put onto the GSDI Task Command Queue. So long as the
		queuing of the command is successfully, a response with a valid Transaction ID is provided.
		Check the Command Status and verify it is successful before accepting the Transaction ID.
		At the completion of the Command Processing in the GSDI Task, an event is generated to notify
		the client.

	Related script command:  SIMSetFeatureData

  	  The QMSL function will currently >>not<< process the event that results from this
	  function call. Use QLIB_GSDIDIAG_GetEventResponse() to get the response data, see
	  QLibDemo.cpp ->Test_Security() for an example of this.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_PersoFeature = input, see description of GSDI_DIAG_PersoFeature_Enum
	\param piSIM_PersoData = input, byte buffer
	\code
      Personalization Data Value. Input is in HEX
      representation + string format
      Formats of the data are:
      - Network personalization (multiple of 3 bytes)
	    As defined in IMSI, e.g.:
         - 44097(2 digits MNC) . >= 44F079
         - 440973 (3 digits MNC) >= 443079

      Network Subset personalization (multiple of 4 bytes)
      As defined in Network personalization + 6 and 7 bits in
      IMSI, e.g.;
          - 4409712 (2 digits MNC) >= 44F07921
          - 44097312 (3 digits MNC) >= 44307921

      Service Provider personalization (multiple of 5 bytes)
      MCC + MNC + bcd format of service provider code, e.g.:
        - MCC + MNC=44097, SP=6 >= 44F07960
        - MCC + MNC=440973, SP=12 >= 44307921

      Corporate personalization (multiple of 6 bytes)
      Network personalization + Service provider
      personalization representation + Corporate code in
      BCD format, e.g.:
        - MCC + MNC = 44097, SP = 13, CP = 17, >= 44F0793171
        - SIM/USIM personalization

      When multiple data entries are made for each
      personalization level data, each entry should follow the
      format indicated above and there should be no space in
      between entries

	\endcode
	\param iSIM_PersoDataSize = size of piSIM_PersonData, in bytes
	\param piTransactionID = Ouptut, returned in order to identify the related event
	\param piCommandStatus = Output, result of CMD_STATUS field, if not GSDI_SUCCESS then the function returns a false.

	\return true if successful, false if fail.

	\warning Will activate event messages and clear the current event queue

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_SET_FEATURE_INDICATOR_DATA_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_PersoFeature,
			unsigned char* piSIM_PersoData,
			unsigned short iSIM_PersoDataSize,
			unsigned short* piTransactionID,
			unsigned long* piCommandStatus
		);

		/******************************************************************************/
	/**

	GDSI ICD, 3.12 GSDIDIAG_GET_FEATURE_INDICATOR_DATA_CMD

	ICD Description:
		This is used to get the data for the corresponding personalization feature indicator data set
		in the module.  All fields are mandatory unless they specifically indicate that it is an optional field.
		The Command is processed and put onto the GSDI Task Command Queue.  So long as the Queuing of the
		command is successfully, a response with a valid Transaction ID is provided.  Please check the Command
		Status and verify it is successful before accepting the Transaction ID.
		At the completion of the Command Processing in the GSDI Task, an event is generated to notify the client.

	Related script command:  SIMSetFeatureData

  	  The QMSL function will currently >>not<< process the event that results from this
	  function call. Use QLIB_GSDIDIAG_GetEventResponse() to get the response data, see
	  QLibDemo.cpp ->Test_Security() for an example of this.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_PersoFeature = input, see description of GSDI_DIAG_PersoFeature_Enum
	\param sEFS_Filename = File at which the return PersoData will be stored at
	\param piTransactionID = Ouptut, returned in order to identify the related event
	\param piCommandStatus = Output, result of CMD_STATUS field, if not GSDI_SUCCESS then the function returns a false.

	\return true if successful, false if fail.

	\warning Will activate event messages and clear the current event queue

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_GET_FEATURE_INDICATOR_DATA_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_PersoFeature,
			char* sEFS_Filename,
			unsigned short* piTransactionID,
			unsigned long* piCommandStatus
		);

	/******************************************************************************/
	/**

	GDSI ICD, 3.13 GSDIDIAG_GET_FEATURE_INDICATOR_KEY_CMD

	ICD Description:
		This request message is used to get the various personalization feature control key value with
		respect to SIM Lock feature. All fields are mandatory unless they specifically indicate that they
		are optional.
		The command is processed and put onto the GSDI Task Command Queue. So long as the
		queuing of the command is successful, a response with a valid Transaction ID is provided. Check
		the Command Status and verify it is successful before accepting the Transaction ID.
		At the completion of the Command Processing in the GSDI Task, an event is generated to notify
		the client.

	Related script command:  SIMGetFeatureKey

 	  The QMSL function will currently >>not<< process the event that results from this
	  function call. Use QLIB_GSDIDIAG_GetEventResponse() to get the response data, see
	  QLibDemo.cpp ->Test_Security() for an example of this.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_PersoFeature = input, see description of GSDI_DIAG_PersoFeature_Enum
	\param sEFS_Filename = File at which the return IMEI + key data will be stored at
	\param piTransactionID = Ouptut, returned in order to identify the related event
	\param piCommandStatus = Output, result of CMD_STATUS field, if not GSDI_SUCCESS then the function returns a false.	\return true if successful, false if fail.

	\return true if successful, false if fail.

	\warning Will activate event messages and clear the current event queue

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_GET_FEATURE_INDICATOR_KEY_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_PersoFeature,
			char* sEFS_Filename,
			unsigned short* piTransactionID,
			unsigned long* piCommandStatus
		);

	/******************************************************************************/
	/**
	GDSI ICD, 3.14 GSDIDIAG_UNBLOCK_FEATURE_INDICATOR_CMD

	ICD Description:
		This request message is used to unblock a blocked personalization feature indicator in SIM Lock
		feature. All fields are mandatory unless specifically indicate that they are an optional field.
		The command is processed and put onto the GSDI Task Command Queue. So long as the
		queuing of the command is successful, a response with a valid Transaction ID is provided. Check
		the Command Status and verify it is successful before accepting the Transaction ID.
		At the completion of the Command Processing in the GSDI Task, an event is generated to notify
		the client.

	Related script command: SIMUnblockFeature

 	  The QMSL function will currently >>not<< process the event that results from this
	  function call. Use QLIB_GSDIDIAG_GetEventResponse() to get the response data, see
	  QLibDemo.cpp ->Test_Security() for an example of this.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_PersoFeature = input, see description of GSDI_DIAG_PersoFeature_Enum
	\param sSIM_PersoKey = input, Personalization Key Value; Input is in string format, NULL terminated

	\param piTransactionID = Ouptut, returned in order to identify the related event
	\param piCommandStatus = Output, result of CMD_STATUS field, if not GSDI_SUCCESS then the function returns a false.

	\return true if successful, false if fail.

	\warning Will activate event messages and clear the current event queue

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_UNBLOCK_FEATURE_INDICATOR_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_PersoFeature,
			char* sSIM_PersoKey,
			unsigned short* piTransactionID,
			unsigned long* piCommandStatus
		);

	/******************************************************************************/
	/**
	GDSI ICD, 3.15 GSDIDIAG_GET_PERM_FEATURE_INDICATION_CMD

	ICD Description:
		This request message is used to get the various permanent personalization feature indication with
		respect to SIM Lock feature. All fields are mandatory unless they specifically indicate that they
		are optional.
		The command is processed and put onto the GSDI Task Command Queue. So long as the
		queuing of the command is successful, a response with a valid Transaction ID is provided. Check
		the Command Status and verify it is successful before accepting the Transaction ID.
		At the completion of the Command Processing in the GSDI Task, an event is generated to notify
		the client.

	Related script command:  SIMGetPermanentFeatureIndicators

  	  The QMSL function will currently >>not<< process the event that results from this
	  function call. Use QLIB_GSDIDIAG_GetEventResponse() to get the response data, see
	  QLibDemo.cpp ->Test_Security() for an example of this.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>

	\param piTransactionID = Ouptut, returned in order to identify the related event
	\param piCommandStatus = Output, result of CMD_STATUS field, if not GSDI_SUCCESS then the function returns a false.

	\return true if successful, false if fail.

	\warning Will activate event messages and clear the current event queue

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_GET_PERM_FEATURE_INDICATION_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned short* piTransactionID,
			unsigned long* piCommandStatus
		);

	/******************************************************************************/
	/**
	GDSI ICD, 3.16 GSDIDIAG_PERM_DISABLE_FEATURE_INDICATOR_CMD

	ICD Description:
		This request message is used to permanently disable a personalization feature indicator in SIM
		Lock feature. All fields are mandatory unless they specifically indicate that they are optional.
		The command is processed and put onto the GSDI Task Command Queue. So long as the
		queuing of the command is successful, a response with a valid Transaction ID is provided. Check
		the Command Status and verify it is successful before accepting the Transaction ID.
		At the completion of the Command Processing in the GSDI Task, an event is generated to notify
		the client.

	Related script command:  SIMDisableFeaturePermanently

  	  The QMSL function will currently >>not<< process the event that results from this
	  function call. Use QLIB_GSDIDIAG_GetEventResponse() to get the response data, see
	  QLibDemo.cpp ->Test_Security() for an example of this.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iSlotID = input, <See description of GSDIDIAG_ROOT_KEY_WRITE_CMD>
	\param iSIM_PersoFeature = input, see description of GSDI_DIAG_PersoFeature_Enum
	\param sSIM_PersoKey = input, Personalization Key Value; Input is in string format, NULL terminated

	\param piTransactionID = Ouptut, returned in order to identify the related event
	\param piCommandStatus = Output, result of CMD_STATUS field, if not GSDI_SUCCESS then the function returns a false.

	\return true if successful, false if fail.

	\warning Will activate event messages and clear the current event queue

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GSDIDIAG_PERM_DISABLE_FEATURE_INDICATOR_CMD
		(
			HANDLE hResourceContext,
			unsigned char iSlotId,
			unsigned char iSIM_PersoFeature,
			char* sSIM_PersoKey,
			unsigned short* piTransactionID,
			unsigned long* piCommandStatus
		);


/******************************************************************************
						AGPS FTM
*******************************************************************************/

	/******************************************************************************/
	/**
	Factory Test Mode AGPS, 3.2.1 Subcommand 0 - set test mode

	Enables/disables AGPS Test Mode

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iOnOff = 0 - OFF disable test mode, 1 - ON enable test mode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AGPS_SET_TEST_MODE( HANDLE hResourceContext, unsigned char iOnOff );

	/******************************************************************************/
	/**
	Factory Test Mode AGPS, 3.2.2 Subcommand 1 - self-test

	Starts a self-test of AGPS-based MSM; tests include memory test, signal
	        processing test, and boot code checksum test

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iPassFail = returns 1 byte with 3 LSB indicators:
	                      0x01 = Memory result
						  0x02 = STP result
						  0x03 = Bootcode Checksum

						  these 3 results are 0 if self test passes, 1 if self test fails

						  This field should be and with 0x07 and if the result is zero,
						  then all 3 modes are pass.

	\return true if sent successfully, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AGPS_SELF_TEST( HANDLE hResourceContext, unsigned char* iPassFail  );

	/******************************************************************************/
	/**
	Factory Test Mode AGPS, 3.2.3 Subcommand 2 - set idle mode

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	Places the Location Services Manager (LSM) task in idle mode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AGPS_IDLE_MODE( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Factory Test Mode AGPS, 3.2.4 Subcommand 3 - standalone test mode

	Verifies the GSP operation in a standalone mode of AGPS-based MSM

		In this mode, an AGPS-based MSM performs position fixes at the rate of 1 sec continuously. The
		results of each fix are sent out as MMGPS LOG packets. The results could include Satellite
		Vehicle (SV) statistics (like SNR, Doppler, code phase, uncertainties, etc.), calculated positions,
		and/or statistics of the RF path (oscillator frequency bias, AGC calibration, DC offset
		adjustments, etc.).
		This test is repetitive and is performed every second. This can be stopped by sending either an
		Idle Mode command or by sending a request to start a different test.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AGPS_STANDALONE_TEST_MODE( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Factory Test Mode AGPS, 3.2.5 Subcommand 4 - SV tracking

	Processes a single SV continuously and produces results on a regular basis

		The results, which include SV SNR, Doppler, code phase, etc., are sent out as MMGPS 20
		LOG packets.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param = iSatelliteVehicleId = SV identifier, 0-32

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AGPS_SV_TRACKING( HANDLE hResourceContext, unsigned char iSatelliteVehicleId );

	/******************************************************************************/
	/**
	Factory Test Mode AGPS, 3.2.6 Subcommand 5 - IQ capture

	Captures a snapshot of the baseband IQ data

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iCenterFreq_Hz = center frequency (Hz)
	\param iSampleFreq_Hz = (1 MHz or 2MHz)
	  \code
         0 - I/Q Capture Sampling frequency 1MHz
		 1 - I/Q Capture Sampling frequency 2KHz
	  \endcode
	\param iStartDelay = start delay (ms)
	\param iAutoCenter = auto center frequency, 0-No auto center, 1-Auto Center
	\param piMaxRecordSize = output, maximum number of samples take.  Each sample is (1) I sample and (2) Q sample.
	                         Each I sample is a 16-bit signed number, as is each Q sample.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AGPS_IQ_CAPTURE
		(
			HANDLE hResourceContext, unsigned long iCenterFreq_Hz, unsigned long iSampleFreq_Hz,
			unsigned short iStartDelay, unsigned char iAutoCenter, unsigned short* piMaxRecordSize
		);

	/******************************************************************************/
	/**
	Factory Test Mode AGPS, 3.2.7 Subcommand 6 - get IQ data

	Returns the baseband IQ data

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pIQ_Data = Buffer of 256 16-bit numbers, representing 128 pairs of I and Q samples
	\param piRecord = The record number that is being requested.  A group of 256 samples is a record.
					  Each sample is either an I or a Q sample of 16-bits.  The order is I0, then Q0,
					  then I1 then Q1, to I127 and Q127.

	                  The response packet returns the actual record number that is returned, and
					  this value is updated with the value stored in the response packet.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AGPS_GET_IQ_DATA
		( HANDLE hResourceContext, short* piIQ_Data, unsigned short* piRecord );

	/******************************************************************************/
	/**
	Factory Test Mode AGPS, 3.2.8 Subcommand 122 - get C/N

	Returns the AGPS C/N in units 1/10dB.  Uses the LSM to perform an IQ capture
	and spectral analysis

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piCTON = Output, C/N value in dB multiplied by 10

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_AGPS_GET_CTON
		( HANDLE hResourceContext, long* piCTON );

	/******************************************************************************/
	/**
	Factory Test Mode, GNSS FTM RF Mode ID 34, Subcommand 253 - External LNA

	FTM ICD DCN: TBD

	Enable/disable external LNA

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iEnable = 0= diable, 1 = enable

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GNSS_EXTERNAL_LNA(HANDLE hResourceContext, unsigned char iEnable);

	/******************************************************************************/
	/**
	Factory Test Mode RF Commands x.x.x.x (CL93-V4168-1) QLIB_FTM_SET_TX_WAVEFORM

	This command is used to generate an Tx waveform of given type with specified attributes.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iWaveformType = 0 - CDMA_WAVEFORM
							1 - CW_WAVEFORM

	\param  iWaveformAttrib = 0 - CW_OFFSET_ZER0_KHZ
							  1 - CW_OFFSET_19_2_KHZ

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_TX_WAVEFORM( HANDLE hResourceContext, unsigned char iWaveformType , unsigned char iWaveformAttrib );


/******************************************************************************
						Common RF FTM
*******************************************************************************/

	/******************************************************************************/
	/**
	FTM RF Common, 80-VA888-1 section 2.1, FTM_TX_RX_FREQ_CAL_SWEEP

	This command instructs the mobile to perform the CDMA TX RX Frequency measurement
	described by 80-V5532-2.  It will setup the appropriate mobile logging so that the
	resulting log message will be captured.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pFTM_Tx_Rx_Freq_Cal_Sweep_Request_Response = structure to hold input and output values,
	       of type "FTM_Tx_Rx_Freq_Cal_Sweep_Request_Response," as defined in QLIB_Defines.h

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_TX_RX_FREQ_CAL_SWEEP(
		HANDLE hResourceContext, void* pFTM_Tx_Rx_Freq_Cal_Sweep_Request_Response);


	/******************************************************************************/
	/**
	FTM RF Common, 80-VA888-1 section x.x, FTM_GET_THERM

	This command instructs the mobile to readback and return the thermistor value

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iThermValue      = Output value - The thermistor ADC value

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_THERM( HANDLE hResourceContext, unsigned char* iThermValue );

	/******************************************************************************/
	/**
	FTM RF Common, 80-VA888-1 section x.x, FTM_GET_ENH_THERM

	This command instructs the mobile to readback and return the thermistor value

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iThermValue      = Output value - The thermistor ADC value

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GET_ENH_THERM( HANDLE hResourceContext, unsigned long* iThermValue );

	/******************************************************************************/
	/**
	FTM RF Common, 80-VA888-1 section 2.2, FTM_LOAD_RF_NV

	This operation is used to load RF NV from NV and into the RF Driver immediately.
	This allows the test automation to skip the step of putting the mobile into ONLINE only
	for the purpose of getting RF NV loaded properly.

	This command is designed to be used in test stations where RF Calibration is performed and
	non-signaling (specification/performance) testing is to be done immediately afterwards, without resetting the phone.

	If this step is not done, then the RF NV is not loaded from NV to the RF Driver, and the phone will not
	use the NV item changes that have occurred since the last time the phone was powered up.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pFTM_Error_Code =RFNV_READ_SUCCESS =0
							RFNV_READ_FAILED=1
							RFNV_WRITE_SUCCESS=2
							RFNV_WRITE_FAILED=3
							RFNV_INACTIVE_ITEM=4

	\return true if successful, false if fail.

	\warning The transmitter should be turned off before this command is called.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LOAD_RF_NV(
		HANDLE hResourceContext, unsigned short* pFTM_Error_Code);

	/******************************************************************************/
	/**
	FTM RF Common, 80-VA888-1, FTM_DO_INTERNAL_DEVICE_CAL

	This operation is used to perform internal calibrations, which are normally done
	the first time a phone is powered.   For example, on the MSM6280 with RTR6275,
	this function will calibrate NV_RFR_IQ_LINE_RESISTOR_I, NV_RFR_BB_FILTER_I, and
	NV_RTR_BB_FILTER_I.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pFTM_errorCode = SUCCESS = 0, FAIL = 1

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_DO_INTERNAL_DEVICE_CAL(	HANDLE hResourceContext, unsigned short* pFTM_error_code );

	/******************************************************************************/
	/**
	FTM RF Common, 80-VA888-1, FTM_DO_XO_DC_CAL

	SC2x

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param FTM_XO_Cal_Request[input] Pointer to FTM_XO_Cal_Request

	\param FTM_XO_Cal_Response[input] Pointer to FTM_XO_Cal_Response

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_DO_XO_DC_CAL (HANDLE hResourceContext, void * pFTM_XO_Cal_Request, void *pFTM_XO_Cal_Response);

	/******************************************************************************/
	/**
	FTM RF Common, 80-VA888-1, FTM_DO_XO_FT_CURVE_CAL

	SC2x

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param FTM_XO_Cal_Request[input] Pointer to FTM_XO_Cal_Request

	\param FTM_XO_Cal_Response[input] Pointer to FTM_XO_Cal_Response

	\return true if successful, false if fail.


	\warning
	*******************************************************************************/


	QLIB_API unsigned char QLIB_FTM_DO_XO_FT_CURVE_CAL (HANDLE hResourceContext, void * pFTM_XO_Cal_Request, void *pFTM_XO_Cal_Response);

	/******************************************************************************/
	/**
	FTM RF Common, 80-VA888-1, FTM_DO_ENH_XO_DC_CAL

	Enhanced XO Coarse DC Calibration

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param FTM_XO_Cal_Request[input] Pointer to FTM_ENH_XO_Cal_Request

	\param FTM_XO_Cal_Response[input] Pointer to FTM_XO_Cal_Response

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_DO_ENH_XO_DC_CAL (HANDLE hResourceContext, void * pFTM_ENH_XO_Cal_Request, void *pFTM_XO_Cal_Response);

   /******************************************************************************/
	/**
	FTM RF Common, 80-VA888-1, FTM_DO_ENH_XO_FT_CURVE_CAL

	Enhanced XO FT Curve and Fine DC Calibration.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param FTM_XO_Cal_Request[input] Pointer to FTM_XO_Cal_Request

	\param FTM_XO_Cal_Response[input] Pointer to FTM_XO_Cal_Response

	\return true if successful, false if fail.


	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_DO_ENH_XO_FT_CURVE_CAL (HANDLE hResourceContext, void * pFTM_ENH_XO_Cal_Request, void *pFTM_XO_Cal_Response);

	/******************************************************************************/
	/**
	FTM RF Common, 80-VA888-1, FTM_DO_ENH_XO_FT_COLLECT_SAMPLE

	Enhanced FT Curve Sample collection. This command results in the phone
        collecting FT curve samples (to be later used for processing by the curvefit functions

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param FTM_XO_Cal_Request[input] Pointer to FTM_XO_Cal_Request

	\param FTM_XO_Cal_Response[input] Pointer to FTM_XO_Cal_Response

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_DO_ENH_XO_FT_COLLECT_SAMPLE (HANDLE hResourceContext, void * pFTM_ENH_XO_Cal_Request, void *pFTM_XO_Cal_Response);

   /******************************************************************************/
	/**
	FTM RF Common, 80-VA888-1, FTM_DO_ENH_XO_DC_CAL_V2

	Enhanced XO Coarse DC Calibration

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param FTM_XO_Cal_Request[input] Pointer to FTM_ENH_XO_Cal_Request

	\param FTM_XO_Cal_Response[input] Pointer to FTM_XO_Cal_Response_v2

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_DO_ENH_XO_DC_CAL_V2 (HANDLE hResourceContext, void * pFTM_ENH_XO_Cal_Request, void *pFTM_XO_Cal_Response_v2);

   /******************************************************************************/
	/**
	FTM RF Common, 80-VA888-1, FTM_DO_ENH_XO_FT_CURVE_CAL_V2

	Enhanced XO FT Curve and Fine DC Calibration.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param FTM_XO_Cal_Request[input] Pointer to FTM_XO_Cal_Request

	\param FTM_XO_Cal_Response[input] Pointer to FTM_XO_Cal_Response_v2

	\return true if successful, false if fail.


	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_DO_ENH_XO_FT_CURVE_CAL_V2 (HANDLE hResourceContext, void * pFTM_ENH_XO_Cal_Request, void *pFTM_XO_Cal_Response_v2);

	/******************************************************************************/
	/**
	FTM RF Common, 80-VA888-1, FTM_DO_ENH_XO_FT_COLLECT_SAMPLE_V2

	Enhanced FT Curve Sample collection. This command results in the phone
        collecting FT curve samples (to be later used for processing by the curvefit functions

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param FTM_XO_Cal_Request[input] Pointer to FTM_XO_Cal_Request

	\param FTM_XO_Cal_Response[input] Pointer to FTM_XO_Cal_Response_v2

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_DO_ENH_XO_FT_COLLECT_SAMPLE_V2 (HANDLE hResourceContext, void * pFTM_ENH_XO_Cal_Request, void *pFTM_XO_Cal_Response_v2);

   /******************************************************************************/
	/**
	FTM RF Common, 80-VA888-1, QLIB_FTM_SET_CALIBRATION_STATE

	This command is used to generate an Tx waveform of given type with specified attributes.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  icalState = 0 - CAL_STATE_INACTIVE
						1 - CAL_STATE_ACTIVE

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_SET_CALIBRATION_STATE( HANDLE hResourceContext, unsigned char icalState );

	/******************************************************************************/
	/**
	Factory Test Mode RF Commands, 80-VP567-3  FTM_RFNV_READ

	This function will read NV items via FTM interface

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iRFNV_ID = NV item enumeration

	\param  pData  = A byte array of NV item data

	\param iDataSz = [input] Size of the byte array
	                 [output] The actual size of item data returned

	\param iFTM_Eror_Code = FTM Error code returned by FTM command
							See rfnv_read_write_status_enum in QLib_Defines.h

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
    QLIB_API unsigned char QLIB_FTM_RFNV_READ(HANDLE hResourceContext, unsigned short iRFNV_ID, unsigned char* pData, unsigned short* iDataSz, unsigned short* iFTM_Error_Code);

	/******************************************************************************/
	/**
	Factory Test Mode RF Commands 80-VP567-3  FTM_RFNV_WRITE

	This function will write NV items via FTM interface

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iRFNV_ID = NV item enumeration

	\param  pData  = A byte array of NV item data

	\param iDataSz = Size of the byte array

	\param iFTM_Eror_Code = FTM Error code returned by FTM command
							See rfnv_read_write_status_enum in QLib_Defines.h

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_RFNV_WRITE(HANDLE hResourceContext, unsigned short iRFNV_ID, unsigned char* pData, unsigned short iDataSz, unsigned short* iFTM_Error_Code);

   /******************************************************************************/
	/**
	Factory Test Mode RF Commands x.x.x.x  FTM_DO_SELF_CAL

	This function is used to call the different Self Cal routines

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iCal_Type = Self Cal type

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_DO_SELF_CAL(HANDLE hResourceContext, unsigned char iCal_Type);
   /******************************************************************************
	   					                  LTE Non-signaling FTM
   *******************************************************************************/

	/******************************************************************************/
	/**
   Factory Test Mode LTE Commands QLIB_FTM_LTE_NS_START

   This command puts the UE in LTE Non-Signaling mode.

   \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

   \return
   	\code
          true  = Success
          false = Failure
		\endcode

    \note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/

QLIB_API unsigned char QLIB_FTM_LTE_NS_START( HANDLE hResourceContext, unsigned long* pStatus );


	/******************************************************************************/
	/**
   Factory Test Mode LTE Commands QLIB_FTM_LTE_NS_IS_CONNECTED

   This command queries if the UE is in LTE Non-Signaling mode call.

   \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

   \return
   	\code
          true  = Success
          false = Failure
		\endcode

   \note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/

QLIB_API unsigned char QLIB_FTM_LTE_NS_IS_CONNECTED( HANDLE hResourceContext, unsigned long* pStatus );



	/******************************************************************************/
	/**
   Factory Test Mode LTE Commands QLIB_FTM_LTE_NS_ACQ

   This command starts acquisition process.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

   \param iBand           = Band, this number is BC number minus 1.  For example, for BC13, band value is 12

   \param iEARFCN         = Channel

   \return
   	\code
          true  = Success
          false = Failure
		\endcode

    \note This function can be used in QMSL FTM Sequencer operation  
	*******************************************************************************/

QLIB_API unsigned char QLIB_FTM_LTE_NS_ACQ( HANDLE hResourceContext, unsigned char iBand, unsigned short iEARFCN, unsigned long* pStatus );

	/******************************************************************************/
	/**
   Factory Test Mode LTE Commands QLIB_FTM_LTE_NS_START_DP

   This command is used to start downlink reception on the UE

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

   \param iCRNTI           = C-RNTI used by UE

   \param iNetworkSigValue   = The network signaled valued - NS01,NS02,..

   \param iBSMaxPowerLimit =  The Base station maximum power limit.

   \return
   	\code
          true  = Success
          false = Failure
		\endcode

    \note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/

QLIB_API unsigned char QLIB_FTM_LTE_NS_START_DP( HANDLE hResourceContext, unsigned short iCRNTI, unsigned char iNetworkSigValue, char iBSMaxPowerLimit,unsigned char iDLLCID, unsigned char iULLCID,unsigned long* pStatus );


	/******************************************************************************/
	/**
   Factory Test Mode LTE Commands QLIB_FTM_LTE_NS_STOP

   This command halts all outstanding operation and exits the LTE mode. After this command is executed,
   FTM_LTE_NS_START command must be sent again to enter LTE mode.

   \param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()


   \return
   	\code
          true  = Success
          false = Failure
		\endcode

    \note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/

QLIB_API unsigned char QLIB_FTM_LTE_NS_STOP( HANDLE hResourceContext, unsigned long* pStatus );

	/******************************************************************************/
	/**
	Factory Test Mode LTE Non-Signaling Command, FTM_LTE_NS_CONFIG_UL_WAVEFORM

	Configures the active resource blocks and modulation type for the LTE uplink waveform, overriding the settings in the DL DCI1.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iConfigOverride = 1 = Enable UL Override, ignore DCI 1 value sent over the air, and configure based on the parameters (Tx Chain, Start RB, Num RB, Modulation Type)
								0 = Disable UL Grant override, use DCI 1 value sent over the air

	\param iTxChain =	0 = Tx 0
						1 = Tx 1 (currently not supported)
	   
	\param iStartRB = Starting resource block index that will be active
	   
	\param iNumRB = Number of resources blocks that will be active.  The active resource blocks start at the index value indicated by START_RB_INDEX and are increasing by one after that
	   
	\param iMCS  = Modulation Coding Scheme

				   Refer to Table 8.6.1-1: Modulation, TBS index and redundancy version table for PUSCH of 3GPP TS 36.213
				   The value of 0-10 is for QPSK with TBS value from 0 to 10
				   The value of 11-20 is for 16 QAM with TBS value from 10 to 19


	\param pStatus =		0  Success
							1  Failure
							2  Not Allowed
							12  In progress
							13  Already done
							16  Invalid Argument
							20  Bad data
							55  Busy

	\return
	
	\note This function can be used in QMSL FTM Sequencer operation
	
	*******************************************************************************/
QLIB_API unsigned char QLIB_FTM_LTE_NS_CONFIG_UL_WAVEFORM( HANDLE hResourceContext, unsigned char iConfigOverride, unsigned char iTxChain, unsigned char iStartRB, unsigned char iNumRB, unsigned char iMCS, unsigned long* pStatus );

	/******************************************************************************/
	/**
	Factory Test Mode LTE Non-Signaling Command, FTM_LTE_NS_CONFIG_UL_POWER

	Configures the active resource blocks and modulation type for the LTE uplink waveform, overriding the settings in the DL DCI1.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iTxChain =	0 = Tx 0
						1 = Tx 1 (currently not supported)
	   
	\param iTxPwrCtrlMode = Selects the transmitter power control mode
							0 = enable power control bits
							1 = direct tx level setting

	\param iTxLevel =	Indicates the power level in 10/dBm units as signed number.
						This field is only used if TX_POWER_CONTROL_MODE is set to a value of 1
						
						For example, use 230 for 23dBm.

	\param pStatus =		0  Success
							1  Failure
							2  Not Allowed
							12  In progress
							13  Already done
							16  Invalid Argument
							20  Bad data
							55  Busy

	\return

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
QLIB_API unsigned char QLIB_FTM_LTE_NS_CONFIG_UL_POWER( HANDLE hResourceContext, unsigned char iTxChain, unsigned char iTxPwrCtrlMode, short iTxLevel, unsigned long* pStatus );

	/******************************************************************************/
	/**
	Factory Test Mode LTE Non-Signaling Command, FTM_LTE_NS_GET_DL_LEVEL

	Returns downlink RX AGC and RX Level in dBm/10 units, for a specified receiver

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iRxChain =	0 = Rx 0
						1 = Rx 1
						2 = Rx 2
						3 = Rx 3
	   
	\param iTxPwrC = Selects the transmitter power control mode
							0 = enable power control bits
							1 = direct tx level setting

	\param iRxAGC =		Receiver power in Rx AGC Units
					
	\param iRxLevel =   Receiver power in dBm/10 units. For example, -700 = -70dBm

	\param pStatus =		0  Success
							1  Failure
							2  Not Allowed
							12  In progress
							13  Already done
							16  Invalid Argument
							20  Bad data
							55  Busy

	\return

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
QLIB_API unsigned char QLIB_FTM_LTE_NS_GET_DL_LEVEL( HANDLE hResourceContext, unsigned char iRxChain, short* iRxAGC, short* iRxLeveldBm10, unsigned long* pStatus );

	/******************************************************************************/
	/**
	Factory Test Mode LTE Non-Signaling Command, FTM_LTE_NS_RESET_DL_BLER_REPORT

	Resets the downlink BLER accumulators for a specified receiver.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pStatus =		0  Success
							1  Failure
							2  Not Allowed
							12  In progress
							13  Already done
							16  Invalid Argument
							20  Bad data
							55  Busy

	\return

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
QLIB_API unsigned char QLIB_FTM_LTE_NS_RESET_DL_BLER_REPORT( HANDLE hResourceContext, unsigned long* pStatus );

	/******************************************************************************/
	/**
	Factory Test Mode LTE Non-Signaling Command, FTM_LTE_NS_GET_DL_BLER_REPORT

	Resets the downlink BLER accumulators for a specified receiver.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iTotalBlockReceived = Total number of blocks that have been received since FTM_LTE_NS_RESET_DL_BLER_REPORT was called

	\param iTotalBlockError = Total number of blocks errors that have been received since FTM_LTE_NS_RESET_DL_BLER_REPORT was called.

	\param iThroughput = Throughput, in bits/second, since FTM_LTE_NS_RESET_DL_BLER_REPORT was called.

	\param pStatus =		0  Success
							1  Failure
							2  Not Allowed
							12  In progress
							13  Already done
							16  Invalid Argument
							20  Bad data
							55  Busy

	\return

	\note This function can be used in QMSL FTM Sequencer operation
	*******************************************************************************/
QLIB_API unsigned char QLIB_FTM_LTE_NS_GET_DL_BLER_REPORT( HANDLE hResourceContext, unsigned long* iTotalBlockReceived, unsigned long* iTotalBlockError, unsigned long* iThroughput, unsigned long* pStatus );


   /******************************************************************************
						LTE RF Calibration Commands
   *******************************************************************************/


   /******************************************************************************/
	/**
	Factory Test Mode LTE Commands(80-VR832-1), QLIB_FTM_LTE_SET_TX_BANDWIDTH

	This command configures the phone Tx chain bandwidth.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

    \param itxChanBW =  0 - RFCOM_BW_LTE_1P4MHz
						1 - RFCOM_BW_LTE_3MHz
						2 - RFCOM_BW_LTE_5MHz
						3 - RFCOM_BW_LTE_10MHz
						4 - RFCOM_BW_LTE_15MHz
						5 - RFCOM_BW_LTE_20MHz

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_LTE_SET_TX_BANDWIDTH( HANDLE hResourceContext, unsigned char itxChanBW );

 /******************************************************************************/
	/**
	Factory Test Mode LTE Commands(80-VR832-1),QLIB_FTM_LTE_SET_RX_BANDWIDTH

	This command configures the phone Tx Chain.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

    \param irxChanBW =  0 - RFCOM_BW_LTE_1P4MHz
						1 - RFCOM_BW_LTE_3MHz
						2 - RFCOM_BW_LTE_5MHz
						3 - RFCOM_BW_LTE_10MHz
						4 - RFCOM_BW_LTE_15MHz
						5 - RFCOM_BW_LTE_20MHz

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_LTE_SET_RX_BANDWIDTH( HANDLE hResourceContext, unsigned char irxChanBW );

 /******************************************************************************/
	/**
	Factory Test Mode LTE Commands(80-VR832-1), QLIB_FTM_LTE_SET_TX_WAVEFORM

	This command configures the phone Tx Waveform.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iTxWaveform  = 0-CW, 1- PUSCH, 2- PUCCH, 3 - PRACH, 4 - SRS, 5 - UpPTS
    \param inumRBsPUSCH = Number of UL resource blocks to transmit on the PUSCH.
    \param inumRBsPUCCH = Number of UL resource blocks to transmit on the PUCCH.
	\param iPUSCHStartRBIndex = Starting resource block index on the PUSCH.

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_LTE_SET_TX_WAVEFORM( HANDLE hResourceContext, unsigned char iTxWaveform, unsigned char inumRBsPUSCH, unsigned char inumRBsPUCCH,unsigned char iPUSCHStartRBIndex );

	/******************************************************************************/
	/**
	Factory Test Mode LTE Commands(80-VR832-1), QLIB_FTM_LTE_STOP_TX_WAVEFORM

	This command stops the phone LTE Tx Waveform transmission.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_LTE_STOP_TX_WAVEFORM( HANDLE hResourceContext );


	 /******************************************************************************/
	/**
	Factory Test Mode LTE Commands(80-VR832-1), QLIB_FTM_SET_TX_GAIN_INDEX

	This command sets the Gain Index on from the corresponding LUT (characterization) table.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iTxGainIndex  = Gain Index to set.

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_SET_TX_GAIN_INDEX( HANDLE hResourceContext, unsigned short iTxGainIndex);


	/******************************************************************************/
	/**

	Starts logging LTE AGC (LOG_FTM2_LTE_TX_AGC) packets.

	This command calls the FTM_LOG_ENABLE() function with the proper settings.
	Subsequently the function QLIB_FTM_LTE_Tx_AGC_WaitForNextLog() can be called
	to wait for the next WCDMA log message and have the values returned.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\return true if successful, false if fail.

	\warning

        1. Before this function is called, the phone must be set in a LTE FTM mode,
		   by calling either QLIB_FTM_SET_MODE() for basic RF testing, or by starting
		   LTE NS Call.

		2. This function will set the async messasge logging status to ON, to
           turn off async messages, QLIB_DIAG_SetPhoneLoggingState() should be called.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LTE_Tx_AGC_Start_Log( HANDLE hResourceContext );

	/******************************************************************************/
	/**

	Starts logging LTE AGC (LOG_FTM2_LTE_RX_AGC) packets.

	This command calls the FTM_LOG_ENABLE() function with the proper settings.
	Subsequently the function QLIB_FTM_LTE_Rx_AGC_WaitForNextLog() can be called
	to wait for the next WCDMA log message and have the values returned.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\return true if successful, false if fail.

	\warning

        1. Before this function is called, the phone must be set in a LTE FTM mode,
		   by calling either QLIB_FTM_SET_MODE() for basic RF testing, or by starting
		   LTE NS Call.

		2. This function will set the async messasge logging status to ON, to
           turn off async messages, QLIB_DIAG_SetPhoneLoggingState() should be called.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LTE_Rx_AGC_Start_Log( HANDLE hResourceContext );

	/******************************************************************************/
	/**

	Wait a specified number of milliseconds for the next LTE Tx AGC log message.

	If the message is found, then the contents of the message are copied into a
	FTM2LogMessage_LTE_Tx_AGC structure.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pLTE_Tx_AGC_Log = pointer to the area to store the LTE AGC log information.
	                        This is of type "FTM2LogMessage_LTE_Tx_AGC" defined in
							QLIB_Defines.h
	\param iTimeout_ms = # of milliseconds to wait for the LTE log.  Default is 300ms

	\return true if a valid LTE log was found within the specified timeout, false if not.

	\warning Before this function is called, QLIB_FTM_LTE_Tx_AGC_Start_Log() must be
			 called to setup capturing of LTE Tx AGC messages.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LTE_Tx_AGC_WaitForNextLog( HANDLE hResourceContext,
		                                                         void* pLTE_Tx_AGC_Log,
																 unsigned long iTimeout_ms );
	/******************************************************************************/
	/**

	Wait a specified number of milliseconds for the next LTE Rx AGC log message.

	If the message is found, then the contents of the message are copied into a
	FTM2LogMessage_LTE_Rx_AGC structure.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pLTE_Rx_AGC_Log = pointer to the area to store the LTE AGC log information.
	                        This is of type "FTM2LogMessage_LTE_Rx_AGC" defined in
							QLIB_Defines.h
	\param iTimeout_ms = # of milliseconds to wait for the LTE log.  Default is 300ms

	\return true if a valid LTE log was found within the specified timeout, false if not.

	\warning Before this function is called, QLIB_FTM_LTE_Rx_AGC_Start_Log() must be
			 called to setup capturing of LTE Tx AGC messages.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LTE_Rx_AGC_WaitForNextLog( HANDLE hResourceContext,
		                                                         void* pLTE_Rx_AGC_Log,
																 unsigned long iTimeout_ms );

	/******************************************************************************/
	/**

	Stop logging LTE AGC (LOG_FTM2_LOG_LTE_Tx_AGC) packets.  This is important
	to do before changing RF modes or starting/stopping LTE NS testing.

	This command calls the FTM_LOG_DISABLE() function with the proper settings.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning This function will set the async message logging status to OFF.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LTE_Tx_AGC_Stop_Log( HANDLE hResourceContext );
	/******************************************************************************/
	/**

	Stop logging LTE AGC (LOG_FTM2_LOG_LTE_Rx_AGC) packets.  This is important
	to do before changing RF modes or starting/stopping LTE NS testing.

	This command calls the FTM_LOG_DISABLE() function with the proper settings.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning This function will set the async message logging status to OFF.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LTE_Rx_AGC_Stop_Log( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	This command Measures the LTE PDSCH BLER value for a give Loopback Type and updates the pSE_BER_State pointer.
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pLTE_PDSCH_BLER_Status  = Pointer the LTE_PDSCH_BLER_Status structure defined in QLib_Defines.h

	\param iMeasurementCount = Number of ACKs and NACKs to be collected for each LTE PDSCH BLER measurement.

	\param iTimeOut_ms =  Time out duration before exiting the LTE PDSCH BLER measurement.

	\return true if successful, false if fail.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_LTE_PDSCH_BLER_DoMeasurement(
								HANDLE hResourceContext,
								void *pLTE_PDSCH_BLER_Status,
								unsigned long iMeasurementCount,
								unsigned long iTimeOut_ms
								);

	/******************************************************************************/
	/**
	High level function to start PDSCH Logs, including setting the diagnostic log mask

	\return true if successful, false if fail.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_LTE_PDSCH_BLER_Start_Log(HANDLE hResourceContext );

	/******************************************************************************/
	/**
	High level function to stop PDSCH Logs, including setting the diagnostic log mask

	\return true if successful, false if fail.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_LTE_PDSCH_BLER_Stop_Log(HANDLE hResourceContext );

/******************************************************************************
						GPS FTM
*******************************************************************************/

	/******************************************************************************/
	/**
	This command sets the linearity mode of the GPS RF Device.
	This is necessary for selecting the desired linearity mode.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iLinearityMode	= input, specifies the desired linearity mode of the device:
							Low Linearity or High Linearity
	\code
        0 = FTM_GPS_SET_LINEARITY_MODE_LL					=  Low Linearity Mode,
		1 = FTM_GPS_SET_LINEARITY_MODE_HL					=  High Linearity Mode,
		2 =	FTM_GPS_SET_LINEARITY_MODE_HL_AWS				=  High Linearity Mode for AWS band
		Refer to the enumeration ftm_gps_linearity_mode_enum_type for bit mask definitions.
	\endcode
	\param piStatus											= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GPS_SET_LINEARITY_MODE(
									HANDLE hResourceContext,
									unsigned char iLinearityMode,
									unsigned char* piStatus
									);

	/******************************************************************************/
	/**
	This command enables or disables the periodic steady-state DC correction at 1Hz rate.
	The periodic steady-state DC correction needs to be disabled prior to performing the IM2 calibration.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iEnable_DC_correction	= input, enables or disables the steady-state periodic DC correction
	\code
        0 = FTM_GPS_DISABLE_SS_DC_CORRECTION=  Disable periodic steady-state DC correction,
		1 = FTM_GPS_ENABLE_SS_DC_CORRECTION	=  Enable periodic steady-state DC correction
		Refer to the enumeration ftm_gps_enable_ss_dc_correction_enum_type for bit mask definitions.
	\endcode
	\param piStatus								= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GPS_ENABLE_SS_DC_CORRECTION(
									HANDLE hResourceContext,
									unsigned char iEnable_DC_correction,
									unsigned char* piStatus
									);


	/******************************************************************************/
	/**
	This command prepares the GPS RFIC for the IM2 calibration by programming
	its PLL to a different LO output frequency from the normal mode of operation.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iReserved		= input, reserved for future usage or enhancement
	\param piStatus			= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GPS_INIT_FOR_IM2_CAL(
									HANDLE hResourceContext,
									unsigned char* piStatus
									);


	/******************************************************************************/
	/**
	This command triggers a single iteration of the IM2 calibration.
	This command returns the values of DC DACs and IM2 DACs that were found
	to minimize the DC component.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iI_Q_channel_id	= input, defines the channel to use for IM2 calibration: I-channel or Q-channel
	\code
        0 = FTM_GPS_DO_SINGLE_IM2_CAL_ITERATION_CHANNEL_I = Perform single IM2cal iteration on I-channel,
		1 = FTM_GPS_DO_SINGLE_IM2_CAL_ITERATION_CHANNEL_Q = Perform single IM2cal iteration on Q-channel
		Refer to the enumeration ftm_gps_do_single_im2_channel_enum_type for bit mask definitions.
	\endcode
	\param iDC_cancellation_method	= input, defines which DACs to use for DC cancellation: DC DACs or IM2 DACs
	\code
        0 = FTM_GPS_DO_SINGLE_IM2_CAL_ITERATION_METHOD_WITH_DC_DACS  = Cancel DC component using DC DACs,
		1 = FTM_GPS_DO_SINGLE_IM2_CAL_ITERATION_METHOD_WITH_IM2_DACS = Cancel DC component using IM2 DACs
		Refer to the enumeration ftm_gps_do_single_im2_cal_iteration_method_enum_type for bit mask definitions.
	\endcode
	\param iDAC_search_space	= input, defines the DAC search space for IM2 calibration: Full search space or Vicinity search space
	\code
        0 = FTM_GPS_DO_SINGLE_IM2_CAL_ITERATION_FULL_SEARCH_SPACE	  = Full search space (applies to DAC code),
		1 = FTM_GPS_DO_SINGLE_IM2_CAL_ITERATION_VICINITY_SEARCH_SPACE = Vicinity search around previous optimim value (applies to DAC code)
		Refer to the enumeration ftm_gps_do_single_im2_cal_iteration_search_space_enum_type for bit mask definitions.
	\endcode
	\param iPrevious_I_DAC_value	         = input,  Previously found optimum value of the I-channel DC DAC. DC DAC if Method is DC DAC. IM2 DAC if Method is IM2 DAC. This is an unsigned number.
	\param iPrevious_Q_DAC_value	         = input,  Previously found optimum value of the Q-channel DC DAC. DC DAC if Method is DC DAC. IM2 DAC if Method is IM2 DAC. This is an unsigned number.
	\param piCurrent_I_DAC_optimum_value	 = output, Optimum value of the I-channel DC or IM2 DAC. DC DAC if Method is DC DAC. IM2 DAC if Method is IM2 DAC. This is an unsigned number.
	\param piCurrent_Q_DAC_optimum_value	 = output, Optimum value of the Q-channel DC or IM2 DAC. DC DAC if Method is DC DAC. IM2 DAC if Method is IM2 DAC. This is an unsigned number.
	\param piStatus							 = output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GPS_DO_SINGLE_IM2_CAL_ITERATION(
									HANDLE hResourceContext,
									unsigned char iI_Q_channel_id,
									unsigned char iDC_cancellation_method,
									unsigned char iDAC_search_space,
									unsigned short iPrevious_I_DAC_value,
									unsigned short iPrevious_Q_DAC_value,
									unsigned short* piCurrent_I_DAC_optimum_value,
									unsigned short* piCurrent_Q_DAC_optimum_value,
									unsigned char* piStatus
									);


	/******************************************************************************/
	/**
	This command gets the following fields of GPS RF Status:
	BP Mean I, BP Mean Q, BP Amplitude I, and BP Amplitude Q.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext		= Resource context that was returned from the call to ConnectServer()
	\param piBP_Mean_I			= output, BP_Mean from Aries for I-channel. This is a signed number.
	\param piBP_Mean_Q			= output, BP_Mean from Aries for Q-channel. This is a signed number.
	\param piBP_Amplitude_I		= output, BP_Amplitude from Aries for I-channel. This is a signed number.
	\param piBP_Amplitude_Q		= output, BP_Amplitude from Aries for Q-channel. This is a signed number.
	\param piStatus				= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GPS_GET_BP_MEAN_AND_AMPL(
									HANDLE hResourceContext,
									short* piBP_Mean_I,
									short* piBP_Mean_Q,
									short* piBP_Amplitude_I,
									short* piBP_Amplitude_Q,
									unsigned char* piStatus
									);

	/******************************************************************************/
	/**
	This command returns the C/No ratio in tenths of dB of the GPS RFIC RF chain.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext		= Resource context that was returned from the call to ConnectServer()
	\param piCNo_tenths_dB		= output, C/No ratio of the GPS receivers RF chain in tenths of dB.
								  This is a signed number.
	\param piStatus				= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_GPS_GET_CN0(
									HANDLE hResourceContext,
									short* piCNo_tenths_dB,
									unsigned char* piStatus
									);

/******************************************************************************
						FM FTM (FM Broadcast Radio)
*******************************************************************************/

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Enable Receiver

	Powers on and initializes the FM receiver. 
		This is an asynchronous command used to power on the FM-RDS receiver. 
		If not already enabled, this function will intialize the receiver with default settings. 
		Only after successfully calling this function can many of the FM receiver interfaces be used.
		When enabling the receiver, the client must also provide the regional settings in which 
		the receiver will operate. These settings are typically used for setting up the FM receiver 
		for operating in a particular geographical region. These settings can be later changed through 
		the use of the function QLIB_FTM_FM_RX_CONFIGURE_RECEIVER.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iRadioBand = 
		\code
			0 = FM_US_EUROPE_BAND		( 87.5 MHz <-> 108 MHz)
			1 = FM_JAPAN_STANDARD_BAND	( 76   MHz <-> 90 MHz)
			2 = FM_JAPAN_WIDE_BAND		( 76   MHz <-> 108 MHz)
			3 = FM_USER_DEFINED_BAND	(as defined by parameters iUserDefinedBandFreqMin & iUserDefinedBandFreqMax)
		\endcode
	\param  iEmphasis = 
		\code
			0 = FM_DE_EMP75				(pre-emphasis/de-emphasis typically used in the United States and Japan.)
			1 = FM_DE_EMP50				(pre-emphasis/de-emphasis typically used outside of the United states and Japan.)
		\endcode
	\param  iChSpacing = 
		\code
			0 = FM_CHSPACE_200_KHZ
			1 = FM_CHSPACE_100_KHZ
			2 = FM_CHSPACE_50_KHZ
		\endcode
	\param  iRdsStd = 
		\code
			0 = FM_RDS_STD_RBDS			RBDS mode (Typically used in the United States). 
			1 = FM_RDS_STD_RDS			RDS mode (Typically used outside of the United States). 
			2 = FM_RDS_STD_NONE			No RDS/RBDS decoding. 
		\endcode
	\param  iUserDefinedBandFreqMin = min freq (in KHz) for FM_USER_DEFINED_BAND, must be >= 76000
	\param  iUserDefinedBandFreqMax = max freq (in KHz) for FM_USER_DEFINED_BAND, must be <= 108000 AND > iUserDefinedBandFreqMin

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_RX_ENABLE_RECEIVER( HANDLE hResourceContext, 
															unsigned char iRadioBand,
															unsigned char iEmphasis,
															unsigned char iChSpacing,
															unsigned char iRdsStd,
															unsigned long iUserDefinedBandFreqMin,
															unsigned long iUserDefinedBandFreqMax );

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Disable Receiver

	Powers off and disables the FM Receiver. 
		This is an asynchronous command used to power-off and disable the FM-RDS receiver. 
		This function is expected to be used when the client no longer requires use of the FM receiver. 
		While powered off, most functionality offered by the FM receiver will also be disabled until 
		the client re-enables the receiver again via QLIB_FTM_FM_RX_ENABLE_RECEIVER.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_RX_DISABLE_RECEIVER( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Configure Receiver

	Reconfigures the receiver's regional settings (FM Band, De-Emphasis, Channel Spacing, RDS/RBDS mode). 
		This is an asynchronous command used to reconfigure various settings on the FM-RDS receiver. 
		These settings typically differ from one geographical region to another.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iRadioBand = 
		\code
			0 = FM_US_EUROPE_BAND		( 87.5 MHz <-> 108 MHz)
			1 = FM_JAPAN_STANDARD_BAND	( 76   MHz <->  90 MHz)
			2 = FM_JAPAN_WIDE_BAND		( 76   MHz <-> 108 MHz)
			3 = FM_USER_DEFINED_BAND	(as defined by parameters iUserDefinedBandFreqMin & iUserDefinedBandFreqMax)
		\endcode
	\param  iEmphasis = 
		\code
			0 = FM_DE_EMP75				(pre-emphasis/de-emphasis typically used in the United States and Japan.)
			1 = FM_DE_EMP50				(pre-emphasis/de-emphasis typically used outside of the United states and Japan.)
		\endcode
	\param  iChSpacing = 
		\code
			0 = FM_CHSPACE_200_KHZ
			1 = FM_CHSPACE_100_KHZ
			2 = FM_CHSPACE_50_KHZ
		\endcode
	\param  iRdsStd = 
		\code
			0 = FM_RDS_STD_RBDS			RBDS mode (Typically used in the United States). 
			1 = FM_RDS_STD_RDS			RDS mode (Typically used outside of the United States). 
			2 = FM_RDS_STD_NONE			No RDS/RBDS decoding. 
		\endcode
	\param  iUserDefinedBandFreqMin = min freq (in KHz) for FM_USER_DEFINED_BAND, must be >= 76000
	\param  iUserDefinedBandFreqMax = max freq (in KHz) for FM_USER_DEFINED_BAND, must be <= 108000 AND > iUserDefinedBandFreqMin

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_RX_CONFIGURE_RECEIVER( HANDLE hResourceContext, 
															unsigned char iRadioBand,
															unsigned char iEmphasis,
															unsigned char iChSpacing,
															unsigned char iRdsStd,
															unsigned long iUserDefinedBandFreqMin,
															unsigned long iUserDefinedBandFreqMax );

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Set FM RX Mute Mode

	Allows the muting and un-muting of the audio coming from the FM receiver. 
		This is an asynchronous command used to mute or un-mute the FM audio. 
		This command mutes the audio coming from the FM device. It is important to note 
		that this only affects the FM audio and not any other audio system being used.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRxMute 
		\code
			0 = FM_RX_NOMUTE     Unmute both audio channels
			1 = FM_RX_MUTELEFT   Mute only the left audio channel
			2 = FM_RX_MUTERIGHT  Mute only the right audio channel
			3 = FM_RX_MUTEBOTH   Mute both audio channels
		\endcode
	\return true if successful, false if fail.

	\warning QLIB_FTM_FM_RX_ENABLE_RECEIVER must be called before this.

	*******************************************************************************/	
	QLIB_API unsigned char QLIB_FTM_FM_RX_SET_MUTE_MODE( HANDLE hResourceContext, unsigned char iRxMute);

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Set FM RX Stereo Mode


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iStereo
		\code
			0 = FM_RX_AUTO_MONO_STEREO_MODE  Both mono and stereo reception is possible;  The FM hardware will transition to stereo when possible.
			1 = FM_RX_FORCE_MONO_ONLY_MODE   Force mono only reception.
		\endcode
	\return true if successful, false if fail.

	\warning QLIB_FTM_FM_RX_ENABLE_RECEIVER must be called before this.

	*******************************************************************************/	
	QLIB_API unsigned char QLIB_FTM_FM_RX_SET_STEREO_MODE( HANDLE hResourceContext, unsigned char iStereo);

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Set FM RX RF frequency

	 Tunes the FM receiver to the supplied FM frequency. 
		This is an asynchronous command which tunes the FM receiver to a station as specified 
		by the supplied frequency. Only valid frequencies within the band set by 
		QLIB_FTM_FM_RX_ENABLE_RECEIVER or QLIB_FTM_FM_RX_CONFIGURE_RECEIVER can be tuned by this function. 
		Attempting to tune to frequencies outside of the set band will result in an error.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iFreqkHz = 
		\code
			The frequency must be a multiple of 50 KHz and within the band ranges defined below

			FM_US_EUROPE_BAND:
				US/Europe FM band (87500 KHz <-> 108000 KHz)

			FM_JAPAN_STANDARD_BAND:
				Japan Standard Band (76000 KHz <-> 90000 KHz)

			FM_JAPAN_WIDE_BAND  
				Japan Wide Band (76000 KHz <-> 108000 KHz)

			FM_USER_DEFINED_BAND  
				User defined band ( x KHz <-> y KHz where x < y and x >= 76000 KHz and y <= 108000 KHz)

		\endcode
	\return true if successful, false if fail.

	\warning QLIB_FTM_FM_RX_ENABLE_RECEIVER must be called before this.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_RX_SET_STATION( HANDLE hResourceContext, unsigned long iFreqkHz );

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Get FM RX station parameters

	Returns various statistics related to the currently tuned station. 
		This is an asynchronous command which returns various statistics related to the currently 
		tuned station. Included in these statistics are the currently tuned frequency, 
		the RDS/RBDS sync status, the RSSI level, current mute settings and the stereo/mono status.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStationFreq = Returns the currently tuned frequency in KHz 
	\param piServAvble = Returns the current service available indicator for the current station
		\code
			0 = FM_RX_SERVICE_NOT_AVAILABLE - No stations were found in the FM band.
			1 = FM_RX_SERVICE_AVAILABLE - At least one station was found in the FM band.
		\endcode
	\param piRssi = Returns the current signal strength level (0-100 range). 
		\code
			0 = -120 dBm
			1 = -119 dBm
			2 = -118 dBm
			...
			100 = -20 dBm
	\param piStereoProgram = Returns the current mono/stereo indicator for this station.
		\code
			0 = FM_RX_MONO_PROGRAM - The currently received audio is mono
			1 = FM_RX_STEREO_PROGRAM - The currently received audio is stereo.
		\endcode
	\param piRdsSyncStatus = Returns the current RDS/RBDS synchronization status
		\code
			0 = FM_RX_NO_RDS_SYNC - No RDS/RBDS decoding possible.
			1 = FM_RX_RDS_SYNC - RDS/RBDS decoding.
		\endcode
	\param piMuteMode = Returns the current FM mute mode.
		\code
			0 = FM_RX_NOMUTE  Un-mute both audio channels
			1 = FM_RX_MUTELEFT - Mute only the left audio channel
			2 = FM_RX_MUTERIGHT - Mute only the right audio channel
			3 = FM_RX_MUTEBOTH - Mute both audio channels
		\endcode
	\return true if successful, false if fail.

	\warning QLIB_FTM_FM_RX_ENABLE_RECEIVER must be called before this.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_RX_GET_STATION_PARAMETERS( HANDLE hResourceContext, 
															unsigned long* piStationFreq,
															unsigned char* piServAvble,
															unsigned char* piRssi,
															unsigned char* piStereoProgram,
															unsigned char* piRdsSyncStatus,
															unsigned char* piMuteMode );

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Set RX RDS Group Options

	This function enables or disables various RDS/RBDS group filtering and buffering features. 
		Included in these features are the RDS group enable mask, RDS/RBDS group change filter, 
		and the RDS/RBDS group buffer size. 
		This is an asynchronous function used to set or unset various Rx RDS/RBDS group filtering 
		and buffering options in the FM driver. 

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iMask = A bitmask of RDS/RBDS groups to enable. 
	\param iGroupBufferSize = The number of RDS/RBDS groups to buffer before sending to the client. Max is 21 groups
	\param bChangeFilterEnabled = Flag used to determine whether the RDS/RBDS change filter should be enabled
		\code
			0 = FTM_FM_RX_RDS_CHANGE_FILTER_DISABLED 
			1 = FTM_FM_RX_RDS_CHANGE_FILTER_ENABLED
		\endcode
	\return true if successful, false if fail.

	\warning QLIB_FTM_FM_RX_ENABLE_RECEIVER must be called before this.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_RX_RDS_GROUP_OPTIONS(HANDLE hResourceContext, 
															unsigned long iMask, 
															unsigned long iGroupBufferSize, 
															unsigned char bChangeFilterEnabled);

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Enable Transmitter

	Powers on and initializes the FM transmitter. 
		This is an asynchronous command used to power on the FM-RDS transmitter. 
		If not already enabled, this function will intialize the transmitter with default settings. 
		Only after successfully calling this function can many of the FM transmitter interfaces be used.
		When enabling the transmitter, the client must also provide the regional settings in which 
		the transmitter will operate. These settings are typically used for setting up the FM transmitter 
		for operating in a particular geographical region. These settings can be changed through 
		the use of the function QLIB_FTM_FM_TX_CONFIGURE_TRANSMITTER.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iRadioBand = 
		\code
			0 = FM_US_EUROPE_BAND		( 87.5 MHz <-> 108 MHz)
			1 = FM_JAPAN_STANDARD_BAND	( 76   MHz <-> 90 MHz)
			2 = FM_JAPAN_WIDE_BAND		( 76   MHz <-> 108 MHz)
			3 = FM_USER_DEFINED_BAND	(as defined by parameters iUserDefinedBandFreqMin & iUserDefinedBandFreqMax)
		\endcode
	\param  iEmphasis = 
		\code
			0 = FM_DE_EMP75				(pre-emphasis/de-emphasis typically used in the United States and Japan.)
			1 = FM_DE_EMP50				(pre-emphasis/de-emphasis typically used outside of the United states and Japan.)
		\endcode
	\param  iChSpacing = 
		\code
			0 = FM_CHSPACE_200_KHZ
			1 = FM_CHSPACE_100_KHZ
			2 = FM_CHSPACE_50_KHZ
		\endcode
	\param  iRdsStd = 
		\code
			0 = FM_RDS_STD_RBDS			RBDS mode (Typically used in the United States). 
			1 = FM_RDS_STD_RDS			RDS mode (Typically used outside of the United States). 
			2 = FM_RDS_STD_NONE			No RDS/RBDS decoding. 
		\endcode
	\param  iUserDefinedBandFreqMin = min freq (in KHz) for FM_USER_DEFINED_BAND, must be >= 76000
	\param  iUserDefinedBandFreqMax = max freq (in KHz) for FM_USER_DEFINED_BAND, must be <= 108000 AND > iUserDefinedBandFreqMin

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_TX_ENABLE_TRANSMITTER( HANDLE hResourceContext, 
															unsigned char iRadioBand,
															unsigned char iEmphasis,
															unsigned char iChSpacing,
															unsigned char iRdsStd,
															unsigned long iUserDefinedBandFreqMin,
															unsigned long iUserDefinedBandFreqMax );

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Disable Transmitter

	Powers off and disables the FM transmitter. 
		This is an asynchronous command used to power-off and disable the FM transmitter. 
		This function is expected to be used when the client no longer needs use of the FM transmitter. 
		While powered off, most functionality offered by the FM transmitter will also be disabled until 
		the client re-enables the device again via QLIB_FTM_FM_TX_ENABLE_TRANSMITTER.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_TX_DISABLE_TRANSMITTER( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Configure Transmitter

	Reconfigures the transmitters regional settings (FM Band, Pre-emphasis, Channel Spacing, RDS/RBDS mode). 
		This is an asynchronous command used to reconfigure various settings of the transmitter.
		These settings typically differ from one geographical region to another.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iRadioBand = 
		\code
			0 = FM_US_EUROPE_BAND		( 87.5 MHz <-> 108 MHz)
			1 = FM_JAPAN_STANDARD_BAND	( 76   MHz <->  90 MHz)
			2 = FM_JAPAN_WIDE_BAND		( 76   MHz <-> 108 MHz)
			3 = FM_USER_DEFINED_BAND	(as defined by parameters iUserDefinedBandFreqMin & iUserDefinedBandFreqMax)
		\endcode
	\param  iEmphasis = 
		\code
			0 = FM_DE_EMP75				(pre-emphasis/de-emphasis typically used in the United States and Japan.)
			1 = FM_DE_EMP50				(pre-emphasis/de-emphasis typically used outside of the United states and Japan.)
		\endcode
	\param  iChSpacing = 
		\code
			0 = FM_CHSPACE_200_KHZ
			1 = FM_CHSPACE_100_KHZ
			2 = FM_CHSPACE_50_KHZ
		\endcode
	\param  iRdsStd = 
		\code
			0 = FM_RDS_STD_RBDS			RBDS mode (Typically used in the United States). 
			1 = FM_RDS_STD_RDS			RDS mode (Typically used outside of the United States). 
			2 = FM_RDS_STD_NONE			No RDS/RBDS decoding. 
		\endcode
	\param  iUserDefinedBandFreqMin = min freq (in KHz) for FM_USER_DEFINED_BAND, must be >= 76000
	\param  iUserDefinedBandFreqMax = max freq (in KHz) for FM_USER_DEFINED_BAND, must be <= 108000 AND > iUserDefinedBandFreqMin

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_TX_CONFIGURE_TRANSMITTER( HANDLE hResourceContext, 
																unsigned char iRadioBand,
																unsigned char iEmphasis,
																unsigned char iChSpacing,
																unsigned char iRdsStd,
																unsigned long iUserDefinedBandFreqMin,
																unsigned long iUserDefinedBandFreqMax );

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Set FM TX RF frequency

	 Tunes the FM transmitter to the supplied FM frequency. 
		This is an asynchronous command which tunes the FM transmitter to a station as specified 
		by the supplied frequency. Only valid frequencies within the band set by 
		QLIB_FTM_FM_TX_ENABLE_TRANSMITTER or QLIB_FTM_FM_TX_CONFIGURE_TRANSMITTER can be tuned by this function. 
		Attempting to tune to frequencies outside of the set band will result in an error.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iFreqkHz = 
		\code
			The frequency must be a multiple of 50 KHz and within the band ranges defined below

			FM_US_EUROPE_BAND:
				US/Europe FM band (87500 KHz <-> 108000 KHz)

			FM_JAPAN_STANDARD_BAND:
				Japan Standard Band (76000 KHz <-> 90000 KHz)

			FM_JAPAN_WIDE_BAND  
				Japan Wide Band (76000 KHz <-> 108000 KHz)

			FM_USER_DEFINED_BAND  
				User defined band ( x KHz <-> y KHz where x < y and x >= 76000 KHz and y <= 108000 KHz)

		\endcode
	\return true if successful, false if fail.

	\warning QLIB_FTM_FM_TX_ENABLE_TRANSMITTER must be called before this.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_TX_SET_STATION( HANDLE hResourceContext, unsigned long iFreqkHz );

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Set FM TX RDS Groups 

	This function will transmit RDS/RBDS groups over an already tuned station. 
		This function accepts a buffer containing one or more RDS groups. 
		When sending this buffer, the client must also indicate how many groups 
		should be taken from this buffer. 

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iNumTxRdsGroups = The number of RDS/RBDS groups to transmit 
	\param  aiRdsData = Data containing one or more RDS groups; each consisting of 4 words (unsigned short)
	\return true if successful, false if fail.

	\warning QLIB_FTM_FM_TX_ENABLE_TRANSMITTER must be called before this.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_TX_TX_RDS_GROUPS(HANDLE hResourceContext, unsigned long iNumTxRdsGroups, unsigned short* aiRdsData);
	
	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Set FM TX Continuous RDS Groups 

	This function will continuously transmit RDS/RBDS groups over an already tuned station. 
		This function accepts a buffer containing one or more RDS groups. 
		The FM client can pass a complete RDS group buffer to the FM driver 
		which will be sent continuously by the FM transmitter or driver. 
		This continuous transmission frees the client from needing to pass a 
		constant stream of RDS/RBDS groups. 
		However, only a single RDS/RBDS group buffer can be continuously transmitted 
		at a time. Because of this fact, it is important that the client only pass 
		the complete buffer it intends to transmit. Attempting to pass a buffer in two calls 
		to this interface will be interpreted as two different RDS/RBDS transmits 
		and all unsent groups may be cleared.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iNumTxRdsGroups = The number of RDS/RBDS groups to transmit 
	\param  aiRdsData = Data containing one or more RDS groups; each consisting of 4 words (unsigned short)
	\return true if successful, false if fail.

	\warning QLIB_FTM_FM_TX_ENABLE_TRANSMITTER must be called before this.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_TX_TX_CONT_RDS_GROUPS(HANDLE hResourceContext, unsigned long iNumTxRdsGroups, unsigned short* aiRdsData);

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Set FM TX Transmit RDS Group Control 

	This function is used to pause/resume RDS/RBDS group transmission, or stop and clear all RDS groups. 
		This function can be used with to control continuous and non-continuous RDS/RBDS group transmissions.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iRdsCtrl = 
		\code
			0 = FTM_TX_RDS_GROUP_PAUSE
			1 = FTM_TX_RDS_GROUP_CLEAR
			2 = FTM_TX_RDS_GROUP_RESUME
		\endcode
	\return true if successful, false if fail.

	\warning QLIB_FTM_FM_TX_ENABLE_TRANSMITTER must be called before this.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_TX_TX_RDS_CTRL(HANDLE hResourceContext, unsigned char iRdsCtrl );

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, Get TX RDS Group Buffer Size 
	
	This function will return the maximum number of RDS/RBDS groups which can be passed to the FM driver. 
		This is used to determine the maximum RDS/RBDS buffer size for use when calling Transmit RDS groups and Transmit continuous RDS groups.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piGroupBufferSize = Returns The maximum number (0-62) of RDS/RBDS groups which can be passed to the FM driver at any one time.
	\return true if successful, false if fail.

	\warning QLIB_FTM_FM_TX_ENABLE_TRANSMITTER must be called before this.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_TX_GET_RDS_GROUP_BUF_SIZE(HANDLE hResourceContext, unsigned long* piGroupBufferSize);

	/******************************************************************************/
	/**
	Factory Test Mode FM, Set FM Audio Route command

	
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iFmAudioRoute - set the audio route to/from the FM core
		\code
			0 = Audio to/from the FM core disabled. 
			1 = Analog audio from the FM core enabled. 
			2 = Digital audio from the FM core enabled (FM core is the master). 
			3 = Digital audio from the FM core enabled (FM core is the slave). 
			4 = Analog and digital audio from the FM core enabled (FM core is the master). 
			5 = Analog and digital audio from the FM core enabled (FM core is the slave). 
			6 = FM core digital input enabled (FM core is the master). 
			7 = FM core digital input enabled (FM core is the slave). 
		\endcode

	\return true if successful, false if fail.

	\warning 

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_SET_ROUTE_AUDIO( HANDLE hResourceContext, unsigned char iFmAudioRoute );

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, SET SIGNAL THRESHOLD

	Set the threshold that the FM driver uses to determine which stations have service available
	
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iThreshold
		\code
			0 = FM_RX_THRESHOLD_VERY_WEAK
			1 = FM_RX_THRESHOLD_WEAK
			2 = FM_RX_THRESHOLD_STRONG
			3 = FM_RX_THRESHOLD_VERY_STRONG
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_RX_SET_SIGNAL_THRESHOLD(HANDLE hResourceContext, unsigned char   iThreshold);
	QLIB_API unsigned char QLIB_FTM_FM_RX_GET_SIGNAL_THRESHOLD(HANDLE hResourceContext, unsigned char* piThreshold);

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, SET RX RDS GROUP PROCESSING OPTIONS

	This function enables or disables RDS/RBDS group processing features.
	
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iRdsProcOptions = Bit mask to determine what RDS processing the FM driver/hardware will do
		\code
			0x01 = FM_RX_RDS_GRP_RT_EBL			(RDS/RBDS Radio Text processing enable bit)
			0x02 = FM_RX_RDS_GRP_PS_EBL			(RDS/RBDS Program Service processing enable bit)
			0x04 = FM_RX_RDS_GRP_PS_SIMPLE_EBL	(RDS/RBDS Simple Program Service processing enable bit)
			0x08 = FM_RX_RDS_GRP_AF_EBL			(RDS/RBDS Alternative Frequency processing enable bit)
			0x10 = FM_RX_RDS_GRP_AF_JUMP_EBL	(RDS/RBDS Alternative Frequency Auto Jump enable bit)
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_RX_RDS_GROUP_PROC_OPTIONS(HANDLE hResourceContext, unsigned long iRdsProcOptions);

	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, SEARCH STATIONS

	This function initiates basic seek and scan operations
	
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iSearchMode		This setting decribes different search modes offered by the FM driver
		\code
			0 = FM_RX_SRCH_MODE_SEEK	(FM driver will tune to the next station that meets a signal level requirement)
			1 = FM_RX_SRCH_MODE_SCAN	(FM driver will tune to all stations that meet a signal level requirement)
		\endcode
	\param  iScanDwellTime	This setting describes how long, in seconds, the FM driver will stay tuned to a station during a scan.
		\code
			1 = FM_RX_DWELL_PERIOD_1S	(FM driver will remain tuned to the a station for 1 second  during a scan)
			2 = FM_RX_DWELL_PERIOD_2S	(FM driver will remain tuned to the a station for 2 seconds during a scan)
			3 = FM_RX_DWELL_PERIOD_3S	(FM driver will remain tuned to the a station for 3 seconds during a scan)
			4 = FM_RX_DWELL_PERIOD_4S	(FM driver will remain tuned to the a station for 4 seconds during a scan)
			5 = FM_RX_DWELL_PERIOD_5S	(FM driver will remain tuned to the a station for 5 seconds during a scan)
			6 = FM_RX_DWELL_PERIOD_6S	(FM driver will remain tuned to the a station for 6 seconds during a scan)
			7 = FM_RX_DWELL_PERIOD_7S	(FM driver will remain tuned to the a station for 7 seconds during a scan)
		\endcode
	\param  iSearchDirection	This setting decribes whether searches will increment or decrement frequencies while searching the band
		\code
			0 = FM_RX_SEARCHDIR_UP		(Each frequency searched will be greater than the previous frequency, except when wrapping around the band)
			1 = FM_RX_SEARCHDIR_DOWN	(Each frequency searched will be less than the previous frequency, except when wrapping around the band)
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_RX_SEARCH_STATIONS(HANDLE hResourceContext, unsigned char iSearchMode, unsigned char iScanDwellTime, unsigned char iSearchDirection);
	/******************************************************************************/
	/**
	Factory Test Mode FM Commands, CANCEL SEARCH

	This function cancels any ongoing search operation (including seek, scan, and searchlist)
	
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_RX_CANCEL_SEARCH(HANDLE hResourceContext);
	/******************************************************************************/
	/******************************************************************************/
	/**
	Factory Test Mode FM, Set FM Alternate Frequency Threshold
	
	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iAfThresholdLog - AF threshold to set in dBm (must be between -101 and -70 dBm)

	\return true if successful, false if fail.

	\warning 

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_RX_SET_AF_THRESHOLD(HANDLE hResourceContext, short   iAfThresholdLog);
	QLIB_API unsigned char QLIB_FTM_FM_RX_GET_AF_THRESHOLD(HANDLE hResourceContext, short* piAfThresholdLog);

	/******************************************************************************/
	/**
	Factory Test Mode FM, Set FM RSSI CHECK TIMER
	
	This command set the periodic time interval for monitoring channel condition

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iChCondTimer - each timer counts represents 5 ms

	\return true if successful, false if fail.

	\warning 

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_RX_SET_RSSI_CHECK_TIMER(HANDLE hResourceContext, unsigned char   iChCondTimer);
	QLIB_API unsigned char QLIB_FTM_FM_RX_GET_RSSI_CHECK_TIMER(HANDLE hResourceContext, unsigned char* piChCondTimer);

	/******************************************************************************/
	/**
	Factory Test Mode FM, Set FM RDS PI TIMER
	
	This command set the time to wait for RDS interrupt before declaring no RDS on channel

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iRdsTimeout - each timer counts represents 5 ms

	\return true if successful, false if fail.

	\warning 

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_FM_RX_SET_RDS_PI_TIMER(HANDLE hResourceContext, unsigned char   iRdsTimeout);
	QLIB_API unsigned char QLIB_FTM_FM_RX_GET_RDS_PI_TIMER(HANDLE hResourceContext, unsigned char* piRdsTimeout);

/******************************************************************************
						Software Download
*******************************************************************************/

	/******************************************************************************/
	/**
	Upload a HEX file from the PC to the phone.

	This is also commonly referred to as "software download," but in a technical sense
	the information is being transferred from the PC to the phone, so the function name
	is based on the "upload" operation

	Note: This function requires the use of QPST. 

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sFileName = the local path and filename of the hex file to upload.
	\param sSPC = Service Provider Code, normally "000000"
	\param bClearErrorLog = true to clear phone's NV items which start the most recent errors.
	\param bOverrideModelCheck = true to allow a mismtach between the HEX file and the phone's model identifier
	\param bSkipReset = true to skip the reset of the phone after the HEX file is downloaded
	\param bUseCustomArmProg = true to always use "ARMPRG.HEX"

							   false, the ARM PROG file will be determined by querying the phone
							   model and selecting the correct APRGxxxx.HEX file.

								These files are always in the QPST Server executable folder, usually
								C:\Program Files\QPST\bin

	\param bUploadArmProg = true to send ARMPROG, false to not send ARMPROG
	\param bDoAutoRestoreBackup = true to backup the phone's NV data to the QCN file indicated
									by sAutoRestoreBackupName.
	\param sAutoRestoreBackupName = Name of the QCN file to backup the phone's data into.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_UploadHexFile
	(
		HANDLE hResourceContext,
		char* sFileName,
		char* sSPC,
		unsigned char  bClearErrorLog,
		unsigned char  bOverrideModelCheck,
		unsigned char  bSkipReset,
		unsigned char  bUseCustomArmProg,
		unsigned char  bUploadArmProg,
		unsigned char  bDoAutoRestoreBackup,
		char* sAutoRestoreBackupName
	);

	/******************************************************************************/
	/**
	Upload a QCN (NV memory contents) file from the PC to the phone.

	Note: This function requires the use of QPST. 

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sFileName = Path and file name of QCN file
	\param sSPC = Service provider code, usually "000000"
	\param bAutoRestore = true always, when sending a QCN file to the phone
	\param bSkipReset = true to not reset after QCN file uploaded, false to force reset after QCN file is uploaded
	\param bAllowEsnMismatch = true to allow the ESN to be mismatched between the QCN file and the phone
	\param bIgnorePhoneModel = true to allow the phone model number to be mismatched between the QCN file and the phone

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_UploadQcnFile
	(
		HANDLE hResourceContext,
		char* sFileName,
		char* sSPC,
		unsigned char bAutoRestore,
		unsigned char bSkipReset,
		unsigned char bAllowEsnMismatch,
		unsigned char bIgnorePhoneModel
	);

	/******************************************************************************/
	/**
	Download a QCN (NV memory contents) file from the phone to the PC.

	Note: This function requires the use of QPST. 

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sFileName = Path and file name of QCN file
	\param sSPC = Service provider code, usually "000000"

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DownloadQcnFile
	(
		HANDLE hResourceContext,
		char* sFileName,
		char* sSPC
	);

	/******************************************************************************/
	/**
	Download boot loader image taken from hex file from PC to MP and next should restart
	MP (but this funtionality is not done good in MP).
	QLIB_UploadBootLoaderOnlyHexFile

	Note: This function requires the use of QPST. 


	*******************************************************************************/
	QLIB_API unsigned char QLIB_UploadBootLoaderOnlyHexFile(
							 HANDLE hResourceContext,
							 char* sFileName, char* sSPC,
							 unsigned char bUseCustomArmProg,
							 unsigned char bUploadArmProg
							);

	/******************************************************************************/
	/**
	Upload a Boot file from the PC to the phone.

	Note: This function requires the use of QPST. 

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sFileName = the local path and filename of the hex boot file to upload.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_UploadBootFileBeforeHexFile
	(
		HANDLE hResourceContext,
		char* sFileName
	);

	/******************************************************************************/
	/**
	Upload a CEFS file from the PC to the phone.

	Note: This function requires the use of QPST. 

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sFileName = the local path and filename of the CEFS file to upload.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_UploadCEFS_File
	(
		HANDLE hResourceContext,
		char* sFileName,
		char* sPartitionFileName
	);

	/******************************************************************************/
	/**
	Upload a CEFS file from the PC to the phone, specifying the ARMPROG file, for
	use when the phone is already in download mode.
	This is equivalent to QPST SW Download CEFS tab, "Restore Modem CEFS", function

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sFileName = the local path and filename of the CEFS file to upload.
  	\param iDloadArmprg = if bUseCustomArmprg = false, then ID of the ARMPRG to use
	                       refer to the enumeration, dloadArmprgType

	\code
	From QPST code, SharedInc/ArmprgType.h:

typedef enum		// Default armprg to use when mobile alread in download mode.
{
                    // apStandard must be first.
  apStandard,		    // MSM3000, 3100, 3300, 5000, 5010, 5100, 5105

  apMSM6000,    // MSM6000
  apMSM6050,    // MSM6050
  apMSM6200_1,  // MSM6200 Cheetah
  apMSM6100,    // MSM6100 Cougar with NOR flash
  apMSM6100NAND,// MSM6100 Cougar with NAND flash.
  apMSM6250,      // MSM6250 (Saber) NOR flash
  apMSM6250NAND,  // MSM6250 (Saber) NAND flash
  apMSM6500,      // MSM6500 (Jaguar) NOR flash
  apMSM6500NAND,  // MSM6500 (Jaguar) NAND flash
  apMSM6100NORFFA, // MSM6100 FFA with NOR flash
  apMSM6550,       // MSM6550 (Eagle) NOR flash
  apMSM6550NAND,   // MSM6550 NAND (3/9/05)
  apMSM6550PB,     // MSM6550 progressive boot
  apEM6700,        // MSM6700 emulator (Quasar)
  apMSM6275NOR,    // MSM6275 (Raven) NOR
  apMSM6275NAND,   // MSM6275 (Raven) NAND
  apMSM6800NOR,    // MSM6800 (DoRA) NOR
  apMSM6800NAND,   // MSM6800 (DoRA) NAND
  apMSM6250Sec,    // MSM6250 secure (one-time programmable)
  apMSM7500NAND,   // MSM7500 (Phoenix)
  apMSMSC1x,       // SC1x a.k.a. QSC, NOR progressive
  apMSM6280NAND,   // MSM6280 NAND multi-image
  apMSM7200NAND,   // MSM7200 NAND multi-image
  apMSM7500NOR,    // MSM7500 NOR multi-image
  apMSM6260NAND,   // MSM6260 NAND
  apMSM6245NAND,   // MSM6245 NAND multi-image, progressive
  apMSM6255aNAND,  // MSM6255A NAND, progressive
  apMSM6800NAND65nm,  // 65nm MSM6800
  apMSMSC2x,       // SC2x a.k.a. QSC60x5
  apMSM7200a,      // MSM7200a
  apMSM7600,       // MSM7600
  apMSMSC2xNOR,     // SC2x using aprg60x5.hex (NOR)
  apMSMSC2xNAND,    // SC2X using nprg60x5.hex (NAND),
  apMSM6260NOR,     // MSM6260 NOR
  apMSM7500a,       // MSM7500a, NAND
  apMDM1000,        // MSM7200a/7500a NOR
  apMSM6235NOR,     // MSM6235 NOR
  apMSM6235NAND,    // MSM6235 NAND
  apMSM7225NAND,    // MSM7225 NAND
  apMSM6246NAND,    // MSM6246 NAND

                    // 11/16/07 added for consistency:
  apMSM6245NOR,     // APRG6245.HEX
  apMSM6246NOR,     // APRG6246.HEX
  apMSM6255aNOR,    // APRG6255A.HEX
  apMSM6800bNOR,    // APRG6800B.HEX
  apMSM7200NOR,     // APRG7200.HEX
  apMSM7200aNOR,    // APRG7200A.HEX
  apMSM7225NOR,     // APRG7225.HEX
  apMSM7500aNOR,    // APRG7500A.HEX
  apMSM7600NOR,     // APRG7600.HEX

  apMSM7800NAND,    // NPRG7800.HEX
  apMSMQSC6270x40NAND,  // QSC6270/40

  apQsd8250NANDV1,  // NPRG8250.HEX
  apQsd8650NANDV1,  // NPRG8650.HEX
  apQsc1100NOR,     // APRG1100.HEX
  apQsc1110NOR,     // APRG1110.HEX
  apQsd8250NANDV2,  // NPRG8250.HEX
  apQsd8650NANDV2,  // NPRG8650.HEX

  apQst1105NAND,    // NPRG1105A.HEX

  apMSM7625NAND,
  apQsc7630NAND,

  apMDM8200NAND,

  apQst1105NOR,
  apQsc6295NAND,

  apMsm1500NAND,
  apMsm1500NOR,
  apMsm1600NAND,
  apMsm1600NOR,
  apMsm1700NAND,
  apMsm1700NOR,

  apMsm7525NAND,
  apMsm7627NAND,

  apMarkerForDialog // apMarkerForDialog must be last.

	} dloadArmprgType ;
	\endcode

	Note: This function requires the use of QPST. 

	\return true if successful, false if fail.

	\warning This function is grouped with the EFS functions, not the download functions,
	         so it is important to check for errors in the EFS area, not Software download.

			 This might be a little confusing because the other CEFS functions are grouped
			 under software download.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_UploadCEFS_File2
	(
		HANDLE hResourceContext,
		char* sFileName,
		char* sPartitionFileName,
		long iDloadArmprg
	);


	/******************************************************************************/
	/**
	Upload a CEFS file from the PC to the phone alternate filesystem, specifying the ARMPROG file, for
	use when the phone is already in download mode.

	This is equivalent to QPST SW Download CEFS tab, "Restore Applications CEFS", function

	Note: This function requires the use of QPST. 

	\param sFileName = the path and filename of the CEFS file to upload.
	\param sPartitionFileName = the path and filename of the partition file to upload.
  	\param iDloadArmprg = ID of the ARMPRG to use
	                       refer to the enumeration, dloadArmprgType

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_UploadCEFS_ImageAlternate
	(
		HANDLE hResourceContext,
		char* sFileName,
		char* sPartitionFileName,
		long iDloadArmprg
	);


	/******************************************************************************/
	/**
	Backup a CEFS file from the mobile modem file system to PC

	This is equivalent to QPST SW Download CEFS tab, "Backup Legacy CEFS", function

	Note: This function requires the use of QPST. 

	\param sFileName = the PC path and filename of the CEFS file to be stored.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_BackupCEFS_Legacy
	(
		HANDLE hResourceContext,
		char* sFileName
	);


	/******************************************************************************/
	/**
	Backup a CEFS file from the mobile alternate file system to PC

	This is equivalent to QPST SW Download CEFS tab, "Backup Alternate CEFS", function

	Note: This function requires the use of QPST. 

	\param sFileName = the PC path and filename of the CEFS file to be stored.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_BackupCEFS_Alternate
	(
		HANDLE hResourceContext,
		char* sFileName
	);


	/******************************************************************************/
	/**
	Restore a raw CEFS file from PC to the mobile alternate file

	This is equivalent to QPST SW Download CEFS tab, "Write raw (spare+data) Apps EFS image", function

	Note: This function requires the use of QPST. 

	\param sFileName = the path and filename of the CEFS file to upload..

	\param sPartitionFileName = the path and filename of the partition file to upload.

	\param iDloadArmprg =  ID of the ARMPRG to use
	                       refer to the enumeration, dloadArmprgType


	\return true if successful, false if fail.

	\warning

	******************************************************************************/
	QLIB_API unsigned char QLIB_StartRestoreRawAppsEfsImage
	(
		HANDLE hResourceContext,
		char* sFileName,
		char* sPartitionFileName,
		long iDloadArmprg
	);

	/******************************************************************************/
	/**
	Restore a factory file from PC to the mobile mobile

	This is equivalent to QPST SW Download Factory Image tab

	Note: This function requires the use of QPST. 

	\param sFileName = the path and filename of the CEFS file to upload.

	\param useCustomArmprg = true to always use "ARMPRG.HEX"

							   false, the ARM PROG file will be determined by querying the phone
							   model and selecting the correct APRGxxxx.HEX file.

	\param iDloadArmprg = if bUseCustomArmprg = false, then ID of the ARMPRG to use
	                       refer to the enumeration, dloadArmprgType


	\return true if successful, false if fail.

	\warning

	******************************************************************************/

	QLIB_API unsigned char QLIB_StartFactoryImageDownload
	(
		HANDLE hResourceContext,
		char* sFileName,
		unsigned char bUseCustomArmPrg,
		long iDloadArmprg
	);

	/******************************************************************************/
	/**
	Upload a multi-image software image from the PC to the phone.  This function
	performs an "OBL" download, which is equivalent to the QPST Software Download application.

	For the following string inputs DON'T PASS NULL's, use "".  To control which files
	will be sent, use the paraemter, iDownloadBitMask.

	Note: This function requires the use of QPST. 

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sPartitionFileName = partition path and file name, usually "partition.mbn"
	\param sOTBPL_FileName = OTBPL path and file name, usually "obl.mbn"
	\param sPBL_FileName = Primary Boot Loader, usually "pbl.mbn"
	\param sQCSBL_FileName = secure boot loader, usually "qcsblhd_cfgdata.mbn"
	\param sQCSBL_HeaderName = secure boot loader header, usually "qcsbl.mbn"
	\param sOEMSBL_FileName = OEM secure boot loader, usually "oemsbl.mbn"
	\param sOEMSBL_HeaderName = OEM secure boot loader header, usually "oemsblhd.mbn"
	\param sModemFileName = AMSS File, usually "amss.mbn"
	\param sModemHeaderName = AMSS Header, usually "amsshd.mbn"
	\param sAppsFileName = Application file
	\param sAppsHeaderName = Application header file
	\param char bOverridePrtnTable = TRUE to overwrite the stored partition table in the phone
	\param char bUseTrustedMode = TRUE to use trusted mode and the AMSS has a built-in PBL.
	                              If FALSE, then PBL must be provided.

	\param sSPC = Service Programming Code, usually "000000"
	\param bClearErrorLog = TRUE to clear the QPST error log
	\param sStorageFile = file name of temporary QCN file
	\param bOverrideModelCheck = TRUE to override a model number check
	\param bSkipReset = TRUEto skip the reset operation after the phone is programmed
	\param bUseCustomArmprg =  FALSE to let QPST server determine which ARMPRG to bet used.
	                          If TRUE, then the NPRG or ARMPRG will be searched for in the
							  same folder as the modem file name.
	\param iDloadArmprg = if bUseCustomArmprg = false, then ID of the ARMPRG to use
	                       refer to the enumeration, dloadArmprgType
	\param iDownloadBitMask = bitmask of files to download, based on SWD_miFileTypeBitmask_enum

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_UploadMultiImage
	(
		HANDLE hResourceContext,
		char* sPartitionFileName,
		char* sOTBPL_FileName,
		char* sPBL_FileName,
		char* sQCSBL_FileName,
		char* sQCSBL_HeaderName,
		char* sOEMSBL_FileName,
		char* sOEMSBL_HeaderName,
		char* sModemFileName,
		char* sModemHeaderName,
		char* sAppsFileName,
		char* sAppsHeaderName,
		char* sAppsBlFileName,
		char* sAppsBlHeaderFileName,
		unsigned char bOverridePrtnTable,
		unsigned char bUseTrustedMode,
		char* sSPC,
		unsigned char bClearErrorLog,
		char* sStorageFile,
		unsigned char bOverrideModelCheck,
		unsigned char bSkipReset,
		unsigned char bUseCustomArmprg,
		long iDloadArmprg,
		long iDownloadBitMask
	);

	/******************************************************************************/
	/**
	Upload a multi-image software image from the PC to the phone.  This function
	is equivalent to the "Multi-image" tab in the QPST Software Download application.

	For the following string inputs DON'T PASS NULL's, use "".  To control which files
	will be sent, use the paraemter, iDownloadBitMask.

	Note: This function requires the use of QPST. 

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sPartitionFileName = partition path and file name, usually "partition.mbn"
	\param sPBL_FileName = Primary Boot Loader, usually "pbl.mbn"
	\param sQCSBL_FileName = secure boot loader, usually "qcsblhd_cfgdata.mbn"
	\param sQCSBL_HeaderName = secure boot loader header, usually "qcsbl.mbn"
	\param sOEMSBL_FileName = OEM secure boot loader, usually "oemsbl.mbn"
	\param sOEMSBL_HeaderName = OEM secure boot loader header, usually "oemsblhd.mbn"
	\param sModemFileName = AMSS File, usually "amss.mbn"
	\param sModemHeaderName = AMSS Header, usually "amsshd.mbn"
	\param sAppsFileName = Application file
	\param sAppsHeaderName = Application header file
	\param sAppsBlFileName = Application boot loader file
	\param sAppsBlHeaderFileName = Application boot loader header file
	\param char bOverridePrtnTable = TRUE to overwrite the stored partition table in the phone
	\param char bUseTrustedMode = TRUE to use trusted mode and the AMSS has a built-in PBL.
	                              If FALSE, then PBL must be provided.

	\param sSPC = Service Programming Code, usually "000000"
	\param bClearErrorLog = TRUE to clear the QPST error log
	\param sStorageFile = file name of temporary QCN file
	\param bOverrideModelCheck = TRUE to override a model number check
	\param bSkipReset = TRUEto skip the reset operation after the phone is programmed
	\param bUseCustomArmprg =  FALSE to let QPST server determine which ARMPRG to bet used.
	                          If TRUE, then the NPRG or ARMPRG will be searched for in the
							  same folder as the modem file name.
	\param iDloadArmprg = if bUseCustomArmprg = false, then ID of the ARMPRG to use
	                       refer to the enumeration, dloadArmprgType
	\param iDownloadBitMask = bitmask of files to download, based on SWD_miFileTypeBitmask_enum

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_UploadMultiImage2
	(
		HANDLE hResourceContext,
		char* sPartitionFileName,
		char* sPBL_FileName,
		char* sQCSBL_FileName,
		char* sQCSBL_HeaderName,
		char* sOEMSBL_FileName,
		char* sOEMSBL_HeaderName,
		char* sModemFileName,
		char* sModemHeaderName,
		char* sAppsFileName,
		char* sAppsHeaderName,
		char* sAppsBlFileName,
		char* sAppsBlHeaderFileName,
		unsigned char bOverridePrtnTable,
		unsigned char bUseTrustedMode,
		char* sSPC,
		unsigned char bClearErrorLog,
		char* sStorageFile,
		unsigned char bOverrideModelCheck,
		unsigned char bSkipReset,
		unsigned char bUseCustomArmprg,
		long iDloadArmprg,
		long iDownloadBitMask
	);

	/******************************************************************************/
	/**
	Upload a multi-image software image from the PC to the phone.  This function
	is equivalent to the "Multi-image" tab in the QPST Software Download application,
	and the main difference from version 2 is that it supports a Windows Mobile image

	For the following string inputs DON'T PASS NULL's, use "".  To control which files
	will be sent, use the paraemter, iDownloadBitMask.

	Note: This function requires the use of QPST. 

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sPartitionFileName = partition path and file name, usually "partition.mbn"
	\param sPBL_FileName = Primary Boot Loader, usually "pbl.mbn"
	\param sQCSBL_FileName = secure boot loader, usually "qcsblhd_cfgdata.mbn"
	\param sQCSBL_HeaderName = secure boot loader header, usually "qcsbl.mbn"
	\param sOEMSBL_FileName = OEM secure boot loader, usually "oemsbl.mbn"
	\param sOEMSBL_HeaderName = OEM secure boot loader header, usually "oemsblhd.mbn"
	\param sModemFileName = AMSS File, usually "amss.mbn"
	\param sModemHeaderName = AMSS Header, usually "amsshd.mbn"
	\param sAppsFileName = Application file
	\param sAppsHeaderName = Application header file
	\param sAppsBlFileName = Application boot loader file
	\param sAppsBlHeaderFileName = Application boot loader header file
	\param sWinMobileImageFileName = Windows Mobile Image file
	\param char bOverridePrtnTable = TRUE to overwrite the stored partition table in the phone
	\param char bUseTrustedMode = TRUE to use trusted mode and the AMSS has a built-in PBL.
	                              If FALSE, then PBL must be provided.

	\param sSPC = Service Programming Code, usually "000000"
	\param bClearErrorLog = TRUE to clear the QPST error log
	\param sStorageFile = file name of temporary QCN file
	\param bOverrideModelCheck = TRUE to override a model number check
	\param bSkipReset = TRUEto skip the reset operation after the phone is programmed
	\param bUseCustomArmprg =  FALSE to let QPST server determine which ARMPRG to bet used.
	                          If TRUE, then the NPRG or ARMPRG will be searched for in the
							  same folder as the modem file name.
	\param iDloadArmprg = if bUseCustomArmprg = false, then ID of the ARMPRG to use
	                       refer to the enumeration, dloadArmprgType
	\param iDownloadBitMask = bitmask of files to download, based on SWD_miFileTypeBitmask_enum

	\return true if successful, false if fail.

	\warning !!! This function has not been tested yet.  It will be tested for the QDART 3.2.20
	         release on December 14, 2007 !!!

	*******************************************************************************/
	QLIB_API unsigned char QLIB_UploadMultiImage3
	(
		HANDLE hResourceContext,
		char* sPartitionFileName,
		char* sPBL_FileName,
		char* sQCSBL_FileName,
		char* sQCSBL_HeaderName,
		char* sOEMSBL_FileName,
		char* sOEMSBL_HeaderName,
		char* sModemFileName,
		char* sModemHeaderName,
		char* sAppsFileName,
		char* sAppsHeaderName,
		char* sAppsBlFileName,
		char* sAppsBlHeaderFileName,
		char* sWinMobileImageFileName,
		unsigned char bOverridePrtnTable,
		unsigned char bUseTrustedMode,
		char* sSPC,
		unsigned char bClearErrorLog,
		char* sStorageFile,
		unsigned char bOverrideModelCheck,
		unsigned char bSkipReset,
		unsigned char bUseCustomArmprg,
		long iDloadArmprg,
		long iDownloadBitMask
	);

	/******************************************************************************/
	/**
	Upload a multi-image software image (Multimage Download 1.0) from the PC to the phone.  This function supports using
	emegerncy download.  The function requires QPST 2.7.335 or beyond for runtime.

	The following statement is taken from QPST 2.7.335 release note section.  QPST release note can be found
	in "c:\program files\QPST\bin\readme.txt

	"Added "Use Emerg. Host D/L" feature to Software Download. This feature will only work with chipsets
    that support emergency host download, and allows you to download new images to a mobile device that
    has an empty or corrupted flash device. If you enable this feature Software Download will
    attempt to use a special flash programmer (eNPRGxxxx.hex) that is chipset-dependant"

	For the following string inputs DON'T PASS NULL's, use "".  To control which files
	will be sent, use the paraemter, iDownloadBitMask.

	Note: This function requires the use of QPST. 

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sPartitionFileName = partition path and file name, usually "partition.mbn"
	\param sPBL_FileName = Primary Boot Loader, usually "pbl.mbn"
	\param sQCSBL_FileName = secure boot loader, usually "qcsblhd_cfgdata.mbn"
	\param sQCSBL_HeaderName = secure boot loader header, usually "qcsbl.mbn"
	\param sOEMSBL_FileName = OEM secure boot loader, usually "oemsbl.mbn"
	\param sOEMSBL_HeaderName = OEM secure boot loader header, usually "oemsblhd.mbn"
	\param sModemFileName = AMSS File, usually "amss.mbn"
	\param sModemHeaderName = AMSS Header, usually "amsshd.mbn"
	\param sAppsFileName = Application file
	\param sAppsHeaderName = Application header file
	\param sAppsBlFileName = Application boot loader file
	\param sAppsBlHeaderFileName = Application boot loader header file
	\param sWinMobileImageFileName = Windows Mobile Image file
	\param sDSP1FileName = DSP1 file name
	\param sDSP2FileName = DSP2 file name
	\param bUseEmergDL = 1 to use emergency download, 0 to use normal download
	\param sMBRFileName = SBR file name
	\param char bOverridePrtnTable = TRUE to overwrite the stored partition table in the phone
	\param char bUseTrustedMode = TRUE to use trusted mode and the AMSS has a built-in PBL.
	                              If FALSE, then PBL must be provided.

	\param sSPC = Service Programming Code, usually "000000"
	\param bClearErrorLog = TRUE to clear the QPST error log
	\param sStorageFile = file name of temporary QCN file
	\param bOverrideModelCheck = TRUE to override a model number check
	\param bSkipReset = TRUEto skip the reset operation after the phone is programmed
	\param bUseCustomArmprg =  FALSE to let QPST server determine which ARMPRG to bet used.
	                          If TRUE, then the NPRG or ARMPRG will be searched for in the
							  same folder as the modem file name.
	\param iDloadArmprg = if bUseCustomArmprg = false, then ID of the ARMPRG to use
	                       refer to the enumeration, dloadArmprgType
	\param iDownloadBitMask = bitmask of files to download, based on SWD_miFileTypeBitmask_enum

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_UploadMultiImage5
	(
		HANDLE hResourceContext,
		char* sPartitionFileName,
		char* sPBL_FileName,
		char* sQCSBL_FileName,
		char* sQCSBL_HeaderName,
		char* sOEMSBL_FileName,
		char* sOEMSBL_HeaderName,
		char* sModemFileName,
		char* sModemHeaderName,
		char* sAppsFileName,
		char* sAppsHeaderName,
		char* sAppsBlFileName,
		char* sAppsBlHeaderFileName,
		char* sWinMobileImageFileName,
		char* sDSP1FileName,
		char* sDSP2FileName,
		unsigned char  bUseEmergDL,
		char* sMBRFileName,
		unsigned char bOverridePrtnTable,
		unsigned char bUseTrustedMode,
		char* sSPC,
		unsigned char bClearErrorLog,
		char* sStorageFile,
		unsigned char bOverrideModelCheck,
		unsigned char bSkipReset,
		unsigned char bUseCustomArmprg,
		long iDloadArmprg,
		long iDownloadBitMask
	);

	/******************************************************************************/
	/**
	Upload a multi-image software image (Secure Boot 2.0) from the PC to the phone.
	The function requires QPST 2.7.365 or beyond for runtime.

	For the following string inputs DON'T PASS NULL's, use "".  To control which files
	will be sent, use the paraemter, iDownloadBitMask.

	Note: This function requires the use of QPST. 

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sPartitionFileName = partition path and file name, usually "partition.mbn"
	\param sDeviceBootLoader_FileName = Device Boot Loader Name, usually "dbl.mbn"
	\param sQFailSafeBootLoader_FileName = Fail safe boot loader name, usually "fsbl.mbn"
	\param sOSBootLoader_FileName = OS boot loader name, usually "osbl.mbn"
	\param sModem_FileName = AMSS File, usually "amss.mbn"
	\param sApps_FileName = AMSS boot loader, usually "apps.mbn"
	\param sAppsBootLoader_FileName = AMSS boot loader, usually "appsboot.mbn"
	\param sWinbMobile_FileName = Win Image Name, usually "flash.bin"
	\param sDSP1_FileName = DSP1 file name, usually "dsp1.mbn"
	\param sDSP2_FileName = DSP2 file name, usually "dsp2.mbn"
	\param sMBR_FileName = MBR file name, usually "mbr.bin"
	\param sADSP_FileName = MBR file name, usually "adsp_q5.mbn"
	\param sTrustZone = Trust Zone name, usually "tzos.mbn"
	\param sROFS1 = ROFS1 file, usually "file.rofs1"
	\param sROFS2 = ROFS2 file, usually "file.rofs2"
	\param sROFS3 = ROFS3 file, usually "file.rofs3"


	\param bUseEmergDL = 1 to use emergency download, 0 to use normal download
	\param char bOverridePrtnTable = TRUE to overwrite the stored partition table in the phone
	\param char bUseTrustedMode = TRUE to use trusted mode and the AMSS has a built-in PBL.
	                              If FALSE, then PBL must be provided.

	\param sSPC = Service Programming Code, usually "000000"
	\param bClearErrorLog = TRUE to clear the QPST error log
	\param sStorageFile = file name of temporary QCN file, ""
	\param bOverrideModelCheck = TRUE to override a model number check
	\param bSkipReset = TRUE to skip the reset operation after the phone is programmed.  This is ignored by QPST
	\param bUseCustomArmprg =  FALSE to let QPST server determine which ARMPRG to bet used.
	                          If TRUE, then the NPRG or ARMPRG will be searched for in the
							  same folder as the modem file name.
	\param iDloadArmprg = if bUseCustomArmprg = false, then ID of the ARMPRG to use
	                       refer to the enumeration, dloadArmprgType in QLib_SoftwareDownload

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_UploadSB2MultiImage
	(
		HANDLE hResourceContext,
		char* sPartitionFileName,
		char* sDeviceBootLoader_FileName,
		char* sQFailSafeBOotLoader_FileName,
		char* sOSBootLoader_FileName,
		char* sModem_FileName,
		char* sApps_FileName,
		char* sAppsBootLoader_FileName,
		char* sWinMobile_FileName,
		char* sDSP1FileName,
		char* sDSP2FileName,
		char* sMBR_FileName,
		char* sADSP_FileName,
		char* sTrustZone,
		char* sROFS1,
		char* sROFS2,
		char* sROFS3,
		unsigned char  bUseEmergDL,
		unsigned char bOverridePrtnTable,
		unsigned char bUseTrustedMode,
		char* sSPC,
		unsigned char bClearErrorLog,
		char* sStorageFile,
		unsigned char bOverrideModelCheck,
		unsigned char bSkipReset,
		unsigned char bUseCustomArmprg,
		long iDloadArmprg
	);

	/******************************************************************************/
	/**
	Aborts the most recent software download operation (SW Download, QCN file transfer).

	Note: This function requires the use of QPST. 

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return none

	\warning Any current operations will be terminated.  This can cause problems with the
	         phone state.  If a FLASH programming is interrupted, the phone may become
			 unusable and require JTAG.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_AbortSW_DownloadOperation( HANDLE hResourceContext );

	/******************************************************************************/
	/**

	Note: This function requires the use of QPST. 

	Return the phone status, as reported by QPST Server.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatus = value of the current status, as defined by the SWD_enPhoneMode enumeration
	                  in SoftwareDownload.h

	\return true if successful, false if fail.

	\warning---this function is only valid when the library is in QPST mode

	*******************************************************************************/
	QLIB_API unsigned char QLIB_GetQpstPhoneStatus( HANDLE hResourceContext, unsigned long* piStatus );

	/******************************************************************************/
	/**

		Get the error status and description of the last software download operation.

		Note: This function requires the use of QPST. 

		\param bErrorOccurred    = true if an error occurred during the last operation.  False if no error
								   occurred during the last operation.

		\param sErrorMessage     = Filled filled in with a text description of the most recent error.
								   Empty if no error has occurred.

		\param iMaxStringLength  = Maximum nQumber of characters available in the sErrorMessage buffer

		\return true if successful, false if failure

		\warning  The error information will be cleared after this is called.

	*******************************************************************************/
	QLIB_API void QLIB_GetLastSoftwareDownloadErrorInfo
		( HANDLE hResourceContext, unsigned char* bErrorOccurred, char *sErrorMessage, int iMaxStringLength );

	/******************************************************************************/
	/**
	Upload software image for Secure Boot 1.0 targets from the PC to the phone.
	The function runs in QPHONEMS mode (aka NO QPSTServer.exe is required)

	Secure Boot 1.0 target includes MSM7x01, MSM7x25, MSM7x27

	Software Download is a 3 step process

	Step 0: Change mobile from DIAG to DOWNLOAD mode (mobile will re-enumerate)
	Step 1: Download Flash Programmer (Nxxxx.hex) into mobile and issue GO command to start the programmer (mobile will re-enuermate)
	Step 2: Download MBN files
	
	The function will return once RESET command is issued after download

	This function will not backup/restore NV/EFS items from the mobile.  User
	must call other QMSL APIs if backup/restore is required.

	For the file type that is NOT uploaded, user should pass NULL as argument.

	Note: This method will not work with QPST. It requires QPHONEMS connection.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sARMPRG_FileName = ARMPRG file path
	\param sPartitionFileName = Partition File Path, usually "partition.mbn"
	\param sPriBootLoader_FileName= Primary Boot Loader File Path, usually, "pbl.mbn"
	\param sQCSecBootLoader_FileName= Qualcomm Secondary Boot Loader, usually "qcsbl.mbn"
	\param sQCSecBootLoaderHeader_FileName= Qualcomm Secondary Boot Loader Header, usually qcsblhd_cfgdata.mbn"
	\param sOEMSecBootLoader_FileName= OEM Secondary Boot Loader, usually "oemsbl.mbn"
	\param sOEMSecBootLoaderHeader_FileName= OEM Secondary Boot Loader Header, usually "oemsblhd.mbn"
	\param sModemFile_FileName= AMSS modem file, usually amss.mbn"
	\param sModemFileHeader_FileName= AMSS modem file header, usually "amsshd.mbn"
	\param sAppsFile_FileName=  AMSS application file, usually "apps.mbn"
	\param sAppsFileHeader_FileName= AMSS application file header, "appshd.mbn";
	\param sAppsBootLoaderFile_FileName= AMSS application boot loader file, usually "appsboot.mbn";
	\param sAppsBootLoaderFileHeader_FileName= AMSS application boot loader header file, usually "appsboothd.mbn";
	\param sWinMobile_FileName= Winmobile file, usually "flash.bin"
	\param sDSP1_FileName= DSP1 file, usually "dsp1.mbn"
	\param sMBR_FileName= MBR file, usually "mbr.mbn"
	\param sADSP_FileName= ADSP file, usually "adsp.mbn"
	\param bOverridePrtnTable = TRUE(1)  to overwrite the stored partition table in the phone
	\param bUseTrustedMode = TRUE(1) to use trusted mode and the AMSS has a built-in PBL.
	                              If FALSE, then PBL must be provided.
								  The flag must be set to TRUE.
	\param bSkipGoToDownload      = 0 == false
	                                1 == true (essentially skip Step 0)
									If the phone is already in download mode, user can set bSkipToToDownload to true
									The flag must be set to FALSE

	\param iSleepTimeToDOWNLOADmode = Sleep time (in ms) for QMSL to wait between step 0 and 1 due to mobile re-enumeration
									  This value is target dependent.  The value provided below is for reference.
									  User can optimize the value based on their platform
									
									  MSM7x25 = 5000;
									  MSM7x25 = 5000;

	\param iSleepTimeToGOcommand = Sleep time (in ms) for QMSL to wait between step 1 and 2 due to mobile re-enumeration
								   This value is target dependent.  The value provided below is for reference.  
								   User can optimize the value based on their platform

									MSM7x25 = 5000;
									MSM7x25 = 5000;
	
	\param iErrorCode = See QMSL_DownloadAgent_Error_Enum in QLib_Defines.h
	
	\warning Note, sDSP1, sMBR, sADSP files are not supported yet

	*******************************************************************************/
	QLIB_API unsigned char QLIB_QPHONEMS_UploadSB1MultiImage
	(   HANDLE hResourceContext,
		char* sARMPRG_FileName,
		char* sPartitionFileName,
		char* sPriBootLoader_FileName,
		char* sQCSecBootLoader_FileName,
		char* sQCSecBootLoaderHeader_FileName,
		char* sOEMSecBootLoader_FileName,
		char* sOEMSecBootLoaderHeader_FileName,
		char* sModemFile_FileName,
		char* sModemFileHeader_FileName,
		char* sAppsFile_FileName,
		char* sAppsFileHeader_FileName,
		char* sAppsBootLoaderFile_FileName,
		char* sAppsBootLoaderFileHeader_FileName,
		char* sWinMobile_FileName,
		char* sDSP1_FileName,
		char* sMBR_FileName,
		char* sADSP_FileName,
		unsigned char bOverridePrtnTable,
		unsigned char bUseTrustedMode,
		unsigned char bSkipGoToDownload,
		unsigned long iSleepTimeToDOWNLOADmode,
		unsigned long iSleepTimeToGOcommand,
		unsigned long *iErrorCode
	);

	/******************************************************************************/
	/**
	Upload software image for Secure Boot 2.0 targets from the PC to the phone.
	The function runs in QPHONEMS mode (aka NO QPSTServer.exe is required)

	Secure Boot 2.0 target includes QSC6240/6270, QSC6x95, QSD8x50, MDM9k

	Software Download is a 3 step process

	Step 0: Change mobile from DIAG to DOWNLOAD mode (mobile will re-enumerate)
	Step 1: Download Flash Programmer (Nxxxx.hex) into mobile and issue GO command to start the programmer (mobile will re-enuermate)
	Step 2: Download MBN files
	
	The function will return once RESET command is issued after MBN download

	This function will not backup/restore NV/EFS items from the mobile.  User
	must call other QMSL APIs if backup/restore is required.

	For the file type that is NOT uploaded, user should pass NULL as argument.

	Note: This method will not work with QPST. It requires QPHONEMS connection.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sARMPRG_FileName = ARMPRG file path name. For example, "NPRG6695.hex"(regular ARMPRG) or "ENPRG6695.hex" (emergency downloader)
	\param sPartitionFileName = partition path and file name, usually "partition.mbn"
	\param sDeviceBootLoader_FileName = Device Boot Loader Name, usually "dbl.mbn"
	\param sQFailSafeBootLoader_FileName = Fail safe boot loader name, usually "fsbl.mbn"
	\param sOSBootLoader_FileName = OS boot loader name, usually "osbl.mbn"
	\param sModem_FileName = AMSS File, usually "amss.mbn"
	\param sApps_FileName = AMSS boot loader, usually "apps.mbn"
	\param sAppsBootLoader_FileName = AMSS boot loader, usually "appsboot.mbn"
	\param sWinbMobile_FileName = Win Image Name, usually "flash.bin"
	\param sDSP1_FileName = DSP1 file name, usually "dsp1.mbn"
	\param sDSP2_FileName = DSP2 file name, usually "dsp2.mbn"
	\param sMBR_FileName = MBR file name, usually "mbr.bin"
	\param sADSP_FileName = MBR file name, usually "adsp_q5.mbn"
	\param sTrustZone = Trust Zone name, usually "tzos.mbn"
	\param sROFS1 = ROFS1 file, usually "file.rofs1"
	\param sROFS2 = ROFS2 file, usually "file.rofs2"
	\param sROFS3 = ROFS3 file, usually "file.rofs3"
	\param bOverridePrtnTable = TRUE(1)  to overwrite the stored partition table in the phone
	\param bUseTrustedMode = TRUE(1) to use trusted mode and the AMSS has a built-in PBL.
	                              If FALSE, then PBL must be provided.
								  The flag must be set to TRUE.
	\param bSkipGoToDownload      = 0 == false
	                                1 == true (essentially skip Step 0)
									If the phone is already in download mode, user can set bSkipToToDownload to true
									The flag must be set to FALSE

	\param iSleepTimeToDOWNLOADmode = Sleep time (in ms) for QMSL to wait between step 0 and 1 due to mobile re-enumeration
									  This value is target dependent.  The value provided below is for reference.
									  User can optimize the value based on their platform
									
									  MDM9k = 5000;
									  SCMM (MDM6k, QSC6x95) = 5000;
									  LCU (QSC6240/70) = 5000


	\param iSleepTimeToGOcommand = Sleep time (in ms) for QMSL to wait between step 1 and 2 due to mobile re-enumeration
								   This value is target dependent.  The value provided below is for reference.  
								   User can optimize the value based on their platform

									  MDM9k = 3000;
									  SCMM (MDM6k, QSC6x95) = 3000;
									  LCU (QSC6240/70) = 5000

    \param iErrorCode = See QMSL_DownloadAgent_Error_Enum in QLib_Defines.h

	\warning sMBR_FileName, sADSP_FileName, sTrustZone, sORFS1, sORFS2 and sORFS3 partition files are not yet supported.

	*******************************************************************************/

	QLIB_API unsigned char QLIB_QPHONEMS_UploadSB2MultiImage
	(
		HANDLE hResourceContext,
		char* sARMPRG_FileName,
		char* sPartitionFileName,
		char* sDeviceBootLoader_FileName,
		char* sQFailSafeBOotLoader_FileName,
		char* sOSBootLoader_FileName,
		char* sModem_FileName,
		char* sApps_FileName,
		char* sAppsBootLoader_FileName,
		char* sWinMobile_FileName,
		char* sDSP1FileName,
		char* sDSP2FileName,
		char* sMBR_FileName,
		char* sADSP_FileName,
		char* sTrustZone,
		char* sROFS1,
		char* sROFS2,
		char* sROFS3,
		unsigned char bOverridePrtnTable,
		unsigned char bUseTrustedMode,
		unsigned char bSkipGoToDownload,
		unsigned long iSleepTimeToDOWNLOADmode,
		unsigned long iSleepTimeToGOcommand,
		unsigned long *iErrorCode
	);
	/******************************************************************************/
	/**

	Callback function for QMSL client to collect status during software download

	Note: This method will not work with QPST. It requires Qlib connection.

	*******************************************************************************/
	QLIB_API void QLIB_QPHONEMS_UploadSBMultiImage_ConfigureCallBack( HANDLE hResourceContext, swdlQPHONEMSCB pSWDLCallBack);

/******************************************************************************
						MediaFLO FTM
*******************************************************************************/

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO, 3.10 Subcommand 400 - Get RSSI Cal Point

			This function returns a 16-bit signed RSSI cal point for the requested gain state.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iGainState = the gain state (0 = highest gain, 3 = lowest gain)
	\param iInputPower = the receiver input power, 1 dB resolution
	\param piCalPoint = the RSSI cal point for the requested gain state, 1/256 dB

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MF_GET_RSSI_CAL_POINT(HANDLE hResourceContext, unsigned short iGainState,
										  short iInputPower, short *piCalPoint);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO, 3.9 Subcommand 401 - Get Rx RSSI

			This function returns a 16-bit signed receiver signal strength indicator (RSSI) value.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piRssiValue = RSSI value in 1/100 dB

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MF_GET_RX_RSSI( HANDLE hResourceContext, short *piRssiValue );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO, 3.7 Subcommand 402 - Get AGC State

			This function returns the current gain state and 15-bit signed DVGA accumulator value.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piGainState = current gain state (0 = highest gain state, 3 = lowest gain state)
	\param piDvga = current DVGA accumulator value, 15-bit signed value

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MF_GET_AGC_STATE(HANDLE hResourceContext, unsigned short *piGainState, short *piDvga);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO, 3.12 Subcommand 403 - Write Cal Data

			This function stores the current state of the RF Calibration to NV.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iBand = the MediaFLO band to write to NV

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MF_WRITE_CAL_DATA(HANDLE hResourceContext, unsigned short iBand);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO, 3.2 Subcommand 406 - LNA Select

			This function enables the desired LNA in the RBR device.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iWhichLna = which LNA to enable (1=LNA1, 2=LNA2)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MF_LNA_SELECT( HANDLE hResourceContext, unsigned short iWhichLna );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO, 3.3 Subcommand 407 - RF Switch Config

			This function sets the state of the LNA RF Switch Control pins SW_CTL1 and SW_CTL2.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iState = the state of the LNA RF Switch Control pins
						0 - SW_CTL1 Low, SW_CTL2 Low
						1 - SW_CTL1 Low, SW_CTL2 High
						2 - SW_CTL1 High, SW_CTL2 Low
						3 - SW_CTL1 High, SW_CTL2 High

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MF_RF_SWITCH_CONFIG( HANDLE hResourceContext, unsigned short iState );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO, 3.6 Subcommand 408 - Synth Lock

			This function returns the lock state of the synthesizer.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pbLockState = the lock state of the synthesizer (0=unlocked, 1=locked)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MF_SYNTH_LOCK( HANDLE hResourceContext, unsigned char* pbLockState );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO, 3.8 Subcommand 411 - Set Gain State

			This function sets the gain state of the currently selected LNA.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iGainState = the desired gain state (0=highest gain state, 3=lowest gain state)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MF_SET_GAIN_STATE(HANDLE hResourceContext, unsigned short iGainState);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO, 3.5 Subcommand 413 - Tune PLL

			This function tunes the PLL to the requested FLO Air Interface Specification channel.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iChannel = the desired channel (0 - 8191)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MF_TUNE_PLL( HANDLE hResourceContext, unsigned short iChannel );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO, 3.11 Subcommand 415 - Get IM2

			This function gets the MediaFlo IM2 calibration values.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piSuppression = characteristic IM2 performance improvement vs. uncalibrated in dB
	\param piI_Value = I channel IM2 calibration value
	\param piQ_Value = Q channel IM2 calibration value
	\param piTransConductance_Value = Transconductor IM2 calibration value

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MF_GET_IM2(	HANDLE hResourceContext,
												short* piSuppression,
												unsigned char* piI_Value,
												unsigned char* piQ_Value,
												unsigned char* piTransConductance_Value);

/******************************************************************************
						MediaFLO FTM UBM
*******************************************************************************/

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.l Subcommand 0 - Get RSSI Cal Point

			This function returns a 16-bit signed RSSI cal point for the requested gain state.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iGainState = the gain state (0 = highest gain, 3 = lowest gain)
	\param iInputPower = the receiver input power, 1 dB resolution
	\param iNumberOfSamples = the number of times to sample the cal point
	\param piCalPoint = the RSSI cal point for the requested gain state, 1/256 dB

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_GET_RSSI_CAL_POINT(HANDLE hResourceContext,
															  unsigned char iGainState,
															  unsigned short iInputPower,
															  unsigned short iNumberOfSamples,
															  short* piCalPoint);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.2.2 Subcommand 1 - Get Rx RSSI

			This function returns a 16-bit signed receiver signal strength indicator (RSSI) value.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piIsValid = Returns whether the RSSI value is valid (1) or not (0).
	\param piRssiValue = RSSI value in 1/100 dB

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_GET_RSSI(HANDLE hResourceContext,
													unsigned char *piIsValid,
													short *piRssiValue );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.3 Subcommand 2 - Get AGC State

			This function returns the current gain state and 15-bit signed DVGA accumulator value.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piGainState = current gain state (0 = highest gain state, 3 = lowest gain state)
	\param piDvga = current DVGA accumulator value, 15-bit signed value

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_GET_AGC_STATE(HANDLE hResourceContext,
														 short *piDvga,
														 unsigned char  *piGainState);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.4 Subcommand 3 - Write Cal Data to NV

			This function stores the current state of the RF Calibration to NV.

	\param hResourceContext =	Resource context that was returned from the call to QLIB_ConnectServer()
	\param iitemCode=			either 0, for the channel list, or 1 for the RSSI calibration point
	\param iGainState=			when writing the calibration point, this specifes the coresponding gains state.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_WRITE_CAL_DATA_TO_NV(HANDLE hResourceContext,
																unsigned long iItemCode,
																unsigned long iGainState);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.5 Subcommand 4 - Set RF On.

			This command allows the MBP RF_ON signal to be set to the active or inactive state

	\param hResourceContext =	Resource context that was returned from the call to QLIB_ConnectServer()
	\param bRFOn=			    either 0, to set RF_ON to inactive, or 1 to set RF_ON to active.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_SET_RF_ON(HANDLE hResourceContext, unsigned char bRFOn);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.6 Subcommand 5 - Powerup.

			This command enables the RF power supply.

	\param hResourceContext =	Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_RF_POWER_UP_RF(HANDLE hResourceContext);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.7 Subcommand 6 - Select LNA.

			This command allows the LNA selection to be modified
			independent of the FTM_MF_RF_INITIALIZE command.

	\param hResourceContext =	Resource context that was returned from the call to QLIB_ConnectServer()
	\param iLNA	 =				LNA value to select.
		\code
		MFLO UHF_LNA =0,
		MFLO_US_HIGH_BAND_LNA = 1,
		MFLO_US_LOW_BAND_LNA = 2,
		MFLO_L_BAND_LNA = 3,
		\endcode

	\return true if successful, false if fail.

	\warning Recommended for MBP1600/MBP1610 only
			 Not supported on MBP2600.
			 Not recommended for new MBP2700 applications (see QLIB_FTM_MF_LNA_SELECT_2)

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_LNA_SELECT(HANDLE hResourceContext, unsigned char iLNA);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.7 Subcommand 21 - Select LNA.

			This command allows the LNA selection to be modified
			independent of the FTM_MF_RF_INITIALIZE command.

	\param hResourceContext =	Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRfMode = The RF mode to initialise.
	Defined by ftm_mflo_rf_mode in QLib_Defines.h:
		\code
		FTM_MFLO_US		= 0,
		FTM_MFLO_VHF	= 1,
		FTM_MFLO_UHF	= 2,
		FTM_MFLO_L_BAND = 3
		\endcode
	\param iLNASelect = LNA value to select.
	Defined by ftm_mflo_rf_lna_type in QLib_Defines.h:
		\code
		MFLO_T_UHF1		= 0,	( MBP2600 )
		MFLO_F_LBAND	= 1,	( MBP2700 LBAND )
		MFLO_F_LNA1		= 2,	( MBP2700 LNA1 )
		MFLO_F_LNA2		= 3,	( MBP2700 LNA2 )
		\endcode
	\param iStartFreq = The start frequency (ignored if both start and end frequencies are zero).
	\param iEndFreq = The end frequency (ignored if both start and end frequencies are zero).

	\return true if successful, false if fail.

	\warning MBP2700 only

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_LNA_SELECT_2(HANDLE hResourceContext,
														unsigned char iRfMode,
														unsigned char iLNASelect,
														unsigned long iStartFreq,
														unsigned long iEndFreq);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.8 Subcommand 7 - Set Antenna tune switch.

			This command allows the antenna tune selection to be modified independent
			of the FTM_MF_RF_INITIALIZE command

	\param hResourceContext =	Resource context that was returned from the call to QLIB_ConnectServer()
	\param iValue	 =			6 LSB are written to the Antenna tune switch.

	\return true if successful, false if fail.

	\warning Recommended for MBP1600/MBP1610 only
			 Not supported on MBP2600.
			 Not recommended for new MBP2700 applications (see QLIB_FTM_UBM_MF_RF_SET_ANT_TUNE_2)

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_RF_SET_ANT_TUNE(HANDLE hResourceContext, unsigned char iValue);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.8 Subcommand 7 - Set Antenna tune switch.

			This command allows the antenna tune selection to be modified independent
			of the FTM_MF_RF_INITIALIZE command

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRfMode = The RF mode to initialise.
	Defined by ftm_mflo_rf_mode in QLib_Defines.h:
		\code
		FTM_MFLO_US		= 0,
		FTM_MFLO_VHF	= 1,
		FTM_MFLO_UHF	= 2,
		FTM_MFLO_L_BAND = 3
		\endcode
	\param iAntTuneMask = The mask to apply to the Tune Settings.
	\param iAntTuneSettings = The Antenna Tune Settings (only bits with a corresponding 1 in the Tune Mask will actually be set)
	\param iStartFreq = The start frequency (ignored if both start and end frequencies are zero).
	\param iEndFreq = The end frequency (ignored if both start and end frequencies are zero).

	\return true if successful, false if fail.

	\warning MBP2700 Only

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_RF_SET_ANT_TUNE_2(HANDLE hResourceContext,
															 unsigned char iRfMode,
															 unsigned char iAntTuneMask,
															 unsigned char iAntTuneSettings,
															 unsigned long iStartFreq,
															 unsigned long iEndFreq);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.9 Subcommand 8 - Synth Lock

			This function returns the lock state of the synthesizer.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pbLockState = the lock state of the synthesizer (0=unlocked, 1=locked)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_SYNTH_LOCK( HANDLE hResourceContext, unsigned short* pbLockState );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.10 Subcommand 9 - Enable/Disable LNA

			This command allows the LNA to be enabled/disabled independent of the FTM_MF_RF_INITIALIZE command

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param bLNAState = either 0, to disable LNA update, 1 to enable LNA update.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_SET_LNA ( HANDLE hResourceContext, unsigned char bLNAState );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, Subcommand 10 - Tune RF In Hz

		This function tunes the PLL to the requested frequency.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param bfreqHz = Required frequency in Hz.

	\return true if successful, false if fail.

	\warning Supported in MBP2600/MBP2700 only.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_TUNE_RF_IN_HZ ( HANDLE hResourceContext, unsigned long iFreq );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.11 Subcommand 11 - Set Gain State

			This function sets the gain state of the currently selected LNA.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iGainState = the desired gain state (0=highest gain state, 3=lowest gain state)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_SET_GAIN_STATE(HANDLE hResourceContext, unsigned char iGainState);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.12 Subcommand 12 - Pulse MBP TCXO_ON signal.

			 This command allows the MBP TCXO_ON signal to be pulsed.  The pulse width is 100 microsecnds.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_TOGGLE_TCXO_ON( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.13 Subcommand 13 - Tune PLL

			This function tunes the PLL to the requested FLO Air Interface Specification channel.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iChannel = the desired channel (0 - 8191)

	\return true if successful, false if fail.

	\warning Supported in MBP1600/MBP1610 only.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_TUNE_PLL( HANDLE hResourceContext, unsigned short iChannel );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.14 Subcommand 14 - Load RSSI Cal Point

			Loads a RSSI Calibration point in to phone memory

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iChanFreq = for MBP1600/MBP1610: the desired channel (0 - 8191)
					   for MBP2600/MBP2700: the desired frequency in MHz
	\param iGainState = the phone gain state
	\param uCalPoint = the calibration point (dB/256)
	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_LOAD_RSSI_CAL_POINT(HANDLE hResourceContext,
															   unsigned short iChanFreq,
															   unsigned char iGainState,
															   short iCalPoint);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.15 Subcommand 16 - Set AGC Default

			Restores the AGC to the default state.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_SET_AGC_DEFAULT(HANDLE hResourceContext);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.16 Subcommand 17 -RF Initialise

			Initialises the RF Mode, Bandwidth and Frequency

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRfMode = The RF mode to initialise.
	Defined by ftm_mflo_rf_mode in QLib_Defines.h:
		\code
		FTM_MFLO_US		= 0,
		FTM_MFLO_VHF	= 1,
		FTM_MFLO_UHF	= 2,
		FTM_MFLO_L_BAND = 3
		\endcode
	\param iFreqKhz = The RF frequency to initialise in KHz
	\param iBandwidth = The RF bandwidth to use.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_RF_INITIALIZE(HANDLE hResourceContext,
														unsigned char iRfMode,
														unsigned long iFreqKhz,
														unsigned char iBandwidth);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.17 Subcommand 18 -Load AGC Cal Channel List

			Loads the AGC Calibration channel list to the phone memory.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iChannelsFreqs = MBP1600/MBP1610: List of up to 32 channel numbers to load to the phone
							MBP2600/MBP2700: List of up to 32 frequencies in MHz to load to the phone
	\param iNumberOfChannelsFreqs = The number of channels/frequencies to load.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_LOAD_AGC_CAL_CHAN_LIST( HANDLE hResourceContext,
																   unsigned short *iChannelsFreqs,
																   unsigned short iNumberOfChannelsFreqs);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO UBM, 3.3.18 Subcommand 19 -Powerdown.

			This command turns off the RF power supply.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_POWER_DOWN_RF(HANDLE hResourceContext);

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 2.1.3.16 Subcommand 20 - Set Demod Config Options.

		This command sets the demodulation configuration.
		For Pilot Pattern (0, 3, 6) the DMTT mode must obviously be set to TPC based.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iFftSize = FFT Size
		Defined by ftm_mflo_fft_size:
		\code
		FTM_MFLO_2K_FFT = 0,
		FTM_MFLO_4K_FFT = 1,
		FTM_MFLO_8K_FFT = 2
		\endcode
	\param iCpLength = CP Length
		Defined by ftm_mflo_cp_length:
		\code
		FTM_MFLO_1_16_CP_LENGTH = 0,
		FTM_MFLO_1_8_CP_LENGTH = 1,
		FTM_MFLO_3_16_CP_LENGTH = 2,
		FTM_MFLO_1_4_CP_LENGTH = 3
		\endcode
	\param iPpc = 0 - No PPC Symbols, 1 - PPC Symbols
	\param iPilotPattern = 0 - (2,6), 1 - (0,3,6)
	\param iAdaptiveThresh = Adaptive Thresholding (0 - Enabled, 1 - Disabled)
	\param iIcMode = IC Mode
		Defined by ftm_mflo_ic_mode:
		\code
		FTM_MFLO_IC_DISABLED = 0,
		FTM_MFLO_IC_BYPASSED = 1,
		FTM_MFLO_IC_ENABLED = 2,
		FTM_MFLO_IC_DYNAMIC = 3
		\endcode
	\param iDmttMode = DMTT Mode
		Defined by ftm_mflo_dmtt_mode
		\code
		FTM_MFLO_DMTT_DISABLED = 0,
		FTM_MFLO_DMTT_LEGACY = 1,
		FTM_MFLO_DMTT_W_TDM2_RDSP_NOT_USED = 2,
		FTM_MFLO_DMTT_W_TDM2_RDSP_USED = 3,
		FTM_MFLO_DMTT_TPC_BASED = 4
		\endcode

	\return true if successful, false if fail.

	\warning Supported in MBP2600/MBP2700 only.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_UBM_MF_SET_DEMOD_CONFIG( HANDLE hResourceContext,
															 unsigned char eFftSize,
															 unsigned char eCpLength,
															 unsigned char iPpc,
															 unsigned char iPilotPattern,
															 unsigned char iAdaptiveThresh,
															 unsigned char eIcMode,
															 unsigned char eDmttMode );

/******************************************************************************
						MediaFLO NS FTM
*******************************************************************************/

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 3.3.1 Subcommand 0 - Enable FLO Demod

			This function enables FLO demodulation during FTM mode.
			The MediaFLO hardware must have been previously	initialized by the
			FTM MFLO Set Mode RF.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_SET_NS_MODE( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 3.3.2 Subcommand 1 - Acquire FLO System

			This function forces FLO to perform a FLO system acquisition. An attempt
			will be made to acquire both the WIDE and LOCAL systems.   Acquisition may
			require several seconds. The request message contains an additional field
			that instructs FTM to wait (in msec) before returning the system status in
			the response message.  If the wait time is 0 the response will be sent
			immediately.  In this case the FLO system may not be acquired when the
			response is sent.  The FTM_MF_GET_OIS_STATE command can be used to determine
			if a system has been acquired.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iacqWaitTime = time to wait for acquisition.
	\param bLocalAcquired = 1: Local System is valid (acquired)
							0: Local System is invalid (not acquired)
	\param bWideAcquired = 1: Wide System is valid (acquired)
						   0: Wide System is invalid (not acquired)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_ACQUIRE_FLO_SYSTEM( HANDLE hResourceContext,
																unsigned short iAcqWaitTime,
																unsigned char *pbLocalAcquired,
																unsigned char *pbWideAcquired );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.3 Subcommand 2 - Activate Flow

			This function activates the Flow specified by the caller.
			Activation may require several seconds. The request message contains
			an additional field that instructs FTM to wait (in msec) before returning
			the activation response message.  If the wait time is 0 the response will
			be sent immediately and the ACTIVATION_STATUS in the response will be set
			to ACTIVATING_FLOW.  In addition the stream information returned in the
			response will be invalid (set to 0).  The FTM_MFLO_NS_GET_STREAM_INFO command
			can be used to determine if the Flow was successfully activated. If a wait
			time is specified the ACTIVATION_STATUS in the response will be set to either
			ACTIVATION_FAILED or ACTIVATION_SUCCESS depending upon the stream state at the
			wait time expiration.
			Non-signaling mode in FTM supports a maximum of 20 simultaneously active Flows.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iAcqWaitTime = time to wait for acquisition.
	\param iFlowId = specfies the flow to activate.
	\param eBinding = specifies the binding type. This is both an input and output param
		Defined by mftypes_binding_type:
		\code
		MFLO_OVERHEAD   = 0x00,
		RT_VIDEO_CODEC  = 0x01,
		RT_AUDIO_CODEC  = 0x02,
		NRT_MEDIA       = 0x03,
		DATACAST        = 0x04,
		TAP             = 0x05,
		FIXED_TAP       = 0x06,
		\endcode
	\param eStatus = specifies activate flow status.
	Defined by mftypes_activate_status_type:
		\code
		FAILED				= 0x00,
		ACTIVATING			= 0x01,
		SUCCESS				= 0x02
		\endcode
	\param iMlcID = specifies the MLC ID.
	\param iStreamID = specifies the Stream ID.
	\param bStreamUsesBothLayers = true(1) if enhanced layer fata is present.
	\param bByteInterleaveEnabled = true(1) if byte interleave is enabled.
	\param eSystem = specifies the system.
		Defined by mftypes_system_type:
		\code
		WIDE			= 0x00,		//! Wide System
		LOCAL			= 0x01,		//! Local System
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_ACTIVATE_FLOW( HANDLE hResourceContext,
														   unsigned short iAcqWaitTime,
														   unsigned long iFlowId,
														   unsigned char *piBindingType,
														   unsigned char *piStatus,
														   unsigned char *piMlcId,
														   unsigned char *piSteamId,
														   unsigned char *pbStreamUsesBothLayers,
														   unsigned char *pbByteInterleaveEnabled,
														   unsigned char *piSystem );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.4 Subcommand 3 - Deactivate Flow

			This function deactivates the Flow specified by the caller. If the Flow
			Id in the request message is not active FLOW_NOT_ACTIVATED is returned
			in the response, otherwise FLOW_DEACTIVATING is returned.
			The FTM_MFLO_NS_GET_STREAM_INFO command can be used to determine if the Flow
			was successfully deactivated.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iFlowId = specifies the Flow ID.
	\param eStatus = specifies deactivate flow status.
	Defined by mftypes_flow_status_type:
		\code
		FLOW_NOT_ACTIVATED  	= 0x00,
		FLOW_DEACTIVATING		= 0x02
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_DEACTIVATE_FLOW( HANDLE hResourceContext,
															 unsigned long iFlowId,
															 unsigned char *piStatus );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 1.3.5 Subcommand 4 - Get Stream Info

			This function command retrieves the stream information for the specified
			Flow ID.  If the Flow Id specified in the request message is not active
			FLOW_NOT_ACTIVATED is returned in the response message, otherwise
			FLOW_ACTIVATED is returned.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iFlowId = specifies the Flow ID.
	\param eStatus = specifies deactivate flow status.
	Defined by mftypes_flow_status_type:
		\code
		FLOW_NOT_ACTIVATED		= 0x00,
		FLOW_ACTIVATED			= 0x01
		\endcode
	\param iMlcID = specifies the MLC ID.
	\param iStreamID = specifies the Stream ID.
	\param bStreamUsesBothLayers = true(1) if enhanced layer fata is present.
	\param bByteInterleaveEnabled = true(1) if byte interleave is enabled.
	\param peBindingType = specifies the binding type.
		Defined by mftypes_binding_type:
		\code
		MFLO_OVERHEAD   = 0x00,
		RT_VIDEO_CODEC  = 0x01,
		RT_AUDIO_CODEC  = 0x02,
		NRT_MEDIA       = 0x03,
		DATACAST        = 0x04,
		TAP             = 0x05,
		FIXED_TAP       = 0x06,
		\endcode
	\param eSystem = specifies the system.
		Defined by mftypes_system_type:
		\code
		WIDE			= 0x00,		//! Wide System
		LOCAL			= 0x01,		//! Local System
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_STREAM_INFO( HANDLE hResourceContext,
															 unsigned long iFlowId,
															 unsigned char *piStatus,
															 unsigned char *piMlcID,
															 unsigned char *piStreamID,
															 unsigned char *pbStreamUsesBothLayers,
															 unsigned char *pbByteInterleaveEnabled,
															 unsigned char *piBindingType,
															 unsigned char *piSystem );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.6 Subcommand 5 - Get MLC Dynamic Parameters.

		This command retrieves the dynamic parameters for the specified MLC ID. The information
		returned can be used to calculate PER statistics. If the MLC is not active 0 is returned
		in the first byte of the response message, otherwise 1 is returned.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iMlcID = specifies the MLC ID. This is both an input and output param.
	\param eSystem = specifies the system
		Defined by mftypes_system_type:
		\code
		WIDE			= 0x00,		//! Wide System
		LOCAL			= 0x01,		//! Local System
		\endcode
	\param piFFTAddress = MLC Base FFT Address
	\param peTransmitMode = Transmit Mode
		Defined by mftypes_trans_mode_type:
		\code
		REG_QPSK_1_3         = 0,
		MREG_QPSK_1_2        = 1,
		REG_16_QAM_1_3       = 2,
		REG_16_QAM_1_2       = 3,
		REG_16_QAM_2_3       = 4,
		REG_16_QPSK_1_5      = 5,
		LAY_QPSK_1_3_ER_4    = 6,
		LAY_QPSK_1_2_ER_4    = 7,
		LAY_QPSK_2_3_ER_4    = 8,
		LAY_QPSK_1_3_ER_6_25 = 9,
		LAY_QPSK_1_2_ER_6_25 = 10,
		LAY_QPSK_2_3_ER_6_25 = 11
		\endcode
	\param peRSOuterCode = RS Outer Code
		Defined by mftypes_reed_solomon_code_type:
		\code
		RS_16_16_0		= 0x0,
		RS_16_14_2		= 0x1,
		RS_16_12_4		= 0x2,
		RS_16_8_8		= 0x3
		\endcode
	\param piCodeBlocks = Code Blocks in current Superframe
	\param pbStream1Bound = true(1) if Stream 1 is bound
	\param pbStream2Bound = true(1) if Stream 2 is bound
	\param iStream0Length = Stream 0 length
	\param iStream1Length = Stream 1 length
	\param iStream2Length = Stream 2 length
	\param pBasePlpStats = structure of type mftypes_plp_stats_type to hold the Base PLP statistics
									as defined in QLIB_Defines.h
	\param pEnhPlpStats = structure of type mftypes_plp_stats_type to hold the Enhanced PLP statistics
									as defined in QLIB_Defines.h
	\param pBaseCbStats = structure of type mftypes_cb_stats_type to hold the Base CB statistics
									as defined in QLIB_Defines.h
	\param pEnhCbStats = structure of type mftypes_cb_stats_type to hold the Enhanced CB statistics
									as defined in QLIB_Defines.h

	\return true if successful, false if fail.

	\warning Prior to calling this function, sufficient space should be allocated in
			 pMlcPlpStats to store structure of type mftypes_mlc_plp_stats_type

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_MLC_DYN_PARAMS( HANDLE hResourceContext,
																unsigned char iMlcID,
																unsigned char iSystem,
																unsigned char *piStatus,
																unsigned long *piFFTAddress,
																unsigned char *piTransmitMode,
																unsigned char *piRSOuterCode,
																unsigned char *piCodeBlocks,
																unsigned char *pbStream1Bound,
																unsigned char *pbStream2Bound,
																unsigned short *piStream0Length,
																unsigned short *piStream1Length,
																unsigned short *piStream2Length,
																void *pBasePlpStats,
																void *pEnhPlpStats,
																void *pBaseCbStats,
																void *pEnhCbStats );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.19 Subcommand 6 - Get OIS demodulation statistics.

		This command retrieves OIS demodulation statistics for the specified system.
		Both cumulative and statistics for both the most recent superframe are reported in the response.
		In order for valid data to be returned this command requires:
			The FTAP OIS Reception test is enabled for the specified system. See FTM_MFLO_NS_ENABLE_FTAP_OIS_RECEPTION_MODE.
			The MediaFLO Log packet 0x120E (MFLO FTAP WOIS PARAMS) or 0x1210 (MFLO FTAP LOIS PARAMS)

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iSystem = specifies the system
		Defined by mftypes_system_type:
		\code
		WIDE			= 0x00,		//! Wide System
		LOCAL			= 0x01,		//! Local System
		\endcode
	\param piLastNumGoodPlps = pointer to store good PLPs in last Superframe
	\param piLastNumErasuresPlps = pointer to store bad PLPs in last Superframe
	\param piTotalNumGoodPlps = pointer to store cumulative good PLPs
	\param piTotalNumErasures = pointer to store cumlative bad PLPs

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_OIS_STATS( HANDLE hResourceContext,
														   unsigned char iSystem,
														   unsigned long* piLastNumGoodPlps,
														   unsigned long* piLastNumErasuresPlps,
														   unsigned long* piTotalNumGoodPlps,
														   unsigned long* piTotalNumErasures);

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.7 Subcommand 7 - Reset MLC PLP Stats.

		This command clears (resets to 0) the accumulated PLP/CB statistics for the specified MLC ID.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iMlcID = specifies the MLC ID
	\param eSystem = specifies the system
		Defined by mftypes_system_type:
		\code
		WIDE			= 0x00,		//! Wide System
		LOCAL			= 0x01,		//! Local System
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_RESET_MLC_PLP_STATS( HANDLE hResourceContext,
																 unsigned char iMlcID,
																 unsigned char iSystem );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.8 Subcommand 8 - Reset ALL PLP Stats.

		This command clears (resets to 0) the accumulated PLP/CB statistics for all of the active MLCs.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_RESET_ALL_PLP_STATS( HANDLE hResourceContext );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.9 Subcommand 9 - Get the number of Active Flows.

		This command returns the number of currently active Flows. FTM Non-signaling mode
		supports a maximum of 20 simultaneously active Flows.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()

	\param piFlowCount = the number of active flows

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_ACTIVE_FLOW_COUNT( HANDLE hResourceContext,
																   unsigned char *piFlowCount );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.9 Subcommand 9 - Get all active flow Ids.

		This command returns a list of all of the currently active flows.
		The total number of active flows is also returned. The list of active flow IDs
		returned is formatted as a 20 entry by uint32 (4 byte) array (80 total bytes)
		Each array entry corresponds to an active Flow ID. If there are less than 20 active
		Flows (FTM Non-signaling mode supports a maximum of 20 simultaneously active flows)
		the array will be zero padded. Note that 0 is a valid Flow ID.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param piFlowCount = This is both and input and output param.  As an input param
							  it indicates the number of elements in pActiveFlowInfoArray.
							  As an output param it indicates the actual number of active
							  flows in the system.
	\param pArrayFlowIds = array of all active flow ids. The list of active Flow IDs returned is
						formatted as a 20 entry by uint32 (4 byte) array (64 total bytes). Each
						array entry corresponds to an active Flow ID. If there are less than 16
						active Flows (20 is maximum concurrent activated Flows in FTM non-signaling
						mode) the array will be zero padded. Note that 0 is a valid Flow ID.

	\return true if successful, false if fail.

	\warning Prior to calling this function, sufficient space should be allocated in
			 pArrayFlowIds to store 20x4Byte array (80 total bytes).

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_ALL_ACTIVE_FLOW_IDS( HANDLE hResourceContext,
																	 unsigned char *piFlowCount,
																	 unsigned long *pArrayFlowIds );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 3.3.10 Subcommand 10 - Get control channel records.

		This command returns a list of control channel records for the specified system.
		A maximum of eight records are returned per response message. The record retrieval starts
		at the record number (greater than 0) specified in the request message. The total number
		of records for the specified system is returned.  The next record number in the record
		database is also returned. If the system contains more than eight records subsequent
		requests must be performed to retrieve all of the records. The total_records and next_record
		fields allow all of the records for a system to be retrieved via a series of
		FTM_MFLO_NS _GET_CONTROL_CHANNEL_RECORDS messages. For example, if the starting_record field
		in the request was set to 5 and the total_records field contains 15 in the response the
		next_record field in the response field will contain 13 (a maximum 8 records can be retrieved
		in one request). Since eight records are retrieved in each response the number of requests
		required to retrieve all of the records for a system is:
			( TOTAL_RECORD )   mod 8
		The list of Control Channel records returned is formatted as an 8 entry (8 records) array of
		8 byte records (64 total bytes).  Each array entry corresponds to a Control Channel record.
		If there are less than 8 records the array will be zero padded.
		The Flow ID for a particular service is computed as follows using the Control Channel record:
			Flow ID = ( Service ID * 16 ) + Flow Descriptor

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param eSystem = the system
		Defined by mftypes_system_type:
		\code
		WIDE			= 0x00,		//! Wide System
		LOCAL			= 0x01,		//! Local System
		\endcode
	\param iStartRecord = the starting record for the next retrieval.
	\param eStatus = Record retrieval status
		0  = starting record count is invalid or no records are available for the specified system
		1 = records were retrieved
		Defined by mftypes_record_retrieval_status_type:
		\code
		NO_RECORDS_AVAILABLE	= 0x00,
		RECORDS_RETRIEVED	= 0x01
		\endcode
	\param iTotalRecords = The total number of records that are available for the specified system.
						The iTotalRecords and iNextRecord allow all of the records for a system to
						be retrieved via a series of calls to QLIB_MFLO_NS_GET_CONTROL_CHANNEL_RECORDS.
						Since eight records are retrieved in each response the number of requests required
						to retrieve all of the records for a system is: ( TOTAL_RECORD ) mod 8
	\param iNextRecord = the record number for the next available record for the system.
						For example, if the iStartRecord param i was set to 5 and the iTotalRecord
						param contains 15, then the iNextRecord will be 13 (maximum 8 records can
						be retrieved in one request).
	\param pControlChannelRecordArray = Array[8] of mftypes_mf_control_channel_record structures
									(mftypes_mf_control_channel_record is defined in QLib_Defines.h)

	\return true if successful, false if fail.

	\warning Prior to calling this function, sufficient space should be allocated in
			 pControlChannelRecordArray to store eight structures of type mftypes_mf_control_channel_record

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_CONTROL_CHANNEL_RECORDS( HANDLE hResourceContext,
																		 unsigned char eSystem,
																		 unsigned short iStartRecord,
																		 unsigned char *piStatus,
																		 unsigned short *piTotalRecords,
																		 unsigned short *piNextRecord,
																		 void *pControlChannelRecordArray );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 3.3.11 Subcommand 11 - Get AIS channel.

	This command returns the current AIS channel.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param piChannel = Currently programmed AIS Channel.
	AIS channel to Khz conversion: Freq (Khz) = 470,000 + AIS_CHAN*50

	\return true if successful, false if fail.

	\warning Not supported on MBP2600/MBP2700

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_AIS_CHANNEL( HANDLE hResourceContext,
															 unsigned short *piChannel );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 3.3.12 Subcommand 12 - Deactivate all flows.

	This command causes all flows to be deactivated.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_DEACTIVATE_ALL_FLOWS( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 3.3.13 Subcommand 13 - Tune Freq and BW.

	This command tunes the RF to the specified frequency and bandwidth.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iFreqKhz = Frequency in kHz for MBP1600/MBP1610 or Hz for MBP2600/MBP2700.
	\param iBandwidthMHz = Bandwidth in MHz.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_TUNE_FREQ_AND_BW( HANDLE hResourceContext,
															  unsigned long iFreq,
															  unsigned char iBandwidthMHz );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 1.3.14 Subcommand 431 - Get RSSI.

	This command retrieves the RSSI. This value is not valid when the FLO is not actively decoding.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param bRssiValid = specifies validity of the RSSI measurement
	\param iRssi = Signed RSSI value in 1/100th dB resolution.

	\return true if successful, false if fail.

	\warning MBP1600/MBP1610 Only

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_RSSI( HANDLE hResourceContext,
													  unsigned char *pbRssiValid,
													  short *piRssi );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 1.3.15 Subcommand 15 - Set FLO Sleep.

	This command Enables/disables FLO sleep.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param eSleepSetting = indicates sleep setting.
		Defined by mftypes_sleep_settings_type:
		\code
		SLEEP_AND_SNOOZE_DISABLED		= 0x00,
		SLEEP_ENABLED_SNOOZE_DISABLED	= 0x01,
		SLEEP_DISABLED_SNOOZE_ENABLED	= 0x02,
		SLEEP_ENABLED_SNOOZE_ENABLED	= 0x03
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_SET_FLO_SLEEP( HANDLE hResourceContext,
														   unsigned char iSleepSetting );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 1.3.16 Subcommand 433 - Get OIS State.

	This command returns the state of the WIde and Local OIS.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param piWideOisStatus = Wide OIS Status.
		Defined by mftypes_state_type:
		\code
		INVALID_STATE		= 0x00,
		ACQUIRING_STATE		= 0x01,
		IDLE_STATE			= 0x02,
		ACTIVE_STATE		= 0x03,
		UNAVAILABLE_STATE	= 0x04
		\endcode
	\param piLocalOisStatus = Local OIS Status.
		Defined by mftypes_state_type:
		\code
		INVALID_STATE		= 0x00,
		ACQUIRING_STATE		= 0x01,
		IDLE_STATE			= 0x02,
		ACTIVE_STATE		= 0x03,
		UNAVAILABLE_STATE	= 0x04
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_OIS_STATE( HANDLE hResourceContext,
														   unsigned char *piWideOisStatus,
														   unsigned char *piLocalOisStatus );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 3.3.17 Subcommand 17 - Intialize RF.

	This command intializes the MediaFLO driver for FTM Mode. This command must be sent prior to
	sending the FTM_MFLO_NS_SET_MODE command.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param eRfMode = MediaFLO RF Mode
		Defined by ftm_mflo_rf_mode:
		\code
		FTM_MFLO_US		= 0,
		FTM_MFLO_VHF	= 1,
		FTM_MFLO_UHF	= 2,
		FTM_MFLO_L_BAND = 3
		\endcode
	\param iFreqKhz = Channel frequency in kHz
	\param eBandwidth = Channel bandwidth
		Defined by ftm_mflo_bandwidth:
		\code
		FTM_MFLO_5_MHZ_BW	= 5,
		FTM_MFLO_6_MHZ_BW	= 6,
		FTM_MFLO_7_MHZ_BW	= 7,
		FTM_MFLO_8_MHZ_BW	= 8
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_INITIALIZE_RF( HANDLE hResourceContext,
														   unsigned char eRfMode,
														   unsigned long iFreqKhz,
														   unsigned char eBandwidth );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 3.3.18 Subcommand 18 - Set Config Options.

		This command sets the demodulation configuration. This command only applies to the MBPxxxxx.
		For Pilot Pattern (0, 3, 6) the DMTT mode must be set to TPC based.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param eFftSize = FFT Size
		Defined by ftm_mflo_fft_size:
		\code
		FTM_MFLO_2K_FFT = 0,
		FTM_MFLO_4K_FFT = 1,
		FTM_MFLO_8K_FFT = 2
		\endcode
	\param eCpLength = CP Length
		Defined by ftm_mflo_cp_length:
		\code
		FTM_MFLO_1_16_CP_LENGTH = 0,
		FTM_MFLO_1_8_CP_LENGTH = 1,
		FTM_MFLO_3_16_CP_LENGTH = 2,
		FTM_MFLO_1_4_CP_LENGTH = 3
		\endcode
	\param iPpc = 0 - No PPC Symbols, 1 - PPC Symbols
	\param iPilotPattern = 0 - (2,6), 1 - (0,3,6)
	\param iAdaptiveThresh = Adaptive Thresholding (0 - Enabled, 1 - Disabled)
	\param eIcMode = IC Mode
		Defined by ftm_mflo_ic_mode:
		\code
		FTM_MFLO_IC_DISABLED = 0,
		FTM_MFLO_IC_BYPASSED = 1,
		FTM_MFLO_IC_ENABLED = 2,
		FTM_MFLO_IC_DYNAMIC = 3
		\endcode
	\param eDmttMode = DMTT Mode
		Defined by ftm_mflo_dmtt_mode
		\code
		FTM_MFLO_DMTT_DISABLED = 0,
		FTM_MFLO_DMTT_LEGACY = 1,
		FTM_MFLO_DMTT_W_TDM2_RDSP_NOT_USED = 2,
		FTM_MFLO_DMTT_W_TDM2_RDSP_USED = 3,
		FTM_MFLO_DMTT_TPC_BASED = 4
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_SET_CONFIG_OPTIONS( HANDLE hResourceContext,
																unsigned char eFftSize,
																unsigned char eCpLength,
																unsigned char iPpc,
																unsigned char iPilotPattern,
																unsigned char iAdaptiveThresh,
																unsigned char eIcMode,
																unsigned char eDmttMode );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 3.3.20 Subcommand 19 - Reset OIS Stats.

		This command resets the OIS statistics for the specified system.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param eSystem = System
		Defined by mftypes_system_type in QLib_Defines.h:
		\code
		WIDE = 0x00,	//! Wide System
		LOCAL = 0x01,	//! Local System
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_RESET_OIS_STATS( HANDLE hResourceContext,
															 unsigned char eSystem );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 3.3.21 Subcommand 20 - Get MLC Dynamic Parameters.

		This command requests MLC Dynamic Parameters for the specified MLC.
		This command requires enabling the Log Code (0x1214) MFLO MLC LOCATION DYNAMIC PARAMS.
		If this log code is not enabled, the response to this command is undefined.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iMlcId = The MLC ID
	\param eSystem = System
		Defined by mftypes_system_type in QLib_Defines.h:
		\code
		WIDE = 0x00,	//! Wide System
		LOCAL = 0x01,	//! Local System
		\endcode
	\param piMlcId = Pointer to store the MLC ID
	\param piMlcFftMode = Pointer to store the MLC FFT mode
	\param piSfNumber = Pointer to store the last Superframe number
	\param piMlcStartSymbol = Pointer to store the MLC Start Symbol
	\param piMlcSlotOffset = Pointer to store the MLC Slot Offset
	\param piMlcSlotMin = Pointer to store the MLC Slot Minimum
	\param piMlcSlotTotal = Pointer to store the MLC Total Slots
	\param piMlcSlotMax = Pointer to store the MLC Slot Maximum
	\param piNumCbs = Pointer to store the number of Code Blocks in the last Superframe
	\param peTransMode = Pointer to store the MLC Transmit Mode
		Defined by mftypes_trans_mode_type in QLib_Defines.h
		\code
		REG_QPSK_1_3         = 0,
		MREG_QPSK_1_2        = 1,
		REG_16_QAM_1_3       = 2,
		REG_16_QAM_1_2       = 3,
		REG_16_QAM_2_3       = 4,
		REG_16_QPSK_1_5      = 5,
		LAY_QPSK_1_3_ER_4    = 6,
		LAY_QPSK_1_2_ER_4    = 7,
		LAY_QPSK_2_3_ER_4    = 8,
		LAY_QPSK_1_3_ER_6_25 = 9,
		LAY_QPSK_1_2_ER_6_25 = 10,
		LAY_QPSK_2_3_ER_6_25 = 11
		\endcode
	\param peOuterCode = Pointer to store the Outer Code used for the MLC
		Defined by ftm_mflo_mlc_outer_code in QLib_Defines.h
		\code
			FTM_MFLO_NS_OUTER_CODE_NONE = 0,
			FTM_MFLO_NS_OUTER_CODE_RS_7_8 = 1,
			FTM_MFLO_NS_OUTER_CODE_RS_3_4 = 2,
			FTM_MFLO_NS_OUTER_CODE_RS_1_2 = 3,
			FTM_MFLO_NS_OUTER_CODE_REP_4 = 4
		\endcode
	\param piStream1Bound = Pointer to store the "is Stream 1 Bound" flag
		If it is not being decoded, this field is set to FALSE; otherwise, this will be set to TRUE.
	\param piStream2Bound = Pointer to store the "is Stream 2 Bound" flag
		If it is not being decoded, this field is set to FALSE; otherwise, this will be set to TRUE.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_MLC_DYN_PARAMS_LOG( HANDLE hResourceContext,
																	unsigned char iMlcId,
																	unsigned char eSystem,
																	unsigned char* piMlcId,
																	unsigned char* piMlcFftMode,
																	unsigned long* piSfNumber,
																	unsigned short* piMlcStartSymbol,
																	unsigned char* piMlcSlotOffset,
																	unsigned char* piMlcSlotMin,
																	unsigned long* piMlcSlotTotal,
																	unsigned char* piMlcSlotMax,
																	unsigned char* piNumCbs,
																	unsigned char* peTransMode,
																	unsigned char* peOuterCode,
																	unsigned char* piStream1Bound,
																	unsigned char* piStream2Bound );

	/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 3.3.22 Subcommand 21 - Get Flow PLP Dynamic Parameters.

		This command requests the PLP Statistics based on a Flow ID.
		The response contains both the total (cumulative) PLP statistics and the PLP statistics
		from the most recent superframe.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iFlowId = The Flow ID
	\param piTotalNumGoodPlps = Pointer to store the cumulative number of good PLPs
	\param piTotalNumErasuresPlps = Pointer to store the cumulative number of bad PLPs
	\param piPerSfGoodPlps = Pointer to store the number of good PLPs in the most recent superframe
	\param piPerSfErasurePlps = Pointer to store the number of bad PLPs in the most recent superframe

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_FLOW_PLP_DYN_PARAMS( HANDLE hResourceContext,
																	unsigned long iFlowId,
																	unsigned long* piTotalNumGoodPlps,
																	unsigned long* piTotalNumErasuresPlps,
																	unsigned long* piPerSfGoodPlps,
																	unsigned long* piPerSfErasurePlps );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.23 Subcommand 22 - Enable FTAP PLP Data Logging

		This command starts/stops FTAP PLP Data Packet Records Logging.
		The FTAP PLP data records for all the active FTAP Flows will be logged each superframe.
		This command requires that the following log packets are enabled:
		1)	MFLO FTAP PACKETRECORD HEADER PARAMS (0x120C)
		2)	MFLO FTAP PACKETRECORD PARAMS (0x120D)

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iFtapEnable = 0 - Disable FTAP Logging, 1 - Enable FTAP Logging.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_ENABLE_FTAP_PLP_DATA( HANDLE hResourceContext,
																  unsigned char iFtapEnable );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.24 Subcommand 23 - Enable FTAP OIS Reception Mode

		This command starts/stops FTAP OIS RECEPTION Test mode.
		When the device is set in this mode, OIS will be acquired every superframe (either WOIS/LOIS or BOTH)
		until it is turned off by the same command.
		Once in this mode, the FDS starts logging WOIS/LOIS information
		(log codes 0x120E (MFLO FTAP WOIS PARAMS) or 0x1210 (MFLO FTAP LOIS PARAMS)) once every superframe.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param eOisTestMode = OIS Test Mode.
		Defined by ftm_mflo_ois_test_mode_type in QLib_Defines.h
		\code
			FTM_MFLO_NS_ENABLE_WOIS_ONLY = 0x0,
			FTM_MFLO_NS_ENABLE_LOIS_ONLY = 0x1,
			FTM_MFLO_NS_ENABLE_WOIS_AND_LOIS = 0x2,
			FTM_MFLO_NS_DISABLE_WOIS_AND_LOIS = 0x3
		\endcode

	\return true if successful, false if fail.

	\warning Enabling OIS reception while demodulating MLCs will result in undefined behavior on the device.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_ENABLE_FTAP_OIS_RECEPTION_MODE( HANDLE hResourceContext,
																			unsigned char eOisTestMode );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.25 Subcommand 24 - Enable WICLIC Reception Mode

		This command enables/disables FTAP WICLIC RECEPTION Test mode.
		When FTAP WICLIC RECEPTION mode is enabled the WIC/LIC symbols will be decoded every superframe until
		FTAP WICLIC RECEPTION Test mode is disabled.
		When enabled, the WID/LID parameters are logged once every superframe (log code 0x1210 (MFLO FTAP WID LID Params) ).
		Note: FTAP OIS RECEPTION Test mode (see FTM_MFLO_NS_ENABLE_FTAP_OIS_RECEPTION_MODE (23) )
		      must first be enabled before enabling FTAP WIC/LIC Reception mode.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iWicLicMode = 0 - Disable WIC/LIC Reception Mode, 1 - Enable WIC/LIC Reception Mode.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_ENABLE_FTAP_WICLIC_RECEPTION_MODE( HANDLE hResourceContext,
																			   unsigned char iWicLicMode );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.26 Subcommand 25 - Set Jammer Detection Mode

		This command configures the Jammer Detection Mode.
		Jammer Detect functionality is only supported by MBP2700.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iJDMode = Jammer Detect Mode
		Defined by mftypes_jd_mode_type:
		\code
		MFLO_JD_MODE_AUTO = 0,
		MFLO_JD_MODE_1    = 1,
		MFLO_JD_MODE_2    = 2
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_SET_JAMMER_DETECT_MODE( HANDLE hResourceContext,
																	unsigned char iJDMode );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.26 Subcommand 26 - Freeze the AGC gain state

		This command freezes the AGC gain state at the current gain state.
		There may be a delay of up to 500ms after the command is sent before the gain state is frozen.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iFreezeState = 0 - Unfreeze, 1 - Freeze

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_FREEZE_GAIN_STATE( HANDLE hResourceContext,
															   unsigned char iFreezeState );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.27 Subcommand 27 - Enable the AFC outer loop

		This command freezes the AFC outer loop.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iEnable = 0 - Disable, 1 - Enable

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_ENABLE_AFC_OUTER_LOOP( HANDLE hResourceContext,
																   unsigned char iEnable );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.28 Subcommand 28 - Disable the AGC Gain Tracking

		This command disables the AGC Gain Tracking.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iDisable = 0 - Enable, 1 - Disable

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_DISABLE_AGC_GAIN_TRACKING( HANDLE hResourceContext,
																	   unsigned char iDisable );

	/******************************************************************************/
	/**

	Factory Test Mode MediaFLO Non-Signalling, 3.3.29 Subcommand 29 - Get the Jammer Detection State

		This command gets the current Jammer Detection state.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piJDMode = Jammer Detect Mode
		Defined by mftypes_jd_mode_type:
		\code
		MFLO_JD_MODE_AUTO = 0,
		MFLO_JD_MODE_1    = 1,
		MFLO_JD_MODE_2    = 2
		\endcode
	\param piJDState = Jammer Detect State
		Defined by mftypes_jd_state_type:
		\code
		MFLO_JD_STATE_INVALID      = 0,
		MFLO_JD_STATE_MODE_1       = 1,
		MFLO_JD_STATE_MODE_2       = 2,
		MFLO_JD_STATE_INITIALIZING = 3
		\endcode
	\param piJDSubstate = Jammer Detect Substate
		Defined by mftypes_jd_substate_type:
		\code
		MFLO_JD_SUBSTATE_NONE    = 0,
		MFLO_JD_SUBSTATE_POLLING = 1
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_JAMMER_DETECT_STATE( HANDLE hResourceContext,
																	 unsigned char* piJDMode,
																	 unsigned char* piJDState,
																	 unsigned char* piJDSubstate);

/******************************************************************************/
	/**
	Factory Test Mode MediaFLO Non-Signalling, 1.3.14 Subcommand 30 - Get RSSI and Gain State.

	This command retrieves the RSSI and Gain State. This value is not valid when the FLO is not actively decoding.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iGainState = the current gain state
	\param iRssi = Signed RSSI value in 1/100th dB resolution.
	\param bRssiValid = specifies validity of the RSSI measurement

	\return true if successful, false if fail.

	\warning MBP2700 Only

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_RSSI_AND_GAIN_STATE( HANDLE hResourceContext,
																	 unsigned char *piGainState,
																	 short *piRssi,
																	 unsigned char *pbRssiValid );

/******************************************************************************/
	/**
	MFLO get active flow Info

	This command gets information regarding all active flows in the system.

	Calls QLIB_FTM_MFLO_NS_GET_ALL_ACTIVE_FLOW_IDS then calls QLIB_FTM_MFLO_NS_GET_STREAM_INFO
	for each active flow.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param piActiveFlowCount = This is both and input and output param.  As an input param
							  it indicates the number of elements in pActiveFlowInfoArray.
							  As an output param it indicates the actual number of active
							  flows in the system.
	\param pActiveFlowInfoArray = Array of mftypes_active_flow_info structures
									(mftypes_active_flow_info is defined in QLib_Defines.h)

	\return true if successful, false if fail.

	\warning Prior to calling this function, sufficient space should be allocated in
			 pActiveFlowInfoArray to	store information about all active flows in
			 the system.  The required amount of space can be determined by first calling
			 QLIB_MFLO_GetBoundFlowCount.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_ACTIVE_FLOW_INFO_LIST( HANDLE hResourceContext,
																	   unsigned char* piActiveFlowCount,
																	   void* pActiveFlowInfoArray );

	/******************************************************************************/
	/**
	This function measures the Physical layer packet error rate.  This type of packet
	error rate measurement does not require a known nor finite sequence of FTAP packets
	from the FLO Tx Waveform.  The measurement is made by querying the accumulated PLP
	statistics for all requested Flow IDs.  Accumulated statistics continue to be
	queried until the minimum number of PLPs have been recorded.  Accumulated PLP
	statistics are queried through the FTM_MFLO_NS_GET_MLC_DYN_PARAMS function.

	After calling FTM_MFLO_NS_RESET_ALL_PLP_STATS to reset the accumulated statistics for all
	MLCs, this function may be called repeatedly until the desired level of confidence
	is achieved. To measure the packet error rate again, call FTM_MFLO_NS_RESET_ALL_PLP_STATS again
	before calling this function.

	Usage examples:

		FTM_MFLO_NS_RESET_ALL_PLP_STATS
		FTM_MFLO_NS_GetPER_Phy		--------------	Measure PER for first test


		FTM_MFLO_NS_RESET_ALL_PLP_STATS	---------
		FTM_MFLO_NS_GetPER_Phy					 |
		FTM_MFLO_NS_GetPER_Phy					 |-----  Measure PER for second test
		FTM_MFLO_NS_GetPER_Phy					 |		Note: Example shows measurement ran longer
		FTM_MFLO_NS_GetPER_Phy			---------		      to achieve desired level of confidence

	This function reports the packet error rate statistics for all requested Flow IDs,
	the current system state, and an error code.

	\param iNumberOfFlowIDs = the number of FlowIDs in aiFlowIDs
	\param aiFlowIDs = array of Flow IDs for which to get accumulated PLP statistics
	\param aiMlcIDs = array of MLC IDs that correspond to the Flow IDs in aiFlowIDs,
	                  this is required because MFLO_GET_MLC_PLP_STAT_DYN_PARAMS requires
					  the MLC ID not Flow ID
	\param aeSystem = array of mftypes_system_type with elements that correspond to the
	                  Flow IDs in aiFlowIDs, the System for each Flow ID is required by
					  QLIB_MFLO_GET_MLC_PLP_STAT_DYN_PARAMS
	\param iNoStatsTimeout = time in seconds to wait for statistics to update, max of 5
							 seconds recommended
	\param ePerToMeas = which packet error rate to measure, statistics for both Base and
	                    Enhancement layers will be reported but the determination of
						whether or not iMinPLPs have been measured depends on what this
						variable has been set to (mftypes_per_to_measure)
	\param iMinPLPs = the minimum number of PLPs to measure for all Flow IDs
	\param eRS = which statistics to report, Pre or Post Reed Solomon (mftypes_reed_solomon)
	\param paOverallStats = an array of type mftypes_per_statistics with length
							iNumberOfFlowIDs to store the packet error rate statistics for
							all requested Flow IDs
	\param peWideAreaSystemState = the current wide area system state if one of the
								   elements in aeSystem is WIDE (mftypes_state_type)
	\param peLocalAreaSystemState = the current local area system state if one of the
	                                elements in aeSystem is LOCAL (mftypes_state_type)
	\param peErrorCode = an error code used whenever possible to provide more information
	                     about why the function failed, see the warning below for one
						 exception (mftypes_error_code)

	\return true if successful, false if fail.

	\warning This function does not dynamically allocate memory for the pOverallStats
			 array.  Sufficient memory for pOverallStats must be allocated by the
			 calling program.

			 The results reported in paOverallStats are only valid if...
				FTM_MFLO_NS_GetPER_Phy return value is true		AND
				Requested system state(s) == ACTIVE_STATE	AND
			    peErrorCode == NOT_AVAILABLE.

			 If at some point during the measurement, the requested system state is not
			 ACTIVE_STATE,  the function will return but not fail.  The current system
			 state will be reported through peWideAreaSystemState and peLocalAreaSystemState.

			 If the statistics for one or more of the MLC IDs in aiMlcIDs have not updated
			 after the number of seconds specified by iNoStatsTimeout have elapsed, the
			 function will return but not fail. peErrorCode will be set to PLP_STATS_NOT_UPDATING.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GetPER_Phy( HANDLE hResourceContext,
														unsigned char iNumberOfFlowIDs,
														unsigned long* aiFlowIDs,
														unsigned char* aiMlcIDs,
														unsigned long* aeSystem,
														unsigned short iNoStatsTimeout,
														unsigned long ePerToMeas,
														unsigned long iMinPLPs,
														unsigned long eRS,
														void* paOverallStats,
														unsigned long* peWideAreaSystemState,
														unsigned long* peLocalAreaSystemState,
														unsigned long* peErrorCode );

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls several of the MediaFLO FTM
	API's to perform a specialized task.

	This function performs initialization steps required before making a new
	Physical layer + MAC layer packet error rate measurement.  This type of packet
	error rate measurement requires a known and finite sequence of FTAP packets from
	the FLO Tx Waveform.  This function resets the overall packet error rate statistics,
	updates data structures used in the packet error rate measurement, clears the log
	queue, registers the following log codes:

			LOG_MFLO_FTAP_PACKETRECORD_HEADER_PARAMS_C	0x120C
			LOG_MFLO_FTAP_PACKETRECORD_PARAMS_C			0x120D

	and enables FTAP PLP Data Logging Mode by through QLIB_FTM_MFLO_NS_ENABLE_FTAP_PLP_DATA.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iNumberOfFlowIDs = the number of FlowIDs in aiFlowIDs, must match the actual
							  number of active FlowIDs or this funtion will fail
	\param aiFlowIDs = array of Flow IDs for which to measure the packet error rate
	\param paOverallStats = an array of type mftypes_per_statistics with length
							iNumberOfFlowIDs to store the packet error rate
							statistics for all requested Flow IDs
	\param peErrorCode = an error code used whenever possible to provide more
						 information about why the function failed (mftypes_error_code)

	\return true if successful, false if fail.

	\warning This function does not dynamically allocate memory for the pOverallStats
			 array. Sufficient memory for pOverallStats must be allocated by the
			 calling program.

			 QLIB_MFLO_InitTAPMsgContent_PhyMAC must be called once before the first
			 time this function is called.

			 This function must be called once before calling QLIB_FTM_MFLO_NS_GetPER_PhyMAC.
			 The function QLIB_FTM_MFLO_NS_Stop_PhyMAC should be called at the end of the packet
			 error rate measurement. To make a new packet error rate measurement,
			 this function must be called again before calling QLIB_FTM_MFLO_NS_GetPER_PhyMAC.
			 See QLIB_FTM_MFLO_NS_GetPER_PhyMAC for usage examples.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_Start_PhyMAC( HANDLE hResourceContext,
														  unsigned char iNumberOfFlowIDs,
														  unsigned long* aiFlowIDs,
														  void* paOverallStats,
														  unsigned long* peErrorCode );

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls one of the MediaFLO Diagnostic ICD
	API's to perform a specialized task.

	This function measures the Physical layer + MAC layer packet error rate. This
	type of packet error rate measurement requires a known and finite sequence of
	FTAP packets from the FLO Tx Waveform.

	The measurement is made by getting erasure and FTAP Sequence Number /
	FTAP Test Signature information from log packets with the following log codes:

		LOG_MFLO_FTAP_PACKETRECORD_HEADER_PARAMS_C	0x120C
		LOG_MFLO_FTAP_PACKETRECORD_PARAMS_C			0x120D

	FTAP Sequence Number / FTAP Test Signature errors are determined by comparing
	the values reported in the log packets to the expected values that were set
	by QLIB_MFLO_InitTAPMsgContent_PhyMAC. Missing or mismatching pairs in each
	superframe are counted as errors.

	Total errors include erasures and FTAP Sequence Number / FTAP Test Signature errors.

	This function continues parsing log packets and keeping track of overall packet
	error rate statistics until the minimum number of PLPs have been measured for all
	requested Flow IDs.

	After calling QLIB_MFLO_Start_PhyMAC, this function may be called repeatedly until
	desired level of confidence is achieved. Once the current measurement is complete,
	call QLIB_MFLO_Stop_PhyMAC.  To measure the packet error rate again, call
	QLIB_MFLO_Start_PhyMAC again before calling this function.

	Usage example:

		QLIB_MFLO_InitTAPMsgContent_PhyMAC	-------- Called once at start of session

		QLIB_FTM_MFLO_NS_Start_PhyMAC		---------
		QLIB_FTM_MFLO_NS_GetPER_PhyMAC				|-----	Measure PER for first test
		QLIB_FTM_MFLO_NS_Stop_PhyMAC		---------

		QLIB_FTM_MFLO_NS_Start_PhyMAC		---------
		QLIB_FTM_MFLO_NS_GetPER_PhyMAC				|
		QLIB_FTM_MFLO_NS_GetPER_PhyMAC				|-----  Measure PER for second test
		QLIB_FTM_MFLO_NS_GetPER_PhyMAC				|		Note: Example shows measurement
		QLIB_FTM_MFLO_NS_GetPER_PhyMAC				|		      ran longer to achieve
		QLIB_FTM_MFLO_NS_Stop_PhyMAC		---------             desired confidence

		QLIB_MFLO_FinalCleanup_PhyMAC		-------- Called once at end of session

	This function reports the packet error rate statistics for all requested Flow IDs,
	the current system state, and an error code.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iNoLogPktsTimeout = time in seconds to wait for log packets
	\param ePerToMeas = which packet error rate to measure, statistics for both Base
						and Enhancement layers will be reported but the determination of
						whether or not iMinPLPs have been measured depends on what this
						variable has been set to (mftypes_per_to_measure)
	\param iMinPLPs = the minimum number of PLPs to measure for all Flow IDs
	\param eSystem = the system, required for getting the system state (mftypes_system_type)
	\param eErasureIndicator = which erasure indicator to use when counting erasures
	                           (mftypes_reed_solomon)
	\param paOverallStats = an array of type mftypes_per_statistics to store the packet
							error rate statistics for all requested Flow IDs
	\param peWideAreaSystemState = the current wide area system state if eSystem was set to
	                               WIDE or WIDE_AND_LOCAL (mftypes_state_type)
	\param peLocalAreaSystemState = the current local area system state if eSystem was set to
	                                LOCAL or WIDE_AND_LOCAL (mftypes_state_type)
	\param peErrorCode = an error code used whenever possible to provide more information
						 about why the function failed, see the warning below for two
						 exceptions (mftypes_error_code)

	\return true if successful, false if fail.

	\warning This function does not dynamically allocate memory for the pOverallStats
			 array. Sufficient memory for pOverallStats must be allocated by the
			 calling program.

			 The results reported in paOverallStats are only valid if
				QLIB_FTM_MFLO_NS_GetPER_PhyMAC return value is true		AND
				Requested system state(s) == ACTIVE_STATE				AND
				peErrorCode == NOT_AVAILABLE.

			 If at some point during the measurement, the system state is not ACTIVE_STATE,
			 the function will return but not fail. The current system state will be reported
			 through peWideAreaSystemState and peLocalAreaSystemState. At this point
			 QLIB_FTM_MFLO_NS_Stop_PhyMAC should be called.

			 If no log packets are received after the number of seconds specified by
			 iNoLogPktsTimeout have elapsed, the function will return but not fail and
			 peErrorCode will be set to NO_LOG_PACKETS. At this point QLIB_FTM_MFLO_NS_Stop_PhyMAC
			 should be called.

			The time period that is used when checking for status is controlled by the
			timing index QMSL_Timeout_Delay_MediaFLO_StatusCheck, to be used with the functions
			QLIB_ConfigureTimeOut() and QLIB_GetTimeOut().

			 This function depends on receiving all packets for all requested Flow IDs in
			 an expected order. If any expected log packets are not received, the function
			 will return but not fail and peErrorCode will be set to MISSING_LOG_PACKETS.
			 At this point QLIB_FTM_MFLO_NS_Stop_PhyMAC should be called.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GetPER_PhyMAC( HANDLE hResourceContext,
														   unsigned short iNoLogPktsTimeout,
														   unsigned long ePerToMeas,
														   unsigned long iMinPLPs,
														   unsigned long eSystem,
														   unsigned long eErasureIndicator,
														   void* paOverallStats,
														   unsigned long* peWideAreaSystemState,
														   unsigned long* peLocalAreaSystemState,
														   unsigned long* peErrorCode );

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls one of the MediaFLO Diagnostic ICD
	API's to perform a specialized task.

	This function stops the current Physical layer + MAC layer packet error rate
	measurement. It disables FTAP PLP Data Logging Mode, clears all log codes for
	LOG_EQUIP_ID_1X, and clears the log queue.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()

	\return true if successful, false if fail.

	\warning This function should be called at the end of a packet error rate
			 measurement after all calls to QLIB_FTM_MFLO_NS_GetPER_PhyMAC for the current
			 measurement are complete. See QLIB_FTM_MFLO_NS_GetPER_PhyMAC for usage examples.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_Stop_PhyMAC( HANDLE hResourceContext );

/******************************************************************************
						DVB-H Diag Commands
*******************************************************************************/

	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.1 Subcommand 0 -Layer 1 Acquire Command

			This command tells DVB-H L1 to acquire on the given frequency, mode and guard.
			DVB-H L1 must be powered up via QLIB_DIAG_DVBH_UBM_L1_POWERUP_CMD()	before this command is sent.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param	iMode = Mode to acquire on
		Defined by ubm_dvbh_mode in QLib_Defines.h:
		\code
		UBM_L1_MODE_1	= 1,
		UBM_L1_MODE_2	= 2,
		UBM_L1_MODE_3	= 3,
		UBM_L1_MODE_ALL	= 255,
		\endcode
	\param iGuard = Signal Guard interval to use.
		Defined by ubm_dvbh_guard in QLib_Defines.h:
		\code
		UBM_L1_GUARD_4		= 0,
		UBM_L1_GUARD_8		= 1,
		UBM_L1_GUARD_16		= 2,
		UBM_L1_GUARD_32		= 3,
		UBM_L1_GUARD_ALL	= 255
		\endcode
	\param iFrequency = Frequency to acquire. Value in Hz/10
	\param iBandwidth = The bandwidth to acquire to.
		Defined by ubm_dvbh_bandwidth in QLib_Defines.h:
		\code
		UBM_L1_BW_5		=5,
		UBM_L1_BW_6		=6,
		UBM_L1_BW_7		=7,
		UBM_L1_BW_8		=8,
		\endcode
	\param iPriority = Sets the acquire priority, 0 for low, 1 for high.

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning  Must call QLIB_DIAG_DVBH_UBM_L1_POWERUP_CMD() first.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_ACQ_CMD(HANDLE  hResourceContext,
														 unsigned char iMode,
														 unsigned char iGuard,
														 unsigned long iFrequency,
														 unsigned char iBandwidth,
														 unsigned char iPriority);
	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.2 Subcommand 1 - Layer 1 Configure demodulation of a control PID.

			This command configures the demodulation of a control pid.
			L1 must be powered up and acquisition must have occurred before this command can be issued.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param	iPid = The control ID to configure.
	\param iAdd_rem_ind = Select add (0) or remove (1) PID.

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning  L1 must be powered up and acquisition must have occurred before this command can be issued.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_CFG_CTRL_PID_CMD(HANDLE  hResourceContext,
														 unsigned short iPid,
														 unsigned char  iAdd_rem_ind);
	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.3 Subcommand 2 - Layer 1 Configure demodulation of a data PID.

			This command configures the demodulation of a data pid.
			L1 must be powered up and acquisition must have occurred before this command can be issued.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param	iPid = The program ID to configure.
	\param iAdd_rem_ind = Select add (0) or remove (1) PID.
	\param iFrame_size = A frame size of between 0 and 3 (frames) for a given pid.
	\param iMpe_fec = enable mpe_fed, 0 if mpe_fec is disabled, 1 for mpe_fec enabled.
	\param iMax_burst_dur = Max burst duration in ms.

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning  L1 must be powered up and acquisition must have occurred before this command can be issued.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_CFG_DATA_PID_CMD(HANDLE  hResourceContext,
														 unsigned short iPid,
														 unsigned char  iAdd_rem_ind,
														 unsigned char iFrame_size,
														 unsigned char iMpe_fec,
														 unsigned short iMax_burst_dur);
	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.6 Subcommand 5 - Layer 1 Set or read L1 config item.

			This command can set or read a given L1 config item


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param  iGet_set_item = Get/Set the item. 0 sets item to a value. 1 to gets the item value.
	\param	iItem = configuration item to set/get.
		Defined by ubm_dvbh_configuration_items in QLib_Defines.h:
		\code
		UBM_L1_CFG_EBI2_WS		=0,
		UBM_L1_CFG_USE_PLLS		=1,
		UBM_L1_CFG_CTRL_PID_EXT_MODE	=2,
		UBM_L1_CFG_CTRL_PID_EBI2_MODE	=3,
		UBM_L1_CFG_PAGE_MODE		=4,
		UBM_L1_CFG_USE_MODE2_CPCE	=5,
		UBM_L1_CFG_DEBUG		=6,
		UBM_L1_HANDLE_L3_ACK		=7,
		UBM_L1_CFG_USE_ACQ_TIMEOUT	=8,
		UBM_L1_CFG_SNOOZE		=9,
		UBM_L1_CFG_BW			=11,
		UBM_L1_RX_FRONT_WARMUP		=12,
		UBM_L1_CHANGE_TCXO_PDM		=13,
		UBM_L1_MAP_ADDR_12_18		=14,
		UBM_L1_FAP_LAP_CORR_MASK	=15,
		UBM_L1_SIGNAL_MONITOR		=16,
		UBM_L1_CFG_INPUT_MODE		=17,
		UBM_L1_CFG_RDSP_CLK_SRC		=18,
		\endcode
	\param iValue = value for configuration item.
	\param	piItem = pointer where the configuration item that was set is stored.
		Defined by ubm_dvbh_configuration_items in QLib_Defines.h:
	\param piValue = pointer to location to store the value of configuration item.

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_CFG_ITEM (HANDLE  hResourceContext,
														 unsigned char iGet_set_item,
														 unsigned char  iItem,
														 unsigned long iValue,
														 unsigned char  *piItem,
														 unsigned long *piValue);
	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.8 Subcommand 7 - Layer 1 Get acquisition status

			This function returns the acquisition state of DVB-H L1


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param	piAcquisition_sucess = pointer to the location to store the acquestion status
								   0 indicates  acquisition failed (mode and guard invalid)
								   1 indicates acquisition succeeded
	\param  piMode = Pointer to location to store the mode of the acquired signal.
		Defined by ubm_dvbh_mode in QLib_Defines.h:
		\code
		UBM_L1_MODE_1	= 1,
		UBM_L1_MODE_2	= 2,
		UBM_L1_MODE_3	= 3,
		\endcode
	\param	piGuard = Pointer to location to store the guard of the acquired signal.
		Defined by ubm_dvbh_guard in QLib_Defines.h:
		\code
		UBM_L1_GUARD_4		=0,
		UBM_L1_GUARD_8		=1,
		UBM_L1_GUARD_16		=2,
		UBM_L1_GUARD_32		=3,
		\endcode

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_ACQ_STATUS  (HANDLE  hResourceContext,
																unsigned char *piAcquisition_sucess,
																unsigned char  *piMode,
																unsigned char  *piGuard );
	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.9 Subcommand 8 - Layer 1 Sets up the PRBS one bit error test.

			The test box is set up to transmit a packet containing all 0 bits.
			This command sets up a hardware block within the MPE-FEC decoder block to count
			the number of bits set to 1 between the two packet counts.
			This count can be read back using the UBM_L1_PRBS_ONE_BIT_STATUS() (3.3.10) command.



	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param	iLength = Number of packets to run the test over
	\param  iThreshold = Threshold to determine good vs bad sample. If set to 0 then the default is used.

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_PRBS_ONE_BIT_CMD  (HANDLE  hResourceContext,
																unsigned long  iLength,
																unsigned long  iThreshold );
	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.10 Subcommand 9 - Layer 1 Gets the results from the 1 bit prbs test.

			This command returns the number of 1 bits counted in the PRBS one bit test (3.3.9).


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer().
	\param piTest_done		= pointer to store test Status, 0 indicates the test is not finished 1 = test finished .
	\param piOnes_cnt		= pointer to store the number of ones counted in the test.
	\param piGood_pkt_cnt	= pointer to store the number of good packets.
								(should be equal to length given in UBM_L1_PRBS_ONE_BIT_CMD if the test is finished).
	\param piBad_pkt_cnt	= pointer to store the number of packets thrown away due to sampling issues.
	\param piMax_sample_pkt_cnt	= Max number of packets used for one sample.

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_PRBS_ONE_BIT_STATUS  (HANDLE  hResourceContext,
																		unsigned char *piTest_done,
																		unsigned long *piOnes_cnt,
																		unsigned long *piGood_pkt_cnt,
																		unsigned long *piBad_pkt_cnt,
																		unsigned long *piMax_sample_pkt_cnt );
	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.11 Subcommand 10 -This command powers up the MBP receiver and initializes DVB-H L1.

			This command should be called before any other DVB-H L1 non-signaling commands.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_POWERUP_CMD  (HANDLE  hResourceContext );
	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.12 Subcommand 11 -This command powers down the MBP receiver.

			This command should be called when exiting DVBH non-signalling mode.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_POWERDOWN_CMD  (HANDLE  hResourceContext );
	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.13 Subcommand 13 -  Wake up UBM.

			This command will trigger DVB-H L1 to wakeup immediately when in snooze/slotted mode.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_WAKEUP_NOW_CMD   (HANDLE  hResourceContext );
	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.16 Subcommand 15 - Enable LNA update.

			This command will enable the LNA update loop.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_ENABLE_LNA_UPDATE    (HANDLE  hResourceContext );
	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.17 Subcommand 16 - Disable LNA update.

			This command will disable the LNA update loop.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_DISABLE_LNA_UPDATE    (HANDLE  hResourceContext );

	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.18 Subcommand 17 - Collect packet count stats for MPE-FEC.

			This command is used to collect packet counter statistics for MPE-FEC.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iPid				= Program ID for data pid
	\param piPid			= Pointer to store	program ID for data pid
	\param piPid_valid		= Pointer to store whether the PID was valid, if 0 ignore Pid_burst_cnt
	\param piPid_burst_cnt	= Pointer to store the number of bursts for pid above
	\param piRs1_pkt_cnt	= Pointer to store RS1 packet counter
	\param piRs1_trash_cnt	= Pointer to store RS1 trashed packet counter
	\param piPrbs_cnt		= Pointer to store PRBS counter

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_PACKET_CNT_CMD    (HANDLE  hResourceContext,
																	unsigned short iPid,
																	unsigned short *piPid,
																	unsigned char *piPid_valid,
																	unsigned long *piPid_burst_cnt,
																	unsigned long *piRs1_pkt_cnt,
																	unsigned long *piRs1_trash_cnt,
																	unsigned long *piPrbs_cnt	);
	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.19 Subcommand 18 - Set default jammer thresholds.

			This command changes the default jammer thresholds.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iNumber_of_Jammers			= Number of jammers, from 0 to 2
	\param  iJammer_1_Gain				= Gain for Jammer 1
	\param  iNotch_1_I					= Notch I, 1st Jammer if Number of Jammers > 0
	\param  iNotch_1_Q					= Notch Q, 1st Jammer if Number of Jammers > 0
	\param  iJammer_2_Gain				= Gain for Jammer 2
	\param  iNotch_2_I					= Notch I, 2nd Jammer if Number of Jammers > 1
	\param  iNotch_2_Q					= Notch Q, 2nd Jammer if Number of Jammers > 1

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning
		This command has to be sent prior to the acquisition command.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_CFG_JAMMER_CMD    (HANDLE  hResourceContext,
																	unsigned char iNumber_of_Jammers,
																	unsigned char iJammer_1_Gain,
																	unsigned short iNotch_1_I,
																	unsigned short iNotch_1_Q,
																	unsigned char iJammer_2_Gain,
																	unsigned short iNotch_2_I,
																	unsigned short iNotch_2_Q);
	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.20 Subcommand 19 - Gets the RSSI.

			This command will trigger DVB-H L1 to display and return the current RSSI information

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pRssi_qb			= Pointer to location to store required Signal Strength Information in Q6 format
	\param pLna_state		= Pointer to location to store Low Noise Amplifier state
	\param pDb_vref_q6		= Pointer to location to store dBvref in Q6 format
	\param pLog2ee_q6       = Pointer to location to store Log2 of the normalized energy estimate in Q6 format.
	\param pAgc_filt_state_q12 =Pointer to location to store DVGA gain in Q12 log2 format

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning
		The system must be acquired.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_RSSI_STATUS    (HANDLE  hResourceContext,
																	short *pRssi_qb,
																	unsigned char *pLna_state,
																	short *pDb_vref_q6,
																	short *pLog2ee_q6,
																	short *pAgc_filt_state_q12);

	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.24 Subcommand 23 - Configure the post FFT jammer Cancellation.

			This command configures post-FFT jammer parameters.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iMode = Mode of the acquired signal.
		Defined by ubm_dvbh_mode in QLib_Defines.h:
		\code
		UBM_L1_MODE_1	= 1,
		UBM_L1_MODE_2	= 2,
		UBM_L1_MODE_3	= 3,
		\endcode
	\param Threshold  =  Post FFT Threshold for mode above
	\param Gain = Post FFT gain for mode above
	\param Region0_Odd_Value = Odd Value for Region 0
	\param Region0_Even_Value =Even Value for Region 0
	\param  Region1_Odd_Value = Odd Value for Region 1
	\param  Region1_Even_Value =Even Value for Region 1
	\param  Region2_Odd_Value = Odd Value for Region 2
	\param  Region2_Even_Value =Even Value for Region 2
	\param  Region3_Odd_Value = Odd Value for Region 3
	\param  Region3_Even_Value =Even Value for Region 3
	\param  Region4_Odd_Value = Odd Value for Region 4
	\param  Region4_Even_Value =Even Value for Region 4
	\param  Region5_Odd_Value = Odd Value for Region 5
	\param  Region5_Even_Value =Even Value for Region 5
	\param  Region6_Odd_Value = Odd Value for Region 6
	\param  Region6_Even_Value =Even Value for Region 6
	\param  Region7_Odd_Value = Odd Value for Region 7
	\param  Region7_Even_Value =Even Value for Region 7
	\param  Region_Enable = Region enable for mode above


	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning
		The system must be acquired.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_CFG_POST_FFT_JAMMER_CMD    (HANDLE  hResourceContext,
															unsigned char iMode,
															unsigned char Threshold,
															unsigned char Gain,
															unsigned short Region0_Odd_Value,
															unsigned short Region0_Even_Value,
															unsigned short Region1_Odd_Value,
															unsigned short Region1_Even_Value,
															unsigned short Region2_Odd_Value,
															unsigned short Region2_Even_Value,
															unsigned short Region3_Odd_Value,
															unsigned short Region3_Even_Value,
															unsigned short Region4_Odd_Value,
															unsigned short Region4_Even_Value,
															unsigned short Region5_Odd_Value,
															unsigned short Region5_Even_Value,
															unsigned short Region6_Odd_Value,
															unsigned short Region6_Even_Value,
															unsigned short Region7_Odd_Value,
															unsigned short Region7_Even_Value,
															unsigned short Region_Enable);


	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.28 Subcommand 27 - Force the LNA State.

			This command allows the LNA State to be forced.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iLNAState	= LNA value from 0 to 5. 0 is the highest gain state.

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning
		The system must be acquired.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_SET_LNA_CMD(HANDLE  hResourceContext,unsigned char iLNAState);

	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.34 Subcommand 33 - Prepare for RSSI Calibration information.

			This command sets up the UUT for CW calibration. It allows the UUT to tune
			when no signal is present.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning
		The system must be acquired.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_PREPARE_FOR_CW_CAL (HANDLE  hResourceContext);

	/******************************************************************************/
	/**
	DVB-H L1 DIAG, 4.3.36 Subcommand 35 - Disable DSP Loops.

			This command disables or enables specific DSP loops.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iTimeTrackDisable = enable (0) or disable (1) the RDSP Time Tracking Loop.
	\param iFreqTrackDisable = enable (0) or disable (1) the RDSP Frequency Tracking Loop.
	\param iRxFrontCoarseDcDisable = enable (0) or disable (1) the RDSP Coarse DC Correction Loop.
	\param iRxFrontAgcDisable = enable (0) or disable (1) the RDSP AGC Loop.

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_DVBH_UBM_L1_DISABLE_DSP_LOOPS_CMD (HANDLE hResourceContext,
																		unsigned char iTimeTrackDisable,
																		unsigned char iFreqTrackDisable,
																		unsigned char iRxFrontCoarseDcDisable,
																		unsigned char iRxFrontAgcDisable);

/******************************************************************************
						WLAN FTM

  NOTE: Please check the module manfucturer's documentation for specific information
        about the commands or parameters.  The documentation for the module-specific
		commands is based sources and Qualcomm can give very little support about
		individual commands and they can also not add new commands unless the
		module vendor writes the corresponding firmware and provides the command
		specification.

*******************************************************************************/
	/******************************************************************************/
	/**

	WLAN FTM, Set the WLAN module type

	Set the WLAN module type, to be used for all QMSL WLAN FTM functions except for
	QLIB_FTM_WLAN_USER_CMD().

	If this funciton is not called, then the default type is FTM_WLAN_ModuleType_Philips.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param eModuletype =
			Defined by FTM_WLAN_ModuleTypeEnum:
			\code
			FTM_WLAN_ModuleType_Philips	= 0x00,	//!< Philips WLAN module
			FTM_WLAN_ModuleType_Atheros	= 0x01,	//!< Atheros WLAN module
			\endcode
		\param iRequestSize = Number of bytes to be sent in the request packet.
		\param piRequestBytes = Pointer to a buffer of request packet contents.
		\param piResponseSize = Pointer to number of bytes received in the response packet
								NOTE: when calling this function, the value must be equal to the
								maximum size of the receive buffer.  When the function returns, the
								value will be the actual number of bytes filled into the receive buffer.
		\param iResponseBytes = Pointer to a buffer to store the response packet contents.

	\return Returns true if the command was dispatched successfully through the FTM.

	\warning This function only sets QMSL's mode.  The phone must also have a certain
	         NV item written to indicate whether the phone things the module is
			 Atheros or Philips.  The NV item number is 4202. A value of 0 indicates
			 Philips and a value of 1 indicates Atheros.


			These files come from the wlan folder in the bulid and must be put into the
			phone's EFS folder /brew

				AMSS folder: wlan\oem\phg_80211g\libs

			Finally, in the phone's EFS, you must delete file /brew/mod/netlist

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_SetModuleType
				(
				HANDLE hResourceContext,
				unsigned long eModuleType
				);


	/******************************************************************************/
	/**

	WLAN FTM ICD, 2.1 FTM_WLAN_DISPATCH

	Sends a request/response packet to a WLAN module.  The command packets are defined
	by the individual module vendors (e.g. Philips/Atheros).

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iRequestSize = Number of bytes to be sent in the request packet.
		\param piRequestBytes = Pointer to a buffer of request packet contents.
		\param piResponseSize = Pointer to number of bytes received in the response packet
								NOTE: when calling this function, the value must be equal to the
								maximum size of the receive buffer.  When the function returns, the
								value will be the actual number of bytes filled into the receive buffer.
		\param iResponseBytes = Pointer to a buffer to store the response packet contents.

	\return Returns true if the command was dispatched successfully through the FTM.
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_USER_CMD
				(
				HANDLE hResourceContext,
				unsigned short iRequestSize,
				unsigned char* piRequestBytes,
				unsigned short* piResponseSize,
				unsigned char* piResponseBytes
				);


	/******************************************************************************/
	/**

	Philips WLAN command, START

		This message is defined in [8] but not defined or implemented in the BGW200
		implementation.

		To avoid any confusion the message is defined and implemented for BGW211.
		The target always returns PCTI_SUCCESS. The same message is used as CONNECT_DUT.

		Request and confirm have no parameters. In case of SPI and UART the status is always
		PCTI_SUCCESS.

	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_START
				(
					HANDLE hResourceContext,
					unsigned char* piStatusCode
				);


	/******************************************************************************/
	/**

	Philips WLAN command, STOP

		On reception of the STOP message the target cancels the currently performed test. The confirm
	message is sent when this has been finished. If no test is running the target immediately returns
	with success.

	The STOP request message has no parameters. The confirm message has no other parameters
	than the mandatory status code.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\return true if successful, false if failure
	\warning FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_STOP
				(
					HANDLE hResourceContext,
					unsigned char* piStatusCode
				);

	/******************************************************************************/
	/**

	Philips WLAN command, TX_CONTINUOUS

		On TX_CONTINUOUS message the target configures the system to continuously
		transmit a single sine wave. The offset frequency of this message is configured
		with the FreqOffs parameter. The confirm message is sent directly after the
		target has initiated the sine wave.

		The transmission stops on the STOP message. In case another test is already
		performing (e.g.TX_BURST), the target wont do anything and confirm with
		the PCTI_FAILURE.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param iChannelNo  = specifies the channel used for Tx. (1-14)
	\param iAntenna    = Antenna to be used for tx (1, 2).
	\param iRates      = Rate of transmission (IGNORED)
	\param iMode       = Data mode (IGNORED)
	\param iTxGain     = 0x00-0x0F are used for BGW200. Since this setting cannot be properly
                         mapped to BGW211, PCTI returns PCTI_FAILURE for all values except
                         for 0x10. With 0x10 the target takes the current values that can be
                         configured with TX_POWER_CONTROL (see 3.2.4)

	\param iSignalType = Offset frequency relative to the carrier, defined by FTM_WLAN_Philips_enSignalType
		\code
           FTM_WLAN_Philips_SINGLETONE_100KHZ    = 1,
           FTM_WLAN_Philips_SINGLETONE_3MHZ      = 2,
           FTM_WLAN_Philips_SINGLETONE_5d5MHZ    = 3,
           FTM_WLAN_Philips_DUALTONE_100_300KHZ  = 4,
           FTM_WLAN_Philips_DUALTONE_3_3d1MHZ    = 5,
           FTM_WLAN_Philips_DUALTONE_5d5_5d6MHZ  = 6,
           FTM_WLAN_Philips_QPSK_0_1_SEQUENCE    = 7,
           FTM_WLAN_Philips_QPSK_PN_SEQUENCE     = 8

		\endcode
	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_TX_CONTINUOUS
				(
					HANDLE hResourceContext,
					unsigned char* piStatusCode,
					unsigned char iChannelNo,
					unsigned char iAntenna,
					unsigned short iRates,
					unsigned char iMode,
					unsigned char iTxGain,
					unsigned short iSignalType
				);

	/******************************************************************************/
	/**

	Philips WLAN command, TX_BURST

	   On TX_BURST the target initiates the transmission of valid WLAN broadcast frames.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param 	iChannelNo       = This field specifies the channel used for Tx.
	\param 	iAntenna	     = Antenna to be used for tx
	\param 	iRates           = Rate of transmission, defined by FTM_WLAN_Philips_enDataRate
		\code
          // 11b rates backwards compatible with washington
          FTM_WLAN_Philips_RATE_1_MBPS	= 0x0,
          FTM_WLAN_Philips_RATE_2_MBPS	= 0x1,
          FTM_WLAN_Philips_RATE_5_MBPS	= 0x2,
          FTM_WLAN_Philips_RATE_11_MBPS	= 0x3,
          // plcp rate codes used for OFDM rates
          FTM_WLAN_Philips_RATE_6_MBPS	= 11,
          FTM_WLAN_Philips_RATE_9_MBPS	= 15,
          FTM_WLAN_Philips_RATE_12_MBPS	= 10,
          FTM_WLAN_Philips_RATE_18_MBPS	= 14,
          FTM_WLAN_Philips_RATE_24_MBPS	= 9,
          FTM_WLAN_Philips_RATE_36_MBPS	= 13,
          FTM_WLAN_Philips_RATE_48_MBPS	= 8,
          FTM_WLAN_Philips_RATE_54_MBPS	= 12

		\endcode
	\param 	bPreamble        = 0 = short,
	                           1 = long preamble Only valid for 11b rates, in case of 1Mbps only long preamble is
                               allowed. For short preamble, PCTI returns PCTI_STATUS_FAILURE

	\param 	iPacketLength    = Tx packet length to be used.
								Number of bytes payload (frame body). The maximum length supported for the
								frame body is 1500 bytes. The length of the frame on the air is
								therefore Packet Length + 28 bytes (MAC header + FCS)
	\param 	iPacketInterval  = Tx packet interframe time, units of microseconds
	\param 	iNumberOfPackets = # of Tx packets to be used, 0 = infinite

	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_TX_BURST
				(
					HANDLE hResourceContext,
					unsigned char* piStatusCode,
					unsigned char iChannelNo,
					unsigned char iAntenna,
					unsigned char iRates,
					unsigned char bPreamble,
					unsigned short iPacketLength,
					unsigned short iPacketInterval,
					unsigned long iNumberOfPackets
				);

	/******************************************************************************/
	/**

	Philips WLAN command, TX_POWER_CONTROL

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param iTxBB = Global linear baseband scaling factor, the default value is 16384.
					 The scaling factor to get a target baseband backoff can be calculated
					 using the Scaling Equation. The maximum allowed value of 32767 leads to a backoff
					 of 3dB. Useful backoff values are between 3dB and 30dB.

	\param iTxLF  = LF attenuator setting in the RF IC (0 - 15dB)
	\param iTxRF  = RF attenuator setting in the RF IC (0 - 15dB)

	  Scaling Equation: S = 10 ^[  (B - 3dB)/20 ] * 32768

	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_TX_POWER_CONTROL
				(
					HANDLE hResourceContext,
					unsigned char* piStatusCode,
					unsigned short iTxBB,
					unsigned char iTxLF,
					unsigned char iTxRF
				);

	/******************************************************************************/
	/**

	Philips WLAN command, RX_CONTINUOUS

		On RX_CONTINUOUS the target goes into receive mode. While it is in the receive mode it
		updates the internal RX statistics. All statistics are reset internally before the RX_CONTINUOUS
		mode is started.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param iChannelNo = This field specifies the channel used for Tx.
	\param iAntenna = Antenna to be used for tx

	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_RX_CONTINUOUS
				(
					HANDLE hResourceContext,
					unsigned char* piStatusCode,
					unsigned char iChannelNo,
					unsigned char iAntenna
				);

	/******************************************************************************/
	/**

	Philips WLAN command, GET_MAC_ADDRESS

		The target reads the burned-in MAC address from the EEPROM and returns the address with the
		confirm message. This should never fail. In case the MAC_ADDRESS is not configured it returns
		0x424242424242.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param aiMAC_Address = Buffer to store MAC address, size is defined by FTM_WLAN_MAC_ADRESS_SIZE

	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_GET_MAC_ADDRESS
				(
					HANDLE hResourceContext,
					unsigned char* piStatusCode,
					unsigned char aiMAC_Address[6]
				);

	/******************************************************************************/
	/**

	Philips WLAN command, SET_MAC_ADDRESS

		If there is no MAC_ADDRESS in the EEPROM, SET_MAC_ADDRESS appends a new
		information element containing the given address to the customer section of the EEPROM.
		If there is already a MAC_ADDRESS in the EEPROM, SET_MAC_ADDRESS replaces the old
		one with the given new one.

		If there is no valid VERSION field in the EEPROM, SET_MAC_ADDRESS appends a new
		VERSION information element containing the main version number associated with the firmware.
		This specification is valid for PCTI v1.36 or higher.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param aiMAC_Address = Buffer containing MAC address to be programmed.
	                       Size is defined by FTM_WLAN_MAC_ADRESS_SIZE

	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_SET_MAC_ADDRESS
				(
					HANDLE hResourceContext,
					unsigned char* piStatusCode,
					unsigned char aiMAC_Address[6]
				);

	/******************************************************************************/
	/**

	Philips WLAN command, SET_MODULE

		The SET_MODULE message is used to indicate to the target what kind of module it is working
		on. This may affect some internal settings. Currently there is only BGW211 defined for SA5253
		based modules.

		On the SET_MODULE message the target returns PCTI_SUCCESS in the case that the module
		type is BGW211. For all other values it returns PCTI_NOT_SUPPORTED.

		The SET_MODULE request message carries a single byte indicating the module type.
		PCTI currently only supports the BGW211 module. The confirm message only contains the
		status.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param iModule = Module id, defined by FTM_WLAN_Philips_enModuleType
		\code
          // Washington modules (not supported)
          FTM_WLAN_Philips_M1		= 0x00,
          FTM_WLAN_Philips_M2		= 0x01,
          FTM_WLAN_Philips_M3		= 0x02,
          FTM_WLAN_Philips_M4		= 0x03,
          FTM_WLAN_Philips_MWAmax	= 0x0F,

          // Georgia modules
          FTM_WLAN_Philips_M_BGW211	= 0x10

		\endcode

	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_SET_MODULE
				(
					HANDLE hResourceContext,
					unsigned char* piStatusCode,
					unsigned char iModule
				);

	/******************************************************************************/
	/**

	Philips WLAN command, GET_HWSW_VERSIONS

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param piSwVer       = Major version in upper byte, minor version in lower byte
	\param piHwBBChipVer = Baseband IC version
	\param piHwRFChipVer = RF Chip version
	\param iEEPROMVerFirmware = Version expected and written by the firmware
	\param iEEPROMVerManufacture = Version found in the manufacturer section of the EEPROM
	\param iEEPROMVerCustomer = Version found in the customer section of the EEPROM

	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_GET_HWSW_VERSIONS
				(
					HANDLE hResourceContext,
					unsigned char* piStatusCode,
					unsigned short* piSwVer,
					unsigned short* piHwBBChipVer,
					unsigned short* piHwRFChipVer,
					unsigned short*	piEEPROMVerFirmware,
					unsigned short*	piEEPROMVerManufacture,
					unsigned short* piEEPROMVerCustomer
				);

	/******************************************************************************/
	/**

	Philips WLAN command, TX_POWER_SET_CALIBRATED

		On TX_POWER_SET_CALIBRATED the target uses the calibration data as stored in the internal
		EEPROM to set the TX output power at the antenna to the value requested in the message.

		In the case that no valid calibration data is stored in the EEPROM the target returns
		PCTI_FAILURE.

		The request message carries a single signed byte for the targeted output power in dBm. The full
		range is valid. If the specified power is larger than the calibrated power, the latter will be used. If
		the specified power is lower than the minimum possible power, which is at least 20 dB below the
		calibrated power, the minimum power will be used.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param iPower_dBm = Tx power in dBm
	\param iAddress = Address returned from confirm message body

	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_TX_POWER_SET_CALIBRATED
				(
					HANDLE hResourceContext,
					unsigned char* piStatusCode,
					unsigned char iPower_dBm,
					unsigned long* piAddress
				);

	/******************************************************************************/
	/**

	Philips WLAN command, READ_STATISTICS (partial)

		Parses enough of the READ_STATISTICS result to return the RSSI
		levels.  Use the QLIB_FTM_WLAN_Philips_READ_STATISTICS_Partial() command
		to return the entire READ_STATISTICS structure.

		On READ_STATISTICS the target collects the internal counter in a structure
		and returns it with the confirm message and status PCTI_SUCCESS.

		Only a few of the available parameters are returned through the C interface.

		If the full packet response is desired, then the user command should be called.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param piNumRxFrames     - CRCOKA1
	\param piNumRxBytesOk    - CumulatedNumRx - BytesCRCOKA1
	\param piRSSI_OK         - BBRSSICumulated - AllRxCRCOKA1
	\param piRSSI_NOK        - BBRSSICumulated - AllRxCRCErrorA1
	\param piNumRxFrames_ant2     - CRCOKA2
	\param piNumRxBytesOk_ant2    - CumulatedNumRx - BytesCRCOKA2
	\param piRSSI_OK_ant2         - BBRSSICumulated - AllRxCRCOKA2
	\param piRSSI_NOK_ant2        - BBRSSICumulated - AllRxCRCErrorA2



	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_READ_STATISTICS_Partial
				(
					HANDLE hResourceContext,
					unsigned char* piStatusCode,
					unsigned long* piNumRxFrames_ant1,
					unsigned long* piNumRxBytesOk_ant1,
					unsigned long* piRSSI_OK_ant1,
					unsigned long* piRSSI_NOK_ant1,
					unsigned long* piNumRxFrames_ant2,
					unsigned long* piNumRxBytesOk_ant2,
					unsigned long* piRSSI_OK_ant2,
					unsigned long* piRSSI_NOK_ant2
				);

	/******************************************************************************/
	/**

	Philips WLAN command, READ_STATISTICS (full)

		Reads the entire READ_STATISTICS result and copies it into a user defined
		buffer.  The parsing must be done by the user.

		To get RSSI only fields, use QLIB_FTM_WLAN_Philips_READ_STATISTICS_Partial()

		On READ_STATISTICS the target collects the internal counter in a structure
		and returns it with the confirm message and status PCTI_SUCCESS.

		Only a few of the available parameters are returned through the C interface.
		This is done to focus on the Antenna 1 receiver level measurements.

		If the full packet response is desired, then the user command should be called.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param pReadStatisticsUserBuffer - pointer to 128 bytes, into which the READ_STATISTICS
		   structure will be copied.  Size of buffer is defined by
		   FTM_WLAN_Philips_PCTI_READ_STATISTICS_RESPONSE_SIZE


	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_READ_STATISTICS_Full
				(
					HANDLE hResourceContext,
					unsigned char* piStatusCode,
					void* pReadStatisticsUserBuffer
				);


	/******************************************************************************/
	/**

	Philips WLAN command, RESET_STATISTICS

		Reset the statistics reutrued by READ_STATISTICS

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus

	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_RESET_STATISTICS(
		HANDLE hResourceContext,
		unsigned char* piStatusCode
		);

	/******************************************************************************/
	/**

	Philips WLAN command, SLEEP_MODE

		Used to initiate Sleep Mode Setting for Power Save. The parameters specify
		modes like Sleep between beacons, sleep between DTIM beacons or wake after a
		specified time. Power save during IBSS is also specifiable.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param char iMode, defined by FTM_WLAN_Philips_enSleepMode
	  \code

        FTM_WLAN_Philips_PCTI_SLEEP_DOWN = 0x0,
		0 = Go to sleep and awake with the next message from the host. Similar to
			SLEEP. Wake-up will not work over UART. The confirm is sent from the
			target after and of sleep. That means, in case of UART, never, in case of SPI
			before the command that woke up the target is processed.

        FTM_WLAN_Philips_PCTI_TIMED_SLEEP = 0x1
		1 = Go to sleep and wake up after a defined time. The request is confirmed after
			wake-up or directly in case of an error.
	  \endcode
	\param iSleepTime_ms = sleep time in ms, when iMode = 1
	\param iReserved = reserved


	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_SLEEP_MODE
	(
		HANDLE hResourceContext,
		unsigned char* piStatusCode,
		unsigned char iMode,
		unsigned long iSleepTime_ms,
		unsigned char iReserved
	);


	/******************************************************************************/
	/**

	Philips WLAN command, LOOPBACK_MODE

		The LOOPBACK_MODE message enables a loopback behind the modem. Frames received
		from the air are completely decoded including error correction and sent back to the air with the
		same data rate after a programmable amount of time.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param 	iChannel = Channel to operate on
	\param  iIfs     = Time in s between end of the received frame and start of the transmission,
	                   Units are ms

	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_LOOPBACK_MODE
	(
		HANDLE hResourceContext,
		unsigned char* piStatusCode,
		unsigned char iChannel,
		unsigned long iIfs
	);

	/******************************************************************************/
	/**

	Philips WLAN command, DEBUG_LEVEL

		The DEBUG_LEVEL messages configures the amount of debug messages sent over the UART
		interface. This may help customers to provide detailed information in case of problems. The
		message carries a bitmask where different kinds of debug messages can be separately
		configured. The debug output is enabled if the associated bit is set to 1. Per default (at startup),
		debug outputs are disabled.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param 	iBitmask = Channel to operate on
	  \code
		 Bit 0 PCTI command handler verbose, show only PCTI command related prints
		 Bit 1 Global verbose, show all prints
		 Bitmask
		 Bit 2-15 Reserved (unused)
	  \endcode

	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_DEBUG_LEVEL
	(
		HANDLE hResourceContext,
		unsigned char* piStatusCode,
		unsigned char iBitmask
	);

	/******************************************************************************/
	/**

	Philips WLAN command, CHECK_EXT_32KHZ_CLOCK

		Returns the status of the 32kHz clock

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = return status code, defined by FTM_WLAN_Philips_enPctiStatus
	\param 	iStatus =
		\code
		   0 = External clock is not available / running
		   1 = External clock is available / running
		\endcode

	\param  piClockStatus, output,
		\code
		   0 = External clock is not available / running
		   1 = External clock is available / running
		\endcode


	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_CHECK_EXT_32KHZ_CLOCK
	(
		HANDLE hResourceContext,
		unsigned char* piStatusCode,
		unsigned char* piClockStatus
	);

	/******************************************************************************/
	/**

	Philips WLAN command to get the status value of the last QLIB_FTM_WLAN_Philips()
	function that was called. This is needed for QRCT because QRCT will not update
	the output status value in the case of a failure.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piStatusCode = returns the status code of the last Philips WLAN function,
	                      defined by FTM_WLAN_Philips_enPctiStatus

	\return true if successful, false if failure
	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Philips_GetLastStatus
	(
		HANDLE hResourceContext,
		unsigned char* piLastStatusCode
	);

	/*
	 Notes on testing WLAN commands (May 22, 2006)
		QLIB_FTM_WLAN_Philips_SLEEP_MODE
		-	mode=SLEEP_DOWN fails, the phone does not send a response packet.
		    This is probably because the module has gone to sleep and is not communicating with the ARM

		-	mode=SLEEP_TIMED, fails with Philips status code = 1


		QLIB_FTM_WLAN_Philips_LOOPBACK_MODE
		- Cannot be called after other Tx functions, like QLIB_FTM_WLAN_Philips_TX_CONTINUOUS

		QLIB_FTM_WLAN_Philips_RX_CONTINUOUS
		-	Cannot be called after other Tx functions, like QLIB_FTM_WLAN_Philips_TX_CONTINUOUS
		    and  QLIB_FTM_WLAN_Philips_LOOPBACK_MODE


		QLIB_FTM_WLAN_Philips_TX_BURST
		-	Problem with rate=0 (1_MBPS), reported status is value 1 instead of 0

		QLIB_FTM_WLAN_Philips_READ_STATISTICS_Partial
		-	Not sure if this function is working because it has not been tested with WLAN equipment

		QLIB_FTM_WLAN_Philips_SET_MODULE
		- Philips command does not return a status value, so the value reported by QMSL is forced to
		  FTM_WLAN_Philips_PCTI_FAILURE

	*/

	/*
		These Philips commands are not enabled with a specific C interface, but it is
		possible to call QLIB_FTM_WLAN_USER_CMD().

		DISCONNECT_DUT
		CONNECT_DUT
		GET_TEMPERATURE
		SET_CALIBRATIONINFO
		GET_CALIBRATIONINFO
		EEPROM_READ
		EEPROM_WRITE
		SET_TX_DATA
		MEMORY_READ
		MEMORY_WRITE
		SB_REGISTER_WRITE
		RF_REGISTER_READ
		RF_REGISTER_WRITE
		COEX_LINE_READ
		COEX_LINE_WRITE
	*/

	/******************************************************************************/
	/**

	Atheros WLAN command to enable/disable continuous transmit

	Note: Enable/disable continuous tx test cmd works only when target is awake.

	\param iMode =	0 = Disabling continuous Tx,
					1 = Enabling continuous unmodulated Tx
					2 = Enabling continuous modulated Tx

		   iFreq = Transmit Frequency in MHz
		           For example, 2412 for channel 1 in 802.11g

		   iDataRate =  0 - 1 Mbps
						1 - 2 Mbps
						2 - 5.5 Mbps
						3 - 11 Mbps
						4 - 6 Mbps
						5 - 9 Mbps
						6 - 12 Mbps
						7 - 18 Mbps
						8 - 24 Mbps
						9 - 36 Mbps
						10 - 48 Mbps
						11 - 54 Mbps

		  iTxPwr = Tx Power in dBm
					5 - 11 dBm for unmodulated Tx
					5 - 14 dBm for modulated Tx

	      iAntenna 1 = antenna one
		           2 = antenna two

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Atheros_CONT_TRANSMIT
	(
		HANDLE hResourceContext,
		unsigned long iMode,
		unsigned long iFreq,
		unsigned long iDataRate,
		unsigned long iTxPwr,
		unsigned long iAntenna
	);


	/******************************************************************************/
	/**

	Atheros WLAN command to enable continuous receive

	\param iAction =	0 = promiscuous mode (accept all incoming frames)
					1 = filter mode (accept only frames with dest address equal specified mac address

		   iFreq = Receive Frequency in MHz
		           For example, 2412 for channel 1 in 802.11g

	      iAntenna 1 = antenna one
		           2 = antenna two

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Atheros_CONT_RECEIVE
	(
			HANDLE hResourceContext,
			unsigned long iAction,
			unsigned long iFreq,
			unsigned long iAntenna
	);

	/******************************************************************************/
	/**

	Atheros WLAN command to get receive report

	\param iTotalPkt =	Total packet received

		   iRSSI = RSSI

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Atheros_RECEIVE_REPORT
	(
			HANDLE hResourceContext,
			unsigned long* iTotalPkt,
			unsigned long* iRSSI
	);
	/******************************************************************************/
	/**

	Atheros WLAN command to set MAC address

	\param iMAC_Address  =	MAC address

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Atheros_SET_MAC_ADDRESS
	(
			HANDLE hResourceContext,
			unsigned char aiMAC_Address[6]
	);

	/******************************************************************************/
	/**

	Atheros WLAN command to force SLEEP or AWAKE

	\param iMode  =	1 = Wake up target
					2 = Force the target to sleep

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Atheros_SLEEP_WAKE
	(
		HANDLE hResourceContext,
		unsigned char iMode
	);

	/******************************************************************************/
	/**

	Atheros WLAN FW V2 command to enable/disable continuous transmit

	Note: Enable/disable continuous tx test cmd works only when target is awake.

	\param iMode =	0 = Disabling continuous Tx,
					1 = Enabling continuous unmodulated Tx
					2 = Enabling continuous modulated Tx

		   iFreq = Transmit Frequency in MHz
		           For example, 2412 for channel 1 in 802.11g

		   iDataRate =  0 - 1 Mbps
						1 - 2 Mbps
						2 - 5.5 Mbps
						3 - 11 Mbps
						4 - 6 Mbps
						5 - 9 Mbps
						6 - 12 Mbps
						7 - 18 Mbps
						8 - 24 Mbps
						9 - 36 Mbps
						10 - 48 Mbps
						11 - 54 Mbps

		  iTxPwr = Tx Power in dBm
					5 - 11 dBm for unmodulated Tx
					5 - 14 dBm for modulated Tx

	      iAntenna 1 = antenna one
		           2 = antenna two

		  iEnANI = 0 = Anti-noise immunity (ANI) algorithm is disabled
				   1=  Anti-noise immunity (ANI) algorithm is enabled

		  iScramblerOff = 1 Scrambler is disabled
						= 0 Scrambler is enabled.  Scrambler is used with CCK frames

		   iAifsn = value from 0 to 252,

		   iPktSz = packet size, default is 1500.  Vary from 32 to 1500

		   iTxPattern = Applies to CONT_TX_TX99, CONT_TX_TX100, and CONT_TX_MODE

				ZEROES_PATTERN = 0,
				ONES_PATTERN,
				REPEATING_10,
				PN7_PATTERN,
				PN9_PATTERN,
				PN15_PATTERN



	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Atheros_V2_CONT_TRANSMIT
	(
		HANDLE hResourceContext,
		unsigned long iMode,
		unsigned long iFreq,
		unsigned long iDataRate,
		unsigned long iTxPwr,
		unsigned long iAntenna,
		unsigned long iEnANI,
		unsigned long iScramblerOff,
		unsigned long iAifsn,
		unsigned short  iPktSz,
		unsigned short  iTxPattern
	);


	/******************************************************************************/
	/**

	Atheros WLAN FW V2 command to enable continuous receive

	\param iAction =	0 = promiscuous mode (accept all incoming frames)
					1 = filter mode (accept only frames with dest address equal specified mac address

			iEnANI = 0 = Anti-noise immunity (ANI) algorithm is disabled
					 1=  Anti-noise immunity (ANI) algorithm is enabled

		   iFreq = Receive Frequency in MHz
		           For example, 2412 for channel 1 in 802.11g

	      iAntenna 1 = antenna one
		           2 = antenna two

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Atheros_V2_CONT_RECEIVE
	(
			HANDLE hResourceContext,
			unsigned long iAction,
			unsigned long iEnANI,
			unsigned long iFreq,
			unsigned long iAntenna
	);

	/******************************************************************************/
	/**

	Atheros WLAN FW V2 command to get receive report

	\param iTotalPkt =	Total packet received

		   iRSSI = RSSI

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Atheros_V2_RECEIVE_REPORT
	(
			HANDLE hResourceContext,
			unsigned long* iTotalPkt,
			unsigned long* iRSSI
	);

	/******************************************************************************/
	/**

	Atheros WLAN FW V3 command to get receive report

	\param iTotalPkt =	Total packet received

		   iRSSI = RSSI

		   iCRCErrPkt = CRC Error Pkt

		   iSECErrPkt = SEC Error Pkt

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Atheros_V3_RECEIVE_REPORT
	(
			HANDLE hResourceContext,
			unsigned long* iTotalPkt,
			unsigned long* iRSSI,
			unsigned long* iCRCErrPkt,
			unsigned long* iSECErrPkt
	);
	/******************************************************************************/
	/**

	Atheros WLAN FW V2 command to set MAC address

	\param iMAC_Address  =	MAC address

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Atheros_V2_SET_MAC_ADDRESS
	(
			HANDLE hResourceContext,
			unsigned char aiMAC_Address[6]
	);

	/******************************************************************************/
	/**

	Atheros WLAN FW V2 command to force SLEEP or AWAKE

	\param iMode  =	1 = Wake up target
					2 = Force the target to sleep

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_SetModuleType() must be called first to set the WLAN module type
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_Atheros_V2_SLEEP_WAKE
	(
		HANDLE hResourceContext,
		unsigned long iMode
	);

/**********************************************************************************
                                GEN6 WLAN Commands
***********************************************************************************/

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_START

	  Start Test Mode.

	\return true if successful, false if failure

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_START
	(
		HANDLE hResourceContext,
		int wlanID
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_STOP

	  Stop Test Mode.

	\return true if successful, false if failure

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_STOP
	(
		HANDLE hResourceContext
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_SET_CHANNEL

	  Set the channel.

	\param iChannel  =	Channel Index (1-14)

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_SET_CHANNEL
	(
		HANDLE hResourceContext,
		unsigned int iChannel
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_SET_CLOSED_LOOP_POWER

	  Set Tx closed loop power.

	\param dPowerIndBm  =	0 to 20 dBm

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_SET_CLOSED_LOOP_POWER
	(
		HANDLE hResourceContext,
		double dPowerIndBm
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_TX_PKT_START_STOP

	  Start/stop the Tx Packet generator.

	\param iStart  =	0: stop, 1: start

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_TX_PKT_START_STOP
	(
		HANDLE hResourceContext,
		unsigned char iStart
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_SET_RX_DISABLE_MODE

	  Enable/Disable the receiver capabilities.

	\param agPktsDisabled = true:disable A/G packets
	\param bPktsDisabled = true:disable B packets
	\param slrPktsDisabled = true:disable SLR packets

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_SET_RX_DISABLE_MODE
	(
		HANDLE hResourceContext,
		unsigned char agPktsDisabled,
		unsigned char bPktsDisabled,
		unsigned char slrPktsDisabled
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_SET_TX_FRAME

	  Configure the WLAN Tx.

	\param iNumTestFrame = number of test frames to transmit; 0 = infinite
	\param iPayloadSize = size of payload in bytes
	\param iFrameSpacing = spacing between frames in uSec
	\param iFCSCal = true:enable CRC calulations
	\param iRate = 			--- 802.11b Rates ---
							0: HAL_PHY_RATE_11B_LONG_1_MBPS
							1: HAL_PHY_RATE_11B_LONG_2_MBPS
							2: HAL_PHY_RATE_11B_LONG_5_5_MBPS
							3: HAL_PHY_RATE_11B_LONG_11_MBPS
							4: HAL_PHY_RATE_11B_SHORT_2_MBPS
							5: HAL_PHY_RATE_11B_SHORT_5_5_MBPS
							6: HAL_PHY_RATE_11B_SHORT_11_MBPS
							--- SLR Rates ---
							7: HAL_PHY_RATE_SLR_0_25_MBPS
							8: HAL_PHY_RATE_SLR_0_5_MBPS
							--- Spica_Virgo 11A 20MHz Rates ---
							9: HAL_PHY_RATE_11A_6_MBPS
							10: HAL_PHY_RATE_11A_9_MBPS
							11: HAL_PHY_RATE_11A_12_MBPS
							12: HAL_PHY_RATE_11A_18_MBPS
							13: HAL_PHY_RATE_11A_24_MBPS
							14: HAL_PHY_RATE_11A_36_MBPS
							15: HAL_PHY_RATE_11A_48_MBPS
							16: HAL_PHY_RATE_11A_54_MBPS
							--- MCS Index #0-15 (20MHz) ---
							17: HAL_PHY_RATE_MCS_1NSS_6_5_MBPS
							18: HAL_PHY_RATE_MCS_1NSS_13_MBPS
							19: HAL_PHY_RATE_MCS_1NSS_19_5_MBPS
							20: HAL_PHY_RATE_MCS_1NSS_26_MBPS
							21: HAL_PHY_RATE_MCS_1NSS_39_MBPS
							22: HAL_PHY_RATE_MCS_1NSS_52_MBPS
							23: HAL_PHY_RATE_MCS_1NSS_58_5_MBPS
							24: HAL_PHY_RATE_MCS_1NSS_65_MBPS
							25: HAL_PHY_RATE_MCS_1NSS_MM_SG_7_2_MBPS
							26: HAL_PHY_RATE_MCS_1NSS_MM_SG_14_4_MBPS
							27: HAL_PHY_RATE_MCS_1NSS_MM_SG_21_7_MBPS
							28: HAL_PHY_RATE_MCS_1NSS_MM_SG_28_9_MBPS
							29: HAL_PHY_RATE_MCS_1NSS_MM_SG_43_3_MBPS
							30: HAL_PHY_RATE_MCS_1NSS_MM_SG_57_8_MBPS
							31: HAL_PHY_RATE_MCS_1NSS_MM_SG_57_8_MBPS
							32: HAL_PHY_RATE_MCS_1NSS_MM_SG_65_MBPS
							33: HAL_PHY_RATE_MCS_1NSS_MM_SG_72_2_MBPS

	\param iRate = 			0: PHYDBG_PREAMBLE_OFDM
							1: PHYDBG_PREAMBLE_GREENFIELD
							2: PHYDBG_PREAMBLE_MIXED
							3: PHYDBG_PREAMBLE_SHORTB
							4: PHYDBG_PREAMBLE_LONGB

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_SET_TX_FRAME
	(
		HANDLE hResourceContext,
		unsigned long iNumTestFrame,
		unsigned short iPayloadSize,
		unsigned long iFrameSpacing,
		unsigned char iFCSCal,
		unsigned long iRate,
		unsigned long iPreamble
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_GET_RX_PACKET_COUNTS

	  Get the number of frames received since the statistics were last reset.

	\param rxFrameCounter = pointer to variable to hold frame count.
	\param totalMacRxPackets = pointer to variable to hold total mac frame count.
	\param totalMacFcsErrPackets = pointer to variable to hold bad checksum frame count.

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_GET_RX_PACKET_COUNTS
	(
		HANDLE hResourceContext,
		unsigned long* rxFrameCounter,
		unsigned long* totalMacRxPackets,
		unsigned long* totalMacFcsErrPackets
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_GET_RX_RSSI_VAL

	  Get the RSSI values for the receive chains.

	\param rssiVals = pointer to array to hold RSSI values.
	\param numRxChains = pointer to variable to hold number of Rx chains.

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_GET_RX_RSSI_VAL
	(
		HANDLE hResourceContext,
		short* rssiVals,
		unsigned short* numRxChains
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_GET_MAC_ADDR

	  Get the MAC address.

	\param macAddr = pointer to 6 byte array to hold the MAC address.

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_GET_MAC_ADDR
	(
		HANDLE hResourceContext,
		unsigned char *macAddr
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_SET_MAC_ADDR

	  Set the MAC address.

	\param macAddr = pointer to 6 byte array holding the desired MAC address.

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_SET_MAC_ADDR
	(
		HANDLE hResourceContext,
		unsigned char* macAddr
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_RESET_RX_PACKET_STATISTICS

	  Reset the received frame count.

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_RESET_RX_PACKET_STATISTICS
	(
		HANDLE hResourceContext
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_ENABLE_CHAINS

	  Enable Rx and/or Tx chains.

	\param iChain =			4: PHY_CHAIN_SEL_R0_ON
							5: PHY_CHAIN_SEL_R0R1_ON
							6: PHY_CHAIN_SEL_T0_ON
							7: PHY_CHAIN_SEL_T0_R1_ON
							8: PHY_CHAIN_SEL_R1_ON
							9: PHY_CHAIN_SEL_NO_RX_TX

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_ENABLE_CHAINS
	(
		HANDLE hResourceContext,
		unsigned int iChain
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_GRAB_RAM

	  Get samples from the 4096 sample IQ buffer.

	\param startSample = Starting sample index, 0 - 4094
	\param numSamples = Number of samples to retrieve
	\param Irx0 = Pointer to buffer to hold Rx0 I samples
	\param Qrx0 = Pointer to buffer to hold Rx0 Q samples
	\param Irx1 = Pointer to buffer to hold Rx1 I samples
	\param Qrx1 = Pointer to buffer to hold Rx1 Q samples

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_GRAB_RAM
	(
		HANDLE hResourceContext,
		unsigned long startSample,
		unsigned long numSamples,
		short *Irx0,
		short *Qrx0,
		short *Irx1,
		short *Qrx1
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_CLOSE_TPC_LOOP

	  Open or close the Tx Power Control Loop.

	\param close = 0: open 1: close

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_CLOSE_TPC_LOOP
	(
		HANDLE hResourceContext,
		unsigned char close
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_RX_DCO_CAL

	  Execute the Rx DC Offset calibration.

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_RX_DCO_CAL
	(
		HANDLE hResourceContext
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_DISABLE_AGC_TABLES

	  Disable/override the AGC

	\param rx0gain = Gain index (0-79) used to override the AGC
	\param rx1gain = Gain index (0-79) used to override the AGC

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_DISABLE_AGC_TABLES
	(
		HANDLE hResourceContext,
		unsigned char rx0gain,
		unsigned char rx1gain
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_STOP_WAVEFORM

	  Stop the Tx waveform generator.

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_STOP_WAVEFORM
	(
		HANDLE hResourceContext
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_START_WAVEFORM

	  Start the Tx waveform generator.

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_START_WAVEFORM
	(
		HANDLE hResourceContext
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_GEN_CW

	  Generate a CW waveform into the Tx waveform generator.

	\param tone = OFDM tone number (-52 to 52)
	\param ampl = IQ max amplitude (0 to 255)

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_GEN_CW
	(
		HANDLE hResourceContext,
		long tone,
		unsigned long ampl
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_SET_TX_WAVEFORM_GAIN

	  Sets the Tx gain of the waveform generator.

	\param gain = Set the waveform gain (31 to 255)

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_SET_TX_WAVEFORM_GAIN
	(
		HANDLE hResourceContext,
		unsigned char gain
	);


	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_GET_TX_POWER_REPORT

	  Gets the Tx power report that can be used to calibrate CLPC or confirm CLPC
	  operation.

	\param rate = Data rate index as defined in QLIB_FTM_WLAN_GEN6_SET_TX_FRAME()
	\param cbState = current Channel bonded state
	\param channelId = Current Channel Index
	\param pwrTemplateIndex = 5-bit template index used for the current rate
	\param gain = 8-bit coarse(bits 4-7) & fine(bits 0-3) gain for the current index
	\param adc = 8-bit power detector ADC sampled during the packet preamble
	\param indexMinMatchLut = minimum LUT matching power that satisfies the
	                          power template index setting (7-bit value)
	\param indexMinMatchAbs = minimum LUT matching power that satisfies the
	                          power template index setting in dBm
	\param indexMaxMatchLut = maximum LUT matching power that satisfies the
	                          power template index setting (7-bit value)
	\param indexMaxMatchAbs = maximum LUT matching power that satisfies the
	                          power template index setting in dBm
	\param outputLut = Output Power (7-bit value in the power Lookup Table)
	\param outputAbs = Ouput Power in dBm

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_GET_TX_POWER_REPORT
	(
		HANDLE hResourceContext,
		unsigned long *rate,
		unsigned long *cbState,
		unsigned char *channelId,
		unsigned long *pwrTemplateIndex,
		unsigned char *gain,
		unsigned char *adc,
		unsigned short *rawAdc,
		unsigned char *indexMinMatchLut,
		double *indexMinMatchAbs,
		unsigned char *indexMaxMatchLut,
		double *indexMaxMatchAbs,
		unsigned char *outputLut,
		double *outputAbs
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_QUERY_TX_STATUS

	  This function retrieves the number of frames generated in each mode.

	\param legacy = Legacy frame counter
	\param gfSimo20 = Green Field Singe Tx Frame counter
	\param gfMimo20 = Green Field Multi Tx Frame counter
	\param mmSimo20 = Mixed Mode Singe Tx Frame counter
	\param mmMimo20 = Mixed Mode Multi Tx Frame counter
	\param txbShort = Short Frame counter
	\param txbLong = Long Frame counter
	\param txbSlr = SLR Frame counter
	\param total = Total Frames counter
	\param txStatus = 0: counter values are invalid, 1: counter values are valid

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_QUERY_TX_STATUS
	(
		HANDLE hResourceContext,
		unsigned long *legacy,
		unsigned long *gfSimo20,
		unsigned long *gfMimo20,
		unsigned long *mmSimo20,
		unsigned long *mmMimo20,
		unsigned long *txbShort,
		unsigned long *txbLong,
		unsigned long *txbSlr,
		unsigned long *total,
		unsigned char *txStatus
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_HDET_CAL

	  This function calibrates HDET

	\param hdetDcocCode = DCOC Code
	\param hdetDcoOffset = DCO offset

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_HDET_CAL
	(
		HANDLE hResourceContext,
		unsigned short *hdetDcocCode, 
		unsigned short *hdetDcoOffset
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_SET_PKT_TX_GAIN_INDEX

	  This function sets the open loop packet gen Tx gain index

	\param index = Gain Index

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_SET_PKT_TX_GAIN_INDEX
	(
		HANDLE hResourceContext,
		unsigned char index 
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_FORCE_PKT_TX_GAIN

	  This function forces the tx packet gen open loop gain

	\param chainNum = Tx chain (0 based)
	\param gain = Gain Value

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_FORCE_PKT_TX_GAIN
	(
		HANDLE hResourceContext,
		unsigned char chainNum, 
		unsigned char gain
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_GET_TEMP_ADC

	  This function gets the tempurature ADC value

	\param sensorID = 0: PA, 1: RX temp sensor
	\param adcValue = ADC Value

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_GET_TEMP_ADC
	(
		HANDLE hResourceContext,
		int sensorID, 
		unsigned short *adcValue
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_GET_NV_TABLE

	  This function gets the contents of a WLAN NV table

	\param tableId = RATE_POWER_SETTINGS    = 2,
					 REGULATORY_DOMAINS     = 3,
					 DEFAULT_COUNTRY        = 4,
					 TPC_POWER_TABLE        = 5,
					 TPC_PDADC_OFFSETS      = 6,
					 RSSI_CHANNEL_OFFSETS   = 9,
	\param tableData = pointer to a buffer to hold the table data

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_GET_NV_TABLE(
		HANDLE hResourceContext, 
		int tableId, 
		void *tableData 
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_SET_NV_TABLE

	  This function sets the contents of a WLAN NV table

	\param tableId = RATE_POWER_SETTINGS    = 2,
					 REGULATORY_DOMAINS     = 3,
					 DEFAULT_COUNTRY        = 4,
					 TPC_POWER_TABLE        = 5,
					 TPC_PDADC_OFFSETS      = 6,
					 RSSI_CHANNEL_OFFSETS   = 9,
	\param tableData = pointer to a buffer containing the table data

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_SET_NV_TABLE(
		HANDLE hResourceContext, 
		int tableId, 
		void *tableData 
	);

	/******************************************************************************/
	/**

	GEN6 WLAN Commands:  QLIB_FTM_WLAN_GEN6_READ_REGISTER

	  This function sets the contents of a WLAN NV table

	\param regAddr = 32 bit register address
	\param regValue = pointer to a buffer to contain the register value

	\return true if successful, false if failure

	\warning QLIB_FTM_WLAN_GEN6_START() must be called first to start WLAN test mode
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_WLAN_GEN6_READ_REGISTER(
		HANDLE hResourceContext, 
		unsigned int regAddr, 
		unsigned int *regValue 
	);

/******************************************************************************
						QFUSE FTM
*******************************************************************************/

	/******************************************************************************/
	/**

	QFUSE Programming 2.1 FTM_FUSE_READ

	\param	iChainSelect =	0 = Configuraiton chain

			iWriteStatus =	0 = Success
							1 = Read operation Failure
							2 = Write operation Failure
							3 = Operation on selected chain not supported

			aConfigRegister = an array of 5 elements and size of each element is 4 bytes.

	\return true if successful, false if failure

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_QFUSE_READ
	(
		HANDLE hResourceContext,
		unsigned short iChainSelect,
		unsigned short* iReadStatus,
		unsigned long   aConfigRegister[5]
	);


	/******************************************************************************/
	/**

	QFUSE Programming 2.2 FTM_FUSE_WRITE

	\param	iChainSelect =	0 = Configuraiton chain

			iWriteStatus =	0 = Success
							1 = Read operation Failure
							2 = Write operation Failure
							3 = Operation on selected chain not supported

			aConfigRegister = an array of 5 elements and size of each element is 4 bytes.

	\return true if successful, false if failure

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_QFUSE_WRITE
	(
		HANDLE hResourceContext,
		unsigned short	iChainSelect,
		unsigned short* iWriteStatus,
		unsigned long   aConfigRegister[5]
	);

	/******************************************************************************/
	/**

	QFUSE Programming  FTM_FUSE_WRITE_V2

	\param	iChainSelect =	Chain select value

			iWriteStatus =	0  Success
							1  Read operation Failure
							2  Write operation Failure
							3  Operation on selected chain not supported


			iNumOfConfigRegister = number of register in aConfigRegister

			aConfigRegister = an array of configuration register

	\return true if successful, false if failure

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_QFUSE_WRITE_V2
	(
		HANDLE hResourceContext,
		unsigned short  iChainSelect,
		unsigned short* iWriteStatus,
		unsigned short  iNumOfConfigRegister,
		unsigned long*  aConfigRegister
	);

	/******************************************************************************/
	/**

	QFUSE Programming  FTM_FUSE_READ_V2

	\param	iChainSelect =	chain select value

			iReadStatus =	0  Success
							1  Read operation Failure
							2  Write operation Failure
							3  Operation on selected chain not supported


			iNumOfConfigRegister = number of register in aConfigRegister

			aConfigRegister = an array of configuration register

	\return true if successful, false if failure

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_QFUSE_READ_V2
	(
		HANDLE hResourceContext,
		unsigned short  iChainSelect,
		unsigned short* iReadStatus,
		unsigned short  iNumOfConfigRegister,
		unsigned long*  aConfigRegister
	);

	/******************************************************************************/
	/**

	QEPROM Programming  FTM_QEPROM_READ

	Read the raw and corrected value on a given row of QERPOM

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param	iRowAddress =	Row address

	\param	iLSBRaw		=   The raw value of least significant word (lower 32 bit value)

	\param	iMSBRaw		=   The raw value of most significant word (upper 32 bit value)

	\param	iLSBCorrected =   The corrected value of least significant word (lower 32 bit value)

	\param	iMSBCorrected =   The corrected  value of most significatn word (upper 32 bit value)

	\param	iReadStatus =	0  Success
							1  Read operation Failure

	\return true if successful, false if failure

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_QEPROM_READ
	(
		HANDLE hResourceContext,
		unsigned long iRowAddress,
		unsigned long* iLSBRaw,
		unsigned long* iMSBRaw,
		unsigned long* iLSBCorrected,
		unsigned long* iMSBCorrected,
		unsigned long* iReadStatus
	);


	/******************************************************************************/
	/**

	QEPROM Programming  FTM_QEPROM_WRITE

	Write the raw value on a given row of QEPROM

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param	iRowAddress =	Row address

	\param	iLSBRaw		=   The raw value of least significant word (lower 32 bit value)

	\param	iMSBRaw		=   The raw value of most significant word (upper 32 bit value)

	\param	iWriteStatus =	0  Success
							1  Write operation Failure

	\return true if successful, false if failure

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_QEPROM_WRITE
	(
		HANDLE hResourceContext,
		unsigned long iRowAddress,
		unsigned long iLSB,
		unsigned long iMSB,
		unsigned long* iWriteStatus
	);



/******************************************************************************
						EFS Functions
*******************************************************************************/


	/******************************************************************************/
	/**
	Initiates an EFS directory on a folder and calls a call-back function for each
	entry in the folder (both files and folders)

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sFolderPath = must be in the format "folder1/folder2" without a leading "/"
	\return none

	\warning If callback function is not supplied, data will not be returned to the calling program.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_EfsDirectory( HANDLE hResourceContext, char* sFolderPath );



	/******************************************************************************/
	/**

	Write file from computer to phone

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param sLocalFile	= absolute path of file on PC
		\param sEFS_File		= absolute path of file to write on phone,
		                          must be in the format "folder/file.ext" without a leading "/"

	\return true if successful, false if failure

	*******************************************************************************/
	QLIB_API unsigned char QLIB_EfsWrite( HANDLE hResourceContext, char *sLocalFile, char *sEFS_File );

	/******************************************************************************/
	/**

	Write file from computer to phone using a RAM buffer isntead of a file.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param sLocalMem	    = buffer pointer to file contenet keeping in memory on PC
		\param iSize		    = buffer size
		\param sEFS_File		= absolute path of file to write on phone,
		                          must be in the format "folder/file.ext" without a leading "/"

	\return true if successful, false if failure
	*******************************************************************************/
	QLIB_API unsigned char QLIB_EfsWriteMem( HANDLE hResourceContext, char *sLocalMem, unsigned long iSize, char *sEFS_File );


	/******************************************************************************/
	/**

	EFS2, 80-V1294-11, 3.40 EFS2_DIAG_GET

	This packet is used to retrieve an EFS2 special item file

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		
		\param sEFS_File        = absolute path of file on phone,
		                          must be in the format "/folder/file.ext" with a leading "/"
		\param sLocalFile       = absolute path of file to create on PC



	\return true if successful, false if failure

	*******************************************************************************/
	QLIB_API unsigned char QLIB_Efs2GetItem( HANDLE hResourceContext, char *sEFS_File, char *sLocalFile , int iEFSFileLength );

	/******************************************************************************/
	/**
	EFS2, 80-V1294-11, 3.40 EFS2_DIAG_PUT

	This packet is used to store a value in an EFS2 special item file. 
	Item files can hold a small 2 amount of data more efficiently than regular files.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		
		\param sLocalFile       = absolute path of file to from PC
		
		\param sEFS_File        = absolute path of file to create on phone
		
		\return true if successful, false if failure

	*******************************************************************************/
	QLIB_API unsigned char QLIB_Efs2PutItem( HANDLE hResourceContext, char *sLocalFile, char *sEFS_File );

	/******************************************************************************/
	/**

	Read file from phone

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param sEFS_File        = absolute path of file on phone,
		                          must be in the format "folder/file.ext" without a leading "/"
		\param sLocalFile       = absolute path of file to create on PC

	Comments:  creates attr file is the same file path as data but with .att appended

	\return true if successful, false if failure

	*******************************************************************************/
	QLIB_API unsigned char QLIB_EfsRead( HANDLE hResourceContext, char *sEFS_File, char *sLocalFile );

	/******************************************************************************/
	/**

	Set the size of the payload data to be used when requesting an EFS Read or Write.
	The higher this number, the fewer request/response packets will be needed to complete
	an EFS operation.

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iEFS_Read_Size = size of the payload of data used for the EFS read request packet.
		                        The size should be less than DIAG_MAX_PACKET_SIZE minus the packet
								response header for an EFS read. Default value is 524.

		\param iEFS_Write_Size = size of the payload of data used for the EFS write request packet.
		                        The size should be less than DIAG_MAX_PACKET_SIZE minus the packet
								request header for an EFS write.  Default is 536

	Comments:  creates attr file is the same file path as data but with .att appended

	\return true if successful, false if failure

	\warning The packet size has dependancies on the transport layer (QPST + Diagnostic handler in embedded software)
	         If the size is set to a point that is <DIAG_MAX_PACKET_SIZE, but the request is failing, then the problem
			 is most likely in one of these physical layer handlers and not in QMSL.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_SetEfsReadAndWritePacketSize(
							HANDLE hResourceContext,
							unsigned short iEFS_Read_Size,
							unsigned short iEFS_Write_Size );

	/******************************************************************************/
	/**

	Delete file from phone

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param sFileName  - absolute path of file on phone,
							must be in the format "folder/file.ext" without a leading "/"

	Comments:   Delete takes the phone offline, so you need to reset afterwards

	\return true if successful, false if failure


	\warning    This function is mapped into the diagnostic class, so that they will
	            be available when QPST is not used.  Given this, they will not return
				error information via the EFS interface--rather the error information
				will be returned via the diagnostic interface.


	*******************************************************************************/
	QLIB_API unsigned char QLIB_EfsDelete( HANDLE hResourceContext, char *sFileName );


	/******************************************************************************/
	/**

	Sets the permission bits on a file on the phone

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param sFileName =  Absolute path of file on phone
		\param oAttr  = Attributes to set the file to

	Return Value:
		true if successful, false if failure

	\return true if successful, false if failure

	\warning  This function is not currently implemented.  If called, an error will be returned.

	*******************************************************************************/
	//unsigned char QLIB_EfsSetPermissions( char *sFileName, EfsDirItem* oAttr ) ;
	// bn: Oct 8, 2004, Disabled for Oct 15 release because more information is needed about this operation


	/******************************************************************************/
	/**

	Create a folder in the EFS file system

	Parameter(s):

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param sEFS_Folder = absolute path of dir to create on phone.
						 So to make the dir "temp" off of the dir 'brew'
						 which is at root do "brew/temp" as the path
						 must be in the format "folder/folder2" without a leading "/"



	\return true if successful, false if failure

	*******************************************************************************/
	QLIB_API unsigned char QLIB_EfsMkDir( HANDLE hResourceContext, char *sEFS_Folder );


	/******************************************************************************/
	/**

	Remove directory from phone

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param sEFS_Folder      - absolute path of dir to create on phone.
						 So to remove the dir "temp" off of the dir 'brew'
						 which is at root, do "brew/temp" as the path
						 must be in the format "folder1/folder2" without a leading "/"

	\return true if successful, false if failure

	\warning    This function is mapped into the diagnostic class, so that they will
	            be available when QPST is not used.  Given this, they will not return
				error information via the EFS interface--rather the error information
				will be returned via the diagnostic interface.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_EfsRmDir( HANDLE hResourceContext, char *sEFS_Folder );

	/******************************************************************************/
	/**

	Remove a directory tree from the phone's EFS

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param sEFS_Folder      - absolute path of dir to create on phone.
						 So to remove the dir "temp" off of the dir 'brew'
						 which is at root, do "brew/temp" as the path
						 must be in the format "folder1/folder2" without a leading "/"

	\return true if successful, false if failure

	\warning    This function is mapped into the QPST diagnostic class, so it will
	            be availble only when QPST is used.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_EfsRmTree( HANDLE hResourceContext, char *sEFS_Folder );

	/******************************************************************************/
	/**
	EFS2, 3.16 EFS2_DIAG_RENAME request/response

	This is used to rename a file or directory. Note that duplicate requests to rename a directory will
	lead to an error code being returned the second time if the rename was successful the first time. If
	the duplicate request is due to a missing response packet, the tool needs to check the error code to
	make sure that the error is reasonable (ENOENT will be the error returned in this case).

	NOTE If a request is received to remove an already removed directory, nothing is done
	but an error is	not reported.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piErrorNo = Error code if error; otherwise, 0
	\param sOldFilePath = Old path name of file, for example "FactoryTest/Pictures/1.jpg"
						This is case sensitive.
						must be in the format "folder/file.ext" without a leading "/"

	\param sNewFilePath = New path name of file, for example "FactoryTest/Pictures/1.jpg"
						This is case sensitive.
						must be in the format "folder/file.ext" without a leading "/"

	\return True if successful, false if the command fails

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_EFS2_DIAG_RENAME(
		HANDLE hResourceContext, char* sOldFilePath, char* sNewFilePath, unsigned long* piErrorNo );

	/******************************************************************************/
	/**
	EFS2, 3.17 EFS2_DIAG_STAT request/response

	This is used to retrieve information about a named file or directory.

	\param sFilePath = File, for example "FactoryTest/Pictures/1.jpg"
						This is case sensitive.
						must be in the format "folder/file.ext" without a leading "/"

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piErrorNo = Error code if error; otherwise, 0
	\param piMode = File mode
	\param piSize = File Size
	\param piNlink = Number of links
	\param piAtime = Time of last access
	\param piMtime = Time of last modify
	\param piCtime = Time of last change
	\return True if successful, false if the command fails

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_EFS2_DIAG_STAT(
		HANDLE hResourceContext, char* sFilePath, unsigned long* piErrorNo, unsigned long* piMode, unsigned long* piSize,
		unsigned long* piNlink, unsigned long* piAtime, unsigned long* piMtime, unsigned long* piCtime );

	/******************************************************************************/
	/**
	EFS2, 3.20 EFS2_DIAG_CHMOD request/response

	This is used to change the access permissions of a file or directory.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piMode = New Mode
	\param sFilePath = File, for example "FactoryTest/Pictures/1.jpg"
						This is case sensitive.
						must be in the format "folder/file.ext" without a leading "/"
	\param piErrorNo = Error code if error; otherwise, 0

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_EFS2_DIAG_CHMOD(
		HANDLE hResourceContext, unsigned short iMode, char* sFilePath, unsigned long* piErrorNo);

	/******************************************************************************/
	/**
	EFS2, 3.21 EFS2_DIAG_STATFS request/response

	This is used to retrieve information about a file system. Note that the request packet must specify
	a path to a file or directory. Information is returned about the file system containing the named
	file or directory.


	\param iMode = New Mode
	\param sFilePath = File, for example "FactoryTest/Pictures/1.jpg"
						This is case sensitive.
						must be in the format "folder/file.ext" without a leading "/"

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piErrorNo = Error code if error; otherwise, 0
	\param piFS_ID = File system ID
	\param piFS_Type = File system type
	\param piBlockSize = File system block size
	\param piTotalBlocks = File system size in bytes
	\param piAvailBlocks = Blocks available in file system
	\param piFreeBlocks = Blocks free in file system
	\param piMaxFileSize = Maximum size of a file in this file system
	\param piNfiles = Current number of files in this file system
	\param piMaxNfiles = Maximum number of files in this file system

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_EFS2_DIAG_STATFS(
		HANDLE hResourceContext, char* sFilePath, unsigned long* piErrorNo, unsigned long* piFS_ID,
		unsigned long* piFS_Type, unsigned long* piBlockSize,
		unsigned long* piTotalBlocks, unsigned long* piAvailBlocks, unsigned long* piFreeBlocks, unsigned long* piMaxFileSize,
		unsigned long* piNfiles, unsigned long* piMaxNfiles);

	/******************************************************************************/
	/**
	EFS2, 3.22 EFS2_DIAG_ACCESS request/response

	Check a named file for accessibility. This is used to check access
	permissions for a file or directory.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iPermissionBits = Permissions bits
	\param sFilePath = File, for example "FactoryTest/Pictures/1.jpg"
						This is case sensitive.
						must be in the format "folder/file.ext" without a leading "/"

	\param piErrorNo = Error code if error; otherwise, 0

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_EFS2_DIAG_ACCESS( HANDLE hResourceContext, unsigned short iPermissionBits, char* sFilePath, unsigned long* piErrorNo);

	/******************************************************************************/
	/**
	EFS2, 3.23 EFS2_DIAG_DEV_INFO request/response

	This command is used to request the specifications of the flash device being used in the phone.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piErrorNo = Error code if error; otherwise, 0
	\param piTotalNumOfBlocks = Total number of blocks in the device
	\param piNumPagesPerBlock = Number of pages in a block
	\param piPageSize = Size of page data region in bytes
	\param piTotalPageSize = Size of total page_size
	\param piMakerId = Device maker ID
	\param piDeviceId = Device ID
	\param piDeviceType = 0 indicates NOR device, 1 indicates NAND
	\param sDeviceName = Beginning of the string containing name of the device (null terminated string)

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_EFS2_DIAG_DEV_INFO(
		HANDLE hResourceContext, unsigned long* piErrorNo, unsigned long* piTotalNumOfBlocks,
		unsigned long* piNumPagesPerBlock, unsigned long* piPageSize, unsigned long* piTotalPageSize,
		unsigned long* piMakerId, unsigned long* piDeviceId, unsigned char* piDeviceType, char* psDeviceName );

	/******************************************************************************/
	/**
	EFS2,   EFS2_DIAG_READLINK request/response

	this is used to retrieve path name pointed out by a link.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sPathName =	path name of link file, for example "VoiceDB/Lang/English/engdat1.dtw"
						this is case sensitive.
						must be in the format "folder/file.ext" without a leading "/"

	\param sPointedFilePath = received path pointed out by a link
	\return true if successful, false if the command fails

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_EfsReadLink( HANDLE hResourceContext, char *sEFS_Path, char *sEFS_Pointed_Path);

	/******************************************************************************/
	/**
	EFS2,   EFS2_DIAG_CREATE_LINK request/response

	this is used to create link

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sPathName =	path name of link file, for example "VoiceDB/Lang/English/engdat1.dtw"
						this is case sensitive.
						must be in the format "folder/file.ext" without a leading "/"

	\param sPointedFilePath = path pointed by a link
	\return true if successful, false if the command fails

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_EfsCreateLink( HANDLE hResourceContext, char *sEFS_Path, char *sEFS_Pointed_Path);

	/******************************************************************************/
	/**
	EFS2,   EFS2_DIAG_EXTENDED_INFO request/response

	this is used to request EFS information.  The user must supply a query type, and
	the function will perform the query and return either an integer or a string,
	depending upon the query type.


	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iQueryType = type of query to perform. Values are defined by EFS2_EXT_Kind_Enum in QLib_Defines.h

	\param piReturnDataType = output, data type (int or string) that is being returned.
	                          Values are defined by EFS2_EXT_Kind_Enum in QLib_Defines.h

	\param piReturnInt = output, holds integer return values

	\param sReturnString = output, holds string return values

	\return true if successful, false if the command fails

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_EFS2_DIAG_EXTENDED_INFO(
							HANDLE hResourceContext,
							unsigned long iQueryType,
							unsigned long* piReturnDataType,
							unsigned long* piReturnInt,
							char sReturnString[32]
							);

	/******************************************************************************/
	/**
	EFS2, 80-V1294-11 3.50 EFS2_DIAG_SYNC_NO_WAIT and EFS2_DIAG_SYNC_GET_STATUS request/response

	This command is used to synchronize the file system to the backing store, start the sync process,
	and return immediately, without blocking the caller. Upon return, a SYNC_TOKEN will be
	provided to the caller. The caller uses this SYNC_TOKEN to learn about the status of this sync
	operation, by calling the EFS2_DIAG_SYNC_GET_STATUS command

	Send EFS2_DIAG_SYNC_NO_WAIT command and return the status of by calling EFS2_DIAG_SYNC_GET_STATUS

	After EFS2_DIAG_SYNC_NO_WAIT is sent succesfully, QMSL will poll for sync status by calling EFS_DIAG_SYNC_GET_STATUS.
	The polling occurs every 100ms until "sync is complete" status is returned or timeout

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

    \param sFilePath = EFS file path to be synced

	\param iTimeOut_ms = Timeout value in ms for waiting for "sync is complete" message.

	\param piExecutionStuats = 0 = Command executed ok ("sync is complete" diag message is received)
							   1 = Command error occured ("ERRNO is not zero")
							   2 = Command can't be dispatched target ("0x18 is returned as when EFS2_DIAG_SYNC_NO_WAIT is sent")
							   3 = Timeout occurred ("sync is pendinng" diag response is last received when timeout)

	\return true if successful, false if the command fails

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_EFS2_SyncWithWait(
							HANDLE hResourceContext,
							unsigned char* sFilePath,
							unsigned long iTimeOut_ms,
							unsigned char* piExecutionStatus
							);

	/******************************************************************************/
	/**
	EFS2,  80-V1294-11 3.55 EFS2_DIAG_MAKE_GOLDEN_COPY request/response

	This packet requests the creation of a backup (golden copy) of the current state of the file system. 
	Creation of a backup for the file system is NOT supported for all storage devices (e.g. Flash). 
	DIAG can only be used to create a backup one time over the life of the device. If a power loss 
	occurs during backup creation, the backup will not be created and further attempts to create a 
	backup using DIAG will fail.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

    \param sFilePath = Path name (NULL-terminated string)

	\param pERRNO =  If successful, 0; otherwise, error code

	\return true if successful, false if the command fails

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_EFS2_DIAG_MAKE_GOLDEN_COPY(
							HANDLE hResourceContext,
							unsigned char *sFilePath,
							unsigned long* pERRNO);
	


	/******************************************************************************/
	/**

	Download a CEFS file from the phone to the PC

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param sLocalFile = absolute path of file to create on PC

	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_DownloadCEFS_File( HANDLE hResourceContext, char* sLocalFile );


	/******************************************************************************/
	/**

	Function:  DownloadPRL

	Description:  Copy PRL from phone to PC


	Parameter(s):
		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iNAM_Index = NAM index for the PRL
		\param sPRL_Path = path of PRL file

		\return true if successful, false if failure

		\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DownloadPRL( HANDLE hResourceContext, short iNAM_Index, char* sPRL_Path );

	/******************************************************************************/
	/**

	Function:  UploadPRL

	Description:  Copy PRL from PC to phone


	Parameter(s):
		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param iNAM_Index = NAM index for the PRL
		\param sPRL_Path = path of PRL file

		\return true if successful, false if failure

		\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_UploadPRL( HANDLE hResourceContext, short iNAM_Index, char* sPRL_Path );

	/******************************************************************************/
	/**
	Aborts the most recent EFS download operation.  Will only affect these functions:
		QLIB_EfsWrite()
		QLIB_EfsRead()

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer().



	\return none

	\warning Any current operations will be terminated.  This can cause problems with the
	         phone state.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_AbortEFS_Operation( HANDLE hResourceContext );

	/******************************************************************************/
	/**


	Get the error status and description of the last EFS operation.  The only operations
	that use this mechanism are:
		QLIB_DownloadPRL()
		QLIB_UploadPRL()
		QLIB_DownloadCEFS_File()
		QLIB_EfsRmTree()

		\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
		\param bErrorOccurred    = true if an error occurred during the last operation.  False if no error
								   occurred during the last operation.

		\param sErrorMessage     = Filled filled in with a text description of the most recent error.
								   Empty if no error has occurred.

		\param iMaxStringLength  = Maximum number of characters available in the sErrorMessage buffer

		\return true if successful, false if failure

		\warning  The error information will be cleared after this is called.

	*******************************************************************************/
	QLIB_API void QLIB_GetLastEfsErrorInfo
		( HANDLE hResourceContext, unsigned char* bErrorOccurred, char *sErrorMessage, int iMaxStringLength );


/******************************************************************************
						MediaFLO DIAG
*******************************************************************************/
	/******************************************************************************/
	/**
	This function returns the wid and lid statistics evaluated over the specified
	number of wid/lid packetes. This function calls the function that parses the wid/lid
	packets.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iNoLogPktsTimeout= time in seconds to wait for statistics to update, max of 5
							  seconds recommended
	\param iMinNumWIDLIDs   = Number of wid/lids
	\param _iWIC            = Expected Wide area Identification Channel
	\param _iLIC            = Expected Local area Identification Channel
	\param wid_lid_overall_stats = pointer of type wid_lid_overall_stats. Stores the overall
								   stats for wid/lid
	\param peErrorCode = an error code used whenever possible to provide more information
	                     about why the function failed.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GetWICLICPER(
									HANDLE hResourceContext,
									unsigned short _iNoLogPktsTimeout,
									unsigned long _iMinNumWIDLIDs,
									int _iWIC,
									int _iLIC,
									 void* wid_lid_overall_stats,
									 unsigned char* peErrorCode );

	/******************************************************************************/
	/**
	This function performs tasks necessary for starting the wid/lid 0x1210 log packets.
	This function resets the overall wid/lid statistics, clears the log queue, sets the
	0x1210 log mask, enables the OIS FTAP mode(recommended by system engineering), enables the
	wic/lic reception mode.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param wid_lid_overall_stats = pointer of type wid_lid_overall_stats. Stores the overall
								   stats for wid/lid
	\param peErrorCode = an error code used whenever possible to provide more information
	                     about why the function failed.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_StartWICLIC(
								HANDLE hResourceContext,
								void* wid_lid_overall_stats,
								unsigned char* peErrorCode);

	/******************************************************************************/
	/**
	This function performs tasks necessary for stopping the wid/lid 0x1210 log packets.
	This function resets the overall wid/lid statistics, clears the log queue, disables the
	0x1210 log mask, disables the OIS FTAP mode(recommended by system engineering),
	disables the wic/lic reception mode.


	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param wid_lid_overall_stats = pointer of type wid_lid_overall_stats. Stores the overall
								   stats for wid/lid
	\param peErrorCode = an error code used whenever possible to provide more information
	                     about why the function failed.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_StopWICLIC(
								HANDLE hResourceContext,
								void* wid_lid_overall_stats,
								unsigned char* peErrorCode);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.1 MFLO reset PLP statistics
	This command resets the PLP statistics for either one MLC or all MLCs.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param bResetAll = indicates which PLP statistics to reset
					   true resets PLP statistics for all MLCs,
					   false resets PLP statistics for the requested MLC
	\param iMlcId = the MLC ID for which to reset the PLP statistics,
					this parameter only applies if bResetAll is set to false
	\param eSystem = the system (mftypes_system_type),
					 this parameter only applies if bResetAll is set to false

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_RST_PLP_STATS(	HANDLE hResourceContext,
													unsigned char bResetAll,
													unsigned char iMlcId,
													unsigned char eSystem );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.2 MFLO get FLO state

	This command gets the current system state for the specified system.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param eSystem = the system (mftypes_system_type),
	\param peSystemState = the current system state (mftypes_state_type)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_FLO_STATE(	HANDLE hResourceContext,
													unsigned char eSystem,
													unsigned char* peSystemState );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.3 MFLO start FLO

	This command sends the request to acquire the system.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_START_FLO(	HANDLE hResourceContext );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.4 MFLO get FLO version

	This command gets the FLO HW and SW version information.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param piHWmajor = the HW Major Number
	\param piHWminor = the HW Minor Number
	\param piHWpatch = the HW Patch Number
	\param piSWmajor = the SW Major Number
	\param piSWminor = the SW Minor Number
	\param piSWpatch = the SW Patch Number
	\param piSWbuild = the SW Build Number

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_FLO_VERSION_INFO(	HANDLE hResourceContext,
															unsigned char* piHWmajor,
															unsigned char* piHWminor,
															unsigned char* piHWpatch,
															unsigned char* piSWmajor,
															unsigned char* piSWminor,
															unsigned char* piSWpatch,
															unsigned char* piSWbuild );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.5 MFLO activate flow

	This command activates the specified flow.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iFlowID = the Flow ID
	\param eBinding = the binding value (mftypes_binding_type)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_ACTIVATE_FLOW( HANDLE hResourceContext,
													unsigned long iFlowID,
													unsigned char eBinding );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.6 MFLO deactivate

	This command deactivates the specified flow.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iFlowID = the Flow ID

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_DEACTIVATE_FLOW( HANDLE hResourceContext, unsigned long iFlowID );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.7 MFLO get active flow

	This command gets the number of active flows in the system.
	Use QLIB_MFLO_GET_BOUND_FLOW_LIST to get more information about the active flows.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param piBoundFlowCount = the number of active flows

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_BOUND_FLOW_COUNT( HANDLE hResourceContext, unsigned char* piBoundFlowCount );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.7 MFLO get active flow

	This command gets information regarding all active flows in the system.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param piBoundFlowCount = This is both and input and output param.  As an input param
							  it indicates the number of elements in pActiveFlowInfoArray.
							  As an output param it indicates the actual number of active
							  flows in the system.
	\param pActiveFlowInfoArray = Array of mftypes_active_flow_info structures
									(mftypes_active_flow_info is defined in QLib_Defines.h)

	\return true if successful, false if fail.

	\warning Prior to calling this function, sufficient space should be allocated in
			 pActiveFlowInfoArray to	store information about all active flows in
			 the system.  The required amount of space can be determined by first calling
			 QLIB_MFLO_GetBoundFlowCount.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_BOUND_FLOW_LIST( HANDLE hResourceContext,
														  unsigned char* piBoundFlowCount,
														  void* pActiveFlowInfoArray);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.8 MFLO get MLC info

	This command gets information about the specified MLC ID.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iMlcID = the MLC ID
	\param eSystem = the system (mftypes_system_type)
	\param pActiveMlcInfo = information regarding the specified MLC (mftypes_active_mlc_info)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_MLC_INFO(	HANDLE hResourceContext,
													unsigned char iMlcID,
													unsigned char eSystem,
													void* pActiveMlcInfo );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.9 MFLO get RSSI value

	This command gets the current calculated RSSI (Received Signal Strength Indicator) value.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param pdRSSI = the RSSI value in dBm

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_RSSI_VALUE( HANDLE hResourceContext, double* pdRSSI );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.10 MFLO get MLC PLP

	This command gets accumulated PLP stats and accumulated CB stats before and after RS.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iMlcID = the MLC ID
	\param eSystem = the system (mftypes_system_type)
	\param pMlcPlpStats = structure of type mftypes_mlc_plp_stats_type to hold the PLP and CB statistics
									as defined in QLIB_Defines.h

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_MLC_PLP_STAT_DYN_PARAMS(	HANDLE hResourceContext,
																	unsigned char iMlcID,
																	unsigned char eSystem,
																	void* pMlcPlpStats );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.11 MFLO set channel

	This command sets the MediaFLO RF channel.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iChannel = the channel

	\return true if successful, false if fail.

	\warning Once the channel is changed, the MFLO_START_FLO command needs to be sent in order
			 to acquire the system on the new channel.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_SET_RF_CHNL( HANDLE hResourceContext, unsigned char iChannel );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.12 MFLO get channel

	This command gets the MediaFLO RF channel.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param piChannel = the channel

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_RF_CHNL( HANDLE hResourceContext, unsigned char *piChannel );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.13 MFLO reset MLC PLP

	This command resets the PLP and CB statistics associated with the specified MLC ID.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iMlcId = the MLC ID for which to reset the PLP and CB statistics
	\param eSystem = the system (mftypes_system_type),

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_RST_MLC_PLP_STATS(	HANDLE hResourceContext,
													    unsigned char iMlcId,
													    unsigned char eSystem );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.14 MFLO MLC dynamic

	This command gets the MLC Dynamic information associated with the specified MLC ID.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iMlcID = the MLC ID
	\param eSystem = the system (mftypes_system_type)
	\param pMLC_Dyn_Params = structure to store the info associated with the MLC ID
							 (mftypes_mlc_dyn_params_type)

	\return true if successful, false if fail.

	\warning The response to this command is only valid if the specified MLC ID is
			 currently active.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_MLC_DYN_PARAMS(	HANDLE hResourceContext,
															unsigned char iMlcID,
															unsigned char eSystem,
															void* pMLC_Dyn_Params);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.15 MFLO get OIS PLPs

	This command gets the OIS PLP statistics associated with the specified OIS type.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param eOIStype = the OIS type, wide area or local area (mftypes_system_type)
	\param piLastNumGoodPLPs = number of good PLPs from last decoding
	\param piLastNumErasures = number of erasures from last decoding
	\param piTotalNumGoodPLPs = cummulative number of good PLPs including from last decoding
	\param piTotalNumErasures = cummulative number of erasures including from last decoding

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_OIS_PLP_STAT(	HANDLE hResourceContext,
														unsigned char eOIStype,
														unsigned long* piLastNumGoodPLPs,
														unsigned long* piLastNumErasures,
														unsigned long* piTotalNumGoodPLPs,
														unsigned long* piTotalNumErasures );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.16 MFLO reset OIS PLPs statistics

	This command resets the OIS PLP statistics associated with the specified OIS type.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param eOIStype = the OIS type, wide area or local area (mftypes_system_type)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_RST_OIS_PLP_STAT( HANDLE hResourceContext, unsigned char eOIStype );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.17 MFLO GET FLO SUBSTATE

	This command gets the protocol task's substate.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param eSystem = the system (mftypes_system_type)
	\param peSubstate = the protocol task's substate (mftypes_substate)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_FLO_SUBSTATE(	HANDLE hResourceContext,
														unsigned char eSystem,
														unsigned char* peSubstate );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.18 MFLO GET ACTIVE MLC LIST

	This command gets the number of active MLCs on both of the systems, WOIS and LOIS.
	Use QLIB_MFLO_GET_ACTIVE_MLC_LIST to get more information about the active MLCs.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param piActiveMlcCount = the number of active MLCs

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_ACTIVE_MLC_COUNT( HANDLE hResourceContext, unsigned char* piActiveMlcCount );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.18 MFLO GET ACTIVE MLC LIST

	This command gets information regarding all active MLCs on both of the systems.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param piActiveMlcCount = This is both and input and output param.  As an input param
							  it indicates the number of elements in pActiveMlcInfoArray.
							  As an output param it indicates the actual number of active
							  MLCs on both systems.
	\param pActiveMlcInfoArray = Array of mftypes_active_mlc_info structures
								 (mftypes_active_mlc_info is defined in QLib_Defines.h)

	\return true if successful, false if fail.

	\warning Prior to calling this function, sufficient space should be allocated in
			 pActiveMlcInfoArray to	store information about all active MLCs on both
			 systems.  The required amount of space can be determined by first calling
			 QLIB_MFLO_GetActiveMlcCount.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_ACTIVE_MLC_LIST( HANDLE hResourceContext,
														  unsigned char* piActiveMlcCount,
														  void* pActiveMlcInfoArray);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.19 MFLOG GET FLO PLP DYN

	This command gets the PLP statistics for a specific Flow ID.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iFlowID = the Flow ID
	\param piTotalNumGoodPlps = the total number of good PLPs
	\param piTotalNumErasures = the total number of erasures
	\param piSFNumGoodPlps = the number of good PLPs in the last superframe
	\param piSFNumErasures = the number of erasures in the last superframe

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_FLO_PLP_DYN_PARAMS( HANDLE hResourceContext,
															 unsigned long iFlowID,
														     unsigned short* piTotalNumGoodPlps,
														     unsigned short* piTotalNumErasures,
															 unsigned short* piSFNumGoodPlps,
														     unsigned short* piSFErasures);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.20 MFLO ENABLE FTAP PLP DATA

	This command enables logging of FTAP PLP parameters.  This is the first diag
	command that needs to be issued when logging FTAP PLP packet parameters.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param bEnable = true enables logging, false disables logging

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_ENABLE_FTAP_PLP_DATA( HANDLE hResourceContext, unsigned char bEnable );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.21 MFLO ENABLE FTAP OIS RECEPTION MODE

	This command places the FDS in a test mode called "FTAP OIS Reception Mode".
	In this mode, the device decodes WOIS Only, LOIS Only or both WOIS and LOIS
	every superframe.  Once in this mode, the FDS starts logging WOIS/LOIS log
	codes (0x120E and 0x120F) once every superframe.  This command can also be used
	to disable "FTAP OIS Reception Mode".

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param eOIS_ReceptionMode = the FTAP OIS reception mode (mftypes_ois_reception_mode_type)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_ENABLE_FTAP_OIS( HANDLE hResourceContext, unsigned char eOIS_ReceptionMode );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic ICD, 2.3.22 MFLO ENABLE FTAP WICLIC RECEPTION MODE

	This command places the FDS in a test mode called "FTAP WIC/LIC Reception Mode".
	In this mode, the device decodes WIC/LIC every superframe.  Once in this mode,
	the FDS starts logging the WIC/LIC log code (0x1210) once every superframe.
	This command can also be used to disable "FTAP WIC/LIC Reception Mode".

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param bEnable = true places FDS in FTAP WIC/LIC Reception Mode,
					 false disables WIC/LIC decode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_ENABLE_WIC_LIC( HANDLE hResourceContext, unsigned char bEnable );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, MFLO GET PLATFORM CONFIG

	This command retrieves the platform configuration information.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param pihwPlatform = The FLO HW type configured in AMSS
	\param pihwVersion = The FLO HW version detected at power up
	\param piMBPBusMode = MBP Bus Mode detected by AMSS
		Defined by mftypes_mbp_bus_mode:
		\code
		MFLO_MBP_BUS_MODE_EBI2     = 0,
		MFLO_MBP_BUS_MODE_EBI2_MUX = 1,
		MFLO_MBP_BUS_MODE_SDIO     = 2
		\endcode
	\param pbMBPDetected = 0 - MBP not detected at power up, 1 - MBP detected at power up
	\param piReserved = reserved

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_PLATFORM_CONFIG( HANDLE hResourceContext,
														  unsigned char* pihwPlatform,
														  unsigned char* pihwVersion,
														  unsigned char* piMBPBusMode,
														  unsigned char* pbMBPDetected,
														  unsigned long* piReserved);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, MFLO GET C/I Average

	This command retrieves the C/I Average.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param piCIAverage = The C/I Average

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_CI_AVG( HANDLE hResourceContext,
												 unsigned short* piCIAverage);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, MFLO FTM SET DEMOD CONFIG

	This command sets the demodulation configuration.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iFftSize = FFT Size
		Defined by ftm_mflo_fft_size:
		\code
		FTM_MFLO_2K_FFT = 0,
		FTM_MFLO_4K_FFT = 1,
		FTM_MFLO_8K_FFT = 2
		\endcode
	\param iCpLength = CP Length
		Defined by ftm_mflo_cp_length:
		\code
		FTM_MFLO_1_16_CP_LENGTH = 0,
		FTM_MFLO_1_8_CP_LENGTH = 1,
		FTM_MFLO_3_16_CP_LENGTH = 2,
		FTM_MFLO_1_4_CP_LENGTH = 3
		\endcode
	\param iPpc = 0 - No PPC Symbols
	\param iPilotPattern = 0 - (2,6), 1 - (0,3,6)
	\param iReserved = Reserved - must be set to 1
	\param iIcMode = IC Mode
		Defined by ftm_mflo_ic_mode:
		\code
		FTM_MFLO_IC_DISABLED = 0,
		FTM_MFLO_IC_BYPASSED = 1,
		FTM_MFLO_IC_DYNAMIC = 3
		\endcode
	\param iDmttMode = DMTT Mode
		Defined by ftm_mflo_dmtt_mode
		\code
		FTM_MFLO_DMTT_W_TDM2_RDSP_NOT_USED = 2,
		FTM_MFLO_DMTT_W_TDM2_RDSP_USED = 3,
		FTM_MFLO_DMTT_TPC_BASED = 4
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_SET_DEMOD_CONFIG( HANDLE hResourceContext,
															unsigned char eFftSize,
															unsigned char eCpLength,
															unsigned char iPpc,
															unsigned char iPilotPattern,
															unsigned char iReserved,
															unsigned char eIcMode,
															unsigned char eDmttMode );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, RF Initialise

			Initialises the RF Mode, Bandwidth and Frequency

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRfMode = The RF mode to initialise.
	Defined by ftm_mflo_rf_mode in QLib_Defines.h:
		\code
		FTM_MFLO_US		= 0,
		FTM_MFLO_VHF	= 1,
		FTM_MFLO_UHF	= 2,
		FTM_MFLO_L_BAND = 3
		\endcode
	\param iFreqKhz = The RF frequency to initialise in KHz
	\param iBandwidth = The RF bandwidth to use.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_RF_INITIALIZE(HANDLE hResourceContext,
													   unsigned char iRfMode,
													   unsigned long iFreqKhz,
													   unsigned char iBandwidth);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, Get PLL Lock Status

			This function returns the lock state of the RF synthesizer PLL.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param pbLockState = the lock state of the RF synthesizer PLL (0=unlocked, 1=locked)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_GET_PLL_LOCK_STATUS(HANDLE hResourceContext,
															 unsigned short* pbLockState);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, Tune RF In Hz

		This function tunes the PLL to the requested frequency.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param ifreqHz = Required frequency in Hz.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_TUNE_RF_IN_HZ(HANDLE hResourceContext,
													   unsigned long iFreq );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, Get Rx RSSI

			This function returns a 16-bit signed receiver signal strength indicator (RSSI) value.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piIsValid = Returns whether the RSSI value is valid (1) or not (0).
	\param piRssiValue = RSSI value in 1/100 dB

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_GET_RSSI(HANDLE hResourceContext,
												  unsigned char *piIsValid,
												  short *piRssiValue );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, Get AGC State

			This function returns the current gain state and 15-bit signed DVGA accumulator value.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piDvga = current DVGA accumulator value, 15-bit signed value
	\param piGainState = current gain state (0 = highest gain state, 6 = lowest gain state)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_GET_AGC_STATE(HANDLE hResourceContext,
													   short*piDvga,
													   unsigned char*piGainState);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, Get RSSI Cal Point

			This function returns a 16-bit signed RSSI cal point for the requested gain state.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iGainState = the gain state (0 = highest gain, 6 = lowest gain)
	\param iInputPower = the receiver input power, 1 dB resolution
	\param iNumberOfSamples = the number of times to sample the cal point
	\param piCalPoint = the RSSI cal point for the requested gain state, 1/256 dB

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_GET_RSSI_CAL_POINT(HANDLE hResourceContext,
															unsigned char iGainState,
															short iInputPower,
															unsigned short iNumberOfSamples,
															short* piCalPoint);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, Load RSSI Cal Point

			Loads a RSSI Calibration point in to phone memory

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iFreq = The desired frequency in MHz
	\param iGainState = the phone gain state
	\param iCalPoint = the calibration point (dB/256)
	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_LOAD_RSSI_CAL_POINT(HANDLE hResourceContext,
															 unsigned short iFreq,
															 unsigned char iGainState,
															 short iCalPoint);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, Load AGC Cal Channel List

			Loads the AGC Calibration channel list to the phone memory.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iChannelsFreqs = List of up to 32 frequencies in MHz to load to the phone
	\param iNumberOfChannelsFreqs = The number of channels/frequencies to load.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_LOAD_AGC_CAL_CHAN_LIST( HANDLE hResourceContext,
																 unsigned short *iChannelsFreqs,
																 unsigned short iNumberOfChannelsFreqs);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, Write Cal Data to NV

			This function stores the current state of the RF Calibration to NV.

	\param hResourceContext =	Resource context that was returned from the call to QLIB_ConnectServer()
	\param iitemCode=			either 0, for the channel list, or 1 for the RSSI calibration point
	\param iGainState=			when writing the calibration point, this specifes the coresponding gains state.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_WRITE_CAL_DATA_TO_NV(HANDLE hResourceContext,
															  unsigned long iItemCode,
															  unsigned long iGainState);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, Set Gain State

			This function sets the gain state of the currently selected LNA.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iGainState = the desired gain state (0=highest gain state, 6=lowest gain state)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_SET_GAIN_STATE(HANDLE hResourceContext,
														unsigned char iGainState);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, Set AGC Default

			Restores the AGC to the default state.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_SET_AGC_DEFAULT(HANDLE hResourceContext);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, Set AGC Gain Tracking

		This command enables/disables the AGC Gain Tracking.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iState = 0 - Disable, 1 - Enable

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_SET_AGC_GAIN_TRACKING( HANDLE hResourceContext,
																unsigned char iState);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, Select LNA.

			This command allows the LNA selection to be modified
			independent of the MFLO_FTM_MF_RF_INITIALIZE command.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRfMode = The RF mode to initialise.
	Defined by ftm_mflo_rf_mode in QLib_Defines.h:
		\code
		FTM_MFLO_US		= 0,
		FTM_MFLO_VHF	= 1,
		FTM_MFLO_UHF	= 2,
		FTM_MFLO_L_BAND = 3
		\endcode
	\param iLNASelect = LNA value to select.
	Defined by ftm_mflo_rf_lna_type in QLib_Defines.h:
		\code
		MFLO_F_LBAND	= 1,	( MBP2700 LBAND )
		MFLO_F_LNA1		= 2,	( MBP2700 LNA1 )
		MFLO_F_LNA2		= 3,	( MBP2700 LNA2 )
		\endcode
	\param iReserved1 = Set to zero.
	\param iReserved2 = Set to zero.

	\return true if successful, false if fail.

	\warning MBP2700 only

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_LNA_SELECT(HANDLE hResourceContext,
													unsigned char iRfMode,
													unsigned char iLNASelect,
													unsigned long iReserved1,
													unsigned long iReserved2);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, Set Antenna tune switch.

			This command allows the antenna tune selection to be modified independent
			of the MFLO_FTM_RF_INITIALIZE command

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRfMode = The RF mode to initialise.
	Defined by ftm_mflo_rf_mode in QLib_Defines.h:
		\code
		FTM_MFLO_US		= 0,
		FTM_MFLO_VHF	= 1,
		FTM_MFLO_UHF	= 2,
		FTM_MFLO_L_BAND = 3
		\endcode
	\param iAntTuneMask = The mask to apply to the Tune Settings.
	\param iAntTuneSettings = The Antenna Tune Settings (only bits with a corresponding 1 in the Tune Mask will actually be set)
	\param iReserved1 = Set to zero.
	\param iReserved2 = Set to zero.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_SET_ANT_TUNE(HANDLE hResourceContext,
													  unsigned char iRfMode,
													  unsigned char iAntTuneMask,
													  unsigned char iAntTuneSettings,
													  unsigned long iReserved1,
													  unsigned long iReserved2);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Non-Signalling, Enable FLO Demod

			This function enables FLO demodulation during FTM mode.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_SET_NS_MODE(HANDLE hResourceContext);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Non-Signalling, Acquire FLO System

			This function forces FLO to perform a FLO system acquisition.
			An attempt will be made to acquire both the WIDE and LOCAL systems.
			Acquisition may require several seconds.
			The QLIB_MFLO_FTM_NS_GET_OIS_STATE command can be used to determine if a system has been acquired.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iReserved = Set to 0.
	\param bReserved1 = Not used
	\param bReserved2 = Not used

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_ACQUIRE_FLO_SYSTEM( HANDLE hResourceContext,
																unsigned short iReserved,
																unsigned char *pbReserved1,
																unsigned char *pbReserved2 );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Non-Signalling, Activate Flow

			This function activates the Flow specified by the caller.
			Activation may require several seconds. The request message contains
			an additional field that instructs FTM to wait (in msec) before returning
			the activation response message.  If the wait time is 0 the response will
			be sent immediately and the ACTIVATION_STATUS in the response will be set
			to ACTIVATING_FLOW.  In addition the stream information returned in the
			response will be invalid (set to 0). The FTM_MFLO_NS_GET_STREAM_INFO command
			can be used to determine if the Flow was successfully activated. If a wait
			time is specified the ACTIVATION_STATUS in the response will be set to either
			ACTIVATION_FAILED or ACTIVATION_SUCCESS depending upon the stream state at the
			wait time expiration.
			Non-signaling mode in FTM supports a maximum of 20 simultaneously active Flows.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iReserved = Set to zero.
	\param iFlowId = specfies the flow to activate.
	\param eBinding = specifies the binding type.
		Defined by mftypes_binding_type:
		\code
		MFLO_OVERHEAD   = 0x00,
		RT_VIDEO_CODEC  = 0x01,
		RT_AUDIO_CODEC  = 0x02,
		NRT_MEDIA       = 0x03,
		DATACAST        = 0x04,
		TAP             = 0x05,
		FIXED_TAP       = 0x06,
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_ACTIVATE_FLOW( HANDLE hResourceContext,
														   unsigned short iReserved,
														   unsigned long iFlowId,
														   unsigned char iBindingType);

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Non-Signalling, Deactivate Flow

			This function deactivates the Flow specified by the caller.
			If the Flow Id in the request message is not active FLOW_NOT_ACTIVATED is returned
			in the response, otherwise FLOW_DEACTIVATING is returned.
			The MFLO_FTM_NS_GET_STREAM_INFO command can be used to determine if the Flow
			was successfully deactivated.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iFlowId = specifies the Flow ID or use 0xFFFFFFFF for all active Flow IDs

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_DEACTIVATE_FLOW( HANDLE hResourceContext,
															 unsigned long iFlowId );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Non-Signalling, Tune Freq and BW.

	This command tunes the RF to the specified frequency and bandwidth.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iFreqKhz = Frequency in Hz.
	\param iBandwidthMHz = Bandwidth in MHz.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_TUNE_FREQ_AND_BW( HANDLE hResourceContext,
															  unsigned long iFreq,
															  unsigned char iBandwidthMHz );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Non-Signalling, Get RSSI and Gain State.

	This command retrieves the RSSI and Gain State. This value is not valid when the FLO is not actively decoding.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iGainState = the current gain state
	\param iRssi = Signed RSSI value in 1/100th dB resolution.
	\param bRssiValid = specifies validity of the RSSI measurement

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_GET_RSSI_AND_GAIN_STATE( HANDLE hResourceContext,
																	 unsigned char *piGainState,
																	 short *piRssi,
																	 unsigned char *pbRssiValid );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Non-Signalling, Get Stream Info

			This function command retrieves the stream information for the specified
			Flow ID.  If the Flow Id specified in the request message is not active
			FLOW_NOT_ACTIVATED is returned in the response message, otherwise
			FLOW_ACTIVATED is returned.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iFlowId = specifies the Flow ID.
	\param eStatus = specifies deactivate flow status.
	Defined by mftypes_flow_status_type:
		\code
		FLOW_NOT_ACTIVATED		= 0x00,
		FLOW_ACTIVATED			= 0x01
		\endcode
	\param iMlcID = specifies the MLC ID.
	\param iStreamID = specifies the Stream ID.
	\param bStreamUsesBothLayers = true(1) if enhanced layer data is present.
	\param bReserved = Reserved.
	\param peBindingType = specifies the binding type.
		Defined by mftypes_binding_type:
		\code
		MFLO_OVERHEAD   = 0x00,
		RT_VIDEO_CODEC  = 0x01,
		RT_AUDIO_CODEC  = 0x02,
		NRT_MEDIA       = 0x03,
		DATACAST        = 0x04,
		TAP             = 0x05,
		FIXED_TAP       = 0x06,
		\endcode
	\param eSystem = specifies the system.
		Defined by mftypes_system_type:
		\code
		WIDE			= 0x00,		//! Wide System
		LOCAL			= 0x01,		//! Local System
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_GET_STREAM_INFO( HANDLE hResourceContext,
															 unsigned long iFlowId,
															 unsigned char *piStatus,
															 unsigned char *piMlcID,
															 unsigned char *piStreamID,
															 unsigned char *pbStreamUsesBothLayers,
															 unsigned char *pbReserved,
															 unsigned char *piBindingType,
															 unsigned char *piSystem );

	/******************************************************************************/
	/**

	MediaFLO Diagnostic Non-Signalling - Get MLC Dynamic Parameters.

		This command retrieves the dynamic parameters for the specified MLC ID. The information
		returned can be used to calculate PER statistics. If the MLC is not active 0 is returned
		in the first byte of the response message, otherwise 1 is returned.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iMlcID = specifies the MLC ID. This is both an input and output param.
	\param eSystem = specifies the system
		Defined by mftypes_system_type:
		\code
		WIDE			= 0x00,		//! Wide System
		LOCAL			= 0x01,		//! Local System
		\endcode
	\param piFFTAddress = MLC Base FFT Address
	\param peTransmitMode = Transmit Mode
		Defined by mftypes_trans_mode_type:
		\code
		REG_QPSK_1_3         = 0,
		MREG_QPSK_1_2        = 1,
		REG_16_QAM_1_3       = 2,
		REG_16_QAM_1_2       = 3,
		REG_16_QAM_2_3       = 4,
		REG_16_QPSK_1_5      = 5,
		LAY_QPSK_1_3_ER_4    = 6,
		LAY_QPSK_1_2_ER_4    = 7,
		LAY_QPSK_2_3_ER_4    = 8,
		LAY_QPSK_1_3_ER_6_25 = 9,
		LAY_QPSK_1_2_ER_6_25 = 10,
		LAY_QPSK_2_3_ER_6_25 = 11
		\endcode
	\param peRSOuterCode = RS Outer Code
		Defined by mftypes_reed_solomon_code_type:
		\code
		RS_16_16_0		= 0x0,
		RS_16_14_2		= 0x1,
		RS_16_12_4		= 0x2,
		RS_16_8_8		= 0x3
		\endcode
	\param piCodeBlocks = Code Blocks in current Superframe
	\param pbStream1Bound = true(1) if Stream 1 is bound
	\param pbStream2Bound = true(1) if Stream 2 is bound
	\param iStream0Length = Stream 0 length
	\param iStream1Length = Stream 1 length
	\param iStream2Length = Stream 2 length
	\param pBasePlpStats = structure of type mftypes_plp_stats_type to hold the Base PLP statistics
									as defined in QLIB_Defines.h
	\param pEnhPlpStats = structure of type mftypes_plp_stats_type to hold the Enhanced PLP statistics
									as defined in QLIB_Defines.h
	\param pBaseCbStats = structure of type mftypes_cb_stats_type to hold the Base CB statistics
									as defined in QLIB_Defines.h
	\param pEnhCbStats = structure of type mftypes_cb_stats_type to hold the Enhanced CB statistics
									as defined in QLIB_Defines.h

	\return true if successful, false if fail.

	\warning Prior to calling this function, sufficient space should be allocated in
			 pMlcPlpStats to store structure of type mftypes_mlc_plp_stats_type

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_MFLO_NS_GET_MLC_DYN_PARAMS( HANDLE hResourceContext,
																unsigned char iMlcID,
																unsigned char iSystem,
																unsigned char *piStatus,
																unsigned long *piFFTAddress,
																unsigned char *piTransmitMode,
																unsigned char *piRSOuterCode,
																unsigned char *piCodeBlocks,
																unsigned char *pbStream1Bound,
																unsigned char *pbStream2Bound,
																unsigned short *piStream0Length,
																unsigned short *piStream1Length,
																unsigned short *piStream2Length,
																void *pBasePlpStats,
																void *pEnhPlpStats,
																void *pBaseCbStats,
																void *pEnhCbStats );

	/******************************************************************************/
	/**

	MediaFLO Diagnostic Non-Signalling, Reset MLC PLP Stats.

		This command clears (resets to 0) the accumulated PLP/CB statistics for the specified MLC ID.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iMlcID = specifies the MLC ID
	\param eSystem = specifies the system
		Defined by mftypes_system_type:
		\code
		WIDE			= 0x00,		//! Wide System
		LOCAL			= 0x01,		//! Local System
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_RESET_MLC_PLP_STATS( HANDLE hResourceContext,
																 unsigned char iMlcID,
																 unsigned char iSystem );

	/******************************************************************************/
	/**

	MediaFLO Diagnostic Non-Signalling, Reset ALL PLP Stats.

		This command clears (resets to 0) the accumulated PLP/CB statistics for all of the active MLCs.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_RESET_ALL_PLP_STATS( HANDLE hResourceContext );

	/******************************************************************************/
	/**

	MediaFLO Diagnostic Non-Signalling, Get the number of Active Flows.

		This command returns the number of currently active Flows. FTM Non-signaling mode
		supports a maximum of 20 simultaneously active Flows.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()

	\param piFlowCount = the number of active flows

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_GET_ACTIVE_FLOW_COUNT( HANDLE hResourceContext,
																   unsigned char *piFlowCount );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Non-Signalling, Get all active flow Ids.

		This command returns a list of all of the currently active flows.
		The total number of active flows is also returned. The list of active flow IDs
		returned is formatted as a 20 entry by uint32 (4 byte) array (80 total bytes)
		Each array entry corresponds to an active Flow ID. If there are less than 20 active
		Flows (FTM Non-signaling mode supports a maximum of 20 simultaneously active flows)
		the array will be zero padded. Note that 0 is a valid Flow ID.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param piFlowCount = This is both and input and output param.  As an input param
							  it indicates the number of elements in pActiveFlowInfoArray.
							  As an output param it indicates the actual number of active
							  flows in the system.
	\param pArrayFlowIds = array of all active flow ids. The list of active Flow IDs returned is
						formatted as a 20 entry by uint32 (4 byte) array (64 total bytes). Each
						array entry corresponds to an active Flow ID. If there are less than 16
						active Flows (20 is maximum concurrent activated Flows in FTM non-signaling
						mode) the array will be zero padded. Note that 0 is a valid Flow ID.

	\return true if successful, false if fail.

	\warning Prior to calling this function, sufficient space should be allocated in
			 pArrayFlowIds to store 20x4Byte array (80 total bytes).

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_GET_ALL_ACTIVE_FLOW_IDS( HANDLE hResourceContext,
																	 unsigned char *piFlowCount,
																	 unsigned long *pArrayFlowIds );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Non-Signalling, Get OIS State.

	This command returns the state of the WIde and Local OIS.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param piWideOisStatus = Wide OIS Status.
		Defined by mftypes_state_type:
		\code
		INVALID_STATE		= 0x00,
		ACQUIRING_STATE		= 0x01,
		IDLE_STATE			= 0x02,
		ACTIVE_STATE		= 0x03,
		UNAVAILABLE_STATE	= 0x04
		\endcode
	\param piLocalOisStatus = Local OIS Status.
		Defined by mftypes_state_type:
		\code
		INVALID_STATE		= 0x00,
		ACQUIRING_STATE		= 0x01,
		IDLE_STATE			= 0x02,
		ACTIVE_STATE		= 0x03,
		UNAVAILABLE_STATE	= 0x04
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_GET_OIS_STATE( HANDLE hResourceContext,
														   unsigned char *piWideOisStatus,
														   unsigned char *piLocalOisStatus );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Non-Signalling, Enable FTAP PLP Data Logging

		This command starts/stops FTAP PLP Data Packet Records Logging.
		The FTAP PLP data records for all the active FTAP Flows will be logged each superframe.
		This command requires that the following log packets are enabled:
		1)	MFLO FTAP PACKETRECORD HEADER PARAMS (0x120C)
		2)	MFLO FTAP PACKETRECORD PARAMS (0x120D)

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iFtapEnable = 0 - Disable FTAP Logging, 1 - Enable FTAP Logging.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_ENABLE_FTAP_PLP_DATA( HANDLE hResourceContext,
																  unsigned char iFtapEnable );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Non-Signalling, Set FLO Sleep.

	This command Enables/disables FLO sleep.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param eSleepSetting = indicates sleep setting.
		Defined by mftypes_sleep_settings_type:
		\code
		SLEEP_AND_SNOOZE_DISABLED		= 0x00,
		SLEEP_ENABLED_SNOOZE_DISABLED	= 0x01,
		SLEEP_DISABLED_SNOOZE_ENABLED	= 0x02,
		SLEEP_ENABLED_SNOOZE_ENABLED	= 0x03
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_SET_FLO_SLEEP( HANDLE hResourceContext,
														   unsigned char iSleepSetting );

	/******************************************************************************/
	/**

	MediaFLO Diagnostic Calibration, Set Jammer Detection Mode

		This command configures the Jammer Detection Mode.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iEnable = Flag to disable (0) or enable (1) jammer detection
	\param iJDMode = Jammer Detect Mode
		Defined by mftypes_jd_mode_type:
		\code
		MFLO_JD_MODE_AUTO = 0,
		MFLO_JD_MODE_1    = 1,
		MFLO_JD_MODE_2    = 2
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_SET_JAMMER_DETECT_MODE( HANDLE hResourceContext,
																	unsigned char iEnable,
																	unsigned char iJDMode );

	/******************************************************************************/
	/**
	MediaFLO Diagnostic Calibration, Set AGC Gain Tracking

		This command enables/disables the AGC Gain Tracking.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iState = 0 - Disable, 1 - Enable

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_SET_AGC_GAIN_TRACKING( HANDLE hResourceContext,
																   unsigned char iState);

	/******************************************************************************/
	/**

	MediaFLO Diagnostic Non-Signalling, Freeze the AGC gain state

		This command freezes the AGC gain state at the current gain state.
		There may be a delay of up to 500ms after the command is sent before the gain state is frozen.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iFreezeState = 0 - Unfreeze, 1 - Freeze

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_FREEZE_GAIN_STATE( HANDLE hResourceContext,
															   unsigned char iFreezeState );

	/******************************************************************************/
	/**

	MediaFLO Diagnostic Non-Signalling, Get FTM state

		This command returns the current FTM state of the FLO device driver.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iFTMState = FTM state
		Defined by mftypes_ftm_state_type:
		\code
		MFLO_FTM_STATE_UNINITIALIZED	= 0,
		MFLO_FTM_STATE_INITIALIZING	= 1,
		MFLO_FTM_STATE_DEMOD			= 2,
		MFLO_FTM_STATE_CALIBRATION	= 3
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_GET_FLO_FTM_STATE( HANDLE hResourceContext,
															unsigned char* piFTMState );

	/******************************************************************************/
	/**

	MediaFLO Diagnostic Non-Signalling, Get the Jammer Detection State

		This command gets the current Jammer Detection state.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piJDMode = Jammer Detect Mode
		Defined by mftypes_jd_mode_type:
		\code
		MFLO_JD_MODE_AUTO = 0,
		MFLO_JD_MODE_1    = 1,
		MFLO_JD_MODE_2    = 2
		\endcode
	\param piJDState = Jammer Detect State
		Defined by mftypes_jd_state_type:
		\code
		MFLO_JD_STATE_INVALID      = 0,
		MFLO_JD_STATE_MODE_1       = 1,
		MFLO_JD_STATE_MODE_2       = 2,
		MFLO_JD_STATE_INITIALIZING = 3
		\endcode
	\param piJDSubstate = Jammer Detect Substate
		Defined by mftypes_jd_substate_type:
		\code
		MFLO_JD_SUBSTATE_NONE    = 0,
		MFLO_JD_SUBSTATE_POLLING = 1
		\endcode

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_GET_JAMMER_DETECT_STATE( HANDLE hResourceContext,
																	 unsigned char* piJDMode,
																	 unsigned char* piJDState,
																	 unsigned char* piJDSubstate);

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls one of the MediaFLO Diagnostic ICD
	API's to perform a specialized task.

	This command is used to enable the logging of LOG_MFLO_FDM_RECORDS_C log packets.
	The LOG_MFLO_FDM_RECORDS_C log packets contain the FDM (Flow Description Message)
	information for a given WIDE/LOCAL system - a mapping table between Flow IDs and
	MLC IDs.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param eMessageType = identifies which part of the control channel data is being
					      requested (mftypes_cc_msg_type)

	\return true if the LOG_MFLO_FDM_RECORDS_C log packets have been generated
	        successfully, otherwise false.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GET_CONTROL_CHANNEL_DATA(HANDLE hResourceContext, unsigned char eMessageType );

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls one of the MediaFLO Diagnostic ICD
	API's to perform a specialized task.

	This function gets information required to deactivate all active Flow IDs through
	QLIB_MFLO_GET_BOUND_FLOW_LIST. Then it sends the QLIB_MFLO_DEACTIVATE_FLOW
	command for each active Flow ID. After deactivating all Flow IDs, this function
	will call QLIB_MFLO_GET_BOUND_FLOW_COUNT in one second intervals until the command
	reports	that the number of active Flow IDs is zero or the number of seconds specified
	by the iTimeOut input parameter have elapsed.

	This function will fail if any of the functions called fail or if all active
	Flow IDs have not been de-activated after the specified number of seconds to wait.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iTimeOut - the number of seconds to wait for QLIB_MFLO_GET_BOUND_FLOW_COUNT
					  to report that the number of active Flow IDs is zero.

	\return true if successful, false if fail.

	\warning none

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_DeactivateAllFlows( HANDLE hResourceContext, unsigned short iTimeOut );

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls one of the MediaFLO Diagnostic ICD
	API's to perform a specialized task.

	This command gets the current system state for the specified system(s) by calling
	QLIB_MFLO_GET_FLO_STATE for each system requested.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param eSystem = the system (mftypes_system_type)
	\param peWideAreaSystemState = the current wide area system state (mftypes_state_type)
	\param peLocalAreaSystemState = the current local area system state (mftypes_state_type)

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GetSystemState( HANDLE hResourceContext, unsigned char eSystem,
													 unsigned char* peWideAreaSystemState,
													 unsigned char* peLocalAreaSystemState );

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls one of the MediaFLO Diagnostic ICD
	API's to perform a specialized task.

	This function measures the Physical layer packet error rate.  This type of packet
	error rate measurement does not require a known nor finite sequence of FTAP packets
	from the FLO Tx Waveform.  The measurement is made by querying the accumulated PLP
	statistics for all requested Flow IDs.  Accumulated statistics continue to be queried
	until the minimum number of PLPs have been recorded.	Accumulated PLP statistics
	are queried through the QLIB_MFLO_GET_MLC_PLP_STAT_DYN_PARAMS function.

	After calling QLIB_MFLO_RST_PLP_STATS to reset the accumulated statistics for all
	MLCs, this function may be called repeatedly until the desired level of confidence
	is achieved.

	The time period that is used when checking for status is controlled by the
	timing index QMSL_Timeout_Delay_MediaFLO_StatusCheck, to be used with the functions
	QLIB_ConfigureTimeOut() and QLIB_GetTimeOut().

	Usage examples:

		QLIB_MFLO_RST_PLP_STATS
		QLIB_MFLO_GetPER_Phy		--------------	Measure PER for first test


		QLIB_MFLO_RST_PLP_STATS		---------
		QLIB_MFLO_GetPER_Phy				|
		QLIB_MFLO_GetPER_Phy				|-----  Measure PER for second test
		QLIB_MFLO_GetPER_Phy				|		Note: Example shows measurement ran longer
		QLIB_MFLO_GetPER_Phy		---------		      to achieve desired level of confidence

	This function reports the packet error rate statistics for all requested Flow IDs,
	the current system state, and an error code.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iNumberOfFlowIDs = the number of FlowIDs in aiFlowIDs
	\param aiFlowIDs = array of Flow IDs for which to get accumulated PLP statistics
	\param aiMlcIDs = array of MLC IDs that correspond to the Flow IDs in aiFlowIDs,
	                  this is required because QLIB_MFLO_GET_MLC_PLP_STAT_DYN_PARAMS
					  requires the MLC ID not Flow ID
	\param aeSystem = array of mftypes_system_type with elements that correspond to the
	                  Flow IDs in aiFlowIDs, the System for each Flow ID is required by
					  QLIB_MFLO_GET_MLC_PLP_STAT_DYN_PARAMS
	\param iNoStatsTimeout = time in seconds to wait for statistics to update, max of 5
							 seconds recommended
	\param ePerToMeas = which packet error rate to measure, statistics for both Base and
	                    Enhancement layers will be reported but the determination of
						whether or not iMinPLPs have been measured depends on what this
						variable has been set to (mftypes_per_to_measure)
	\param iMinPLPs = the minimum number of PLPs to measure for all Flow IDs
	\param eRS = which statistics to report, Pre or Post Reed Solomon (mftypes_reed_solomon)
	\param paOverallStats = an array of type mftypes_per_statistics with length
							iNumberOfFlowIDs to store the packet error rate statistics for
							all requested Flow IDs
	\param peWideAreaSystemState = the current wide area system state if one of the
								   elements in aeSystem is WIDE (mftypes_state_type)
	\param peLocalAreaSystemState = the current local area system state if one of the
	                                elements in aeSystem is LOCAL (mftypes_state_type)
	\param peErrorCode = an error code used whenever possible to provide more information
	                     about why the function failed, see the warning below for one
						 exception (mftypes_error_code)

	\return true if successful, false if fail.

	\warning This function does not dynamically allocate memory for the pOverallStats
			 array.  Sufficient memory for pOverallStats must be allocated by the
			 calling program.

			 The results reported in paOverallStats are only valid if...
				QLIB_MFLO_GetPER_Phy return value is 1		AND
				Requested system state(s) == ACTIVE_STATE	AND
			    peErrorCode == NOT_AVAILABLE.

			 If at some point during the measurement, the requested system state is not
			 ACTIVE_STATE,  the function will return but not fail.  The current system
			 state will be reported through peWideAreaSystemState and peLocalAreaSystemState.

			 If the statistics for one or more of the MLC IDs in aiMlcIDs have not updated
			 after the number of seconds specified by iNoStatsTimeout have elapsed, the
			 function will return but not fail. peErrorCode will be set to PLP_STATS_NOT_UPDATING.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GetPER_Phy( HANDLE hResourceContext, unsigned char iNumberOfFlowIDs,
		                                         unsigned long* aiFlowIDs, unsigned char* aiMlcIDs,
												 unsigned char* aeSystem, unsigned short iNoStatsTimeout,
												 unsigned char ePerToMeas, unsigned long iMinPLPs,
												 unsigned char eRS, void* paOverallStats,
												 unsigned char* peWideAreaSystemState,
												 unsigned char* peLocalAreaSystemState,
												 unsigned char* peErrorCode );

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls one of the MediaFLO Diagnostic ICD
	API's to perform a specialized task.

	This function performs initialization steps required before making ANY
	Physical layer + MAC layer packet error rate measurements.  This type of packet
	error rate measurement requires a known and finite sequence of FTAP packets from
	the FLO Tx Waveform.  This function initializes an internal data structure with
	information about the finite sequence of FTAP packets in the FLO Tx Waveform and
	dynamically allocates memory for internal data structures used to make the packet
	error rate measurement.

	This function will fail if pTAP_MsgContent is NULL or if there are any memory
	allocation errors.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param pTAP_MsgContent = pointer to mftypes_tap_msg_content structure filled with
					         information about the finite sequence of FTAP packets in
							 the FLO Tx Waveform.
	\param peErrorCode = an error code used whenever possible to provide more
						 information about why the function failed (mftypes_error_code)

	\return true if successful, false if fail.

	\warning This function must be called once at the start of testing, before calling
			 any of the following functions:

				QLIB_MFLO_Start_PhyMAC
				QLIB_MFLO_GetPER_PhyMAC
				QLIB_MFLO_Stop_PhyMAC
				QLIB_FTM_MFLO_NS_Start_PhyMAC
				QLIB_FTM_MFLO_NS_GetPER_PhyMAC
				QLIB_FTM_MFLO_NS_Stop_PhyMAC

			 There is no need to call this function more than once during one session
			 if the contents of the mftypes_tap_msg_content structure (pTAP_MsgContent)
			 do not need to change.

			 To prevent memory leaks, memory dynamically allocated by this function
			 should be freed by calling QLIB_MFLO_FinalCleanup_PhyMAC at the end of
			 testing.

			 See QLIB_MFLO_GetPER_PhyMAC or QLIB_FTM_MFLO_NS_GetPER_PhyMAC for usage examples.
 	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_InitTAPMsgContent_PhyMAC( HANDLE hResourceContext,
															   void* pTAP_MsgContent, unsigned char* peErrorCode );

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls one of the MediaFLO Diagnostic ICD
	API's to perform a specialized task.

	This function performs initialization steps required before making a new
	Physical layer + MAC layer packet error rate measurement.  This type of packet
	error rate measurement requires a known and finite sequence of FTAP packets from
	the FLO Tx Waveform.  This function resets the overall packet error rate statistics,
	updates data structures used in the packet error rate measurement, clears the log
	queue, registers the following log codes:

			LOG_MFLO_FTAP_PACKETRECORD_HEADER_PARAMS_C	0x120C
			LOG_MFLO_FTAP_PACKETRECORD_PARAMS_C			0x120D

	and enables FTAP PLP Data Logging Mode by through QLIB_MFLO_ENABLE_FTAP_PLP_DATA.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iNumberOfFlowIDs = the number of FlowIDs in aiFlowIDs, must match the actual
	                          number of active FlowIDs or this funtion will fail
	\param aiFlowIDs = array of Flow IDs for which to measure the packet error rate
	\param paOverallStats = an array of type mftypes_per_statistics with length
							iNumberOfFlowIDs to store the packet error rate
							statistics for all requested Flow IDs
	\param peErrorCode = an error code used whenever possible to provide more
						 information about why the function failed (mftypes_error_code)

	\return true if successful, false if fail.

	\warning This function does not dynamically allocate memory for the pOverallStats
			 array.  Sufficient memory for pOverallStats must be allocated by the
			 calling program.

			 QLIB_MFLO_InitTAPMsgContent_PhyMAC must be called once before the first
			 time this function is called.

			 This function must be called once before calling QLIB_MFLO_GetPER_PhyMAC.
			 The function QLIB_MFLO_Stop_PhyMAC should be called at the end of the packet
			 error rate measurement.  To make a new packet error rate measurement,
			 this function must be called again before calling QLIB_MFLO_GetPER_PhyMAC.
			 See QLIB_MFLO_GetPER_PhyMAC for usage examples.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_Start_PhyMAC( HANDLE hResourceContext,
		                                           unsigned char iNumberOfFlowIDs, unsigned long* aiFlowIDs,
												   void* paOverallStats, unsigned char* peErrorCode );

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls one of the MediaFLO Diagnostic ICD
	API's to perform a specialized task.

	This function measures the Physical layer + MAC layer packet error rate.  This
	type of packet error rate measurement requires a known and finite sequence of
	FTAP packets from the FLO Tx Waveform.

	The measurement is made by getting erasure and FTAP Sequence Number /
	FTAP Test Signature information from log packets with the following log codes:

		LOG_MFLO_FTAP_PACKETRECORD_HEADER_PARAMS_C	0x120C
		LOG_MFLO_FTAP_PACKETRECORD_PARAMS_C			0x120D

    FTAP Sequence Number / FTAP Test Signature errors are determined by comparing
	the values reported in the log packets to the expected values that were set
	by QLIB_MFLO_InitTAPMsgContent_PhyMAC.  Missing or mismatching pairs in each
	superframe are counted as errors.

	Total errors include erasures and FTAP Sequence Number / FTAP Test Signature errors.

	This function continues parsing log packets and keeping track of overall packet
	error rate statistics until the minimum number of PLPs have been measured for all
	requested Flow IDs.

	After calling QLIB_MFLO_Start_PhyMAC, this function may be called repeatedly until
	desired level of confidence is achieved. Once the current measurement is complete,
	call QLIB_MFLO_Stop_PhyMAC.  To measure the packet error rate again, call
	QLIB_MFLO_Start_PhyMAC again before calling this function.

	Usage example:

		QLIB_MFLO_InitTAPMsgContent_PhyMAC	-------- Called once at start of session

		QLIB_MFLO_Start_PhyMAC				---------
		QLIB_MFLO_GetPER_PhyMAC						|-----	Measure PER for first test
		QLIB_MFLO_Stop_PhyMAC				---------

		QLIB_MFLO_Start_PhyMAC				---------
		QLIB_MFLO_GetPER_PhyMAC						|
		QLIB_MFLO_GetPER_PhyMAC						|-----  Measure PER for second test
		QLIB_MFLO_GetPER_PhyMAC						|		Note: Example shows measurement
		QLIB_MFLO_GetPER_PhyMAC						|		      ran longer to achieve
		QLIB_MFLO_Stop_PhyMAC				---------             desired confidence
				.
				.
				.
		QLIB_MFLO_FinalCleanup_PhyMAC		-------- Called once at end of session

	This function reports the packet error rate statistics for all requested Flow IDs,
	the current system state, and an error code.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iNoLogPktsTimeout = time in seconds to wait for log packets
  	\param ePerToMeas = which packet error rate to measure, statistics for both Base
						and Enhancement layers will be reported but the determination of
						whether or not iMinPLPs have been measured depends on what this
						variable has been set to (mftypes_per_to_measure)
	\param iMinPLPs = the minimum number of PLPs to measure for all Flow IDs
	\param eSystem = the system, required for getting the system state (mftypes_system_type)
	\param eErasureIndicator = which erasure indicator to use when counting erasures
	                           (mftypes_reed_solomon)
	\param paOverallStats = an array of type mftypes_per_statistics to store the packet
							error rate statistics for all requested Flow IDs
	\param peWideAreaSystemState = the current wide area system state if eSystem was set to
	                               WIDE or WIDE_AND_LOCAL (mftypes_state_type)
	\param peLocalAreaSystemState = the current local area system state if eSystem was set to
	                                LOCAL or WIDE_AND_LOCAL (mftypes_state_type)
	\param peErrorCode = an error code used whenever possible to provide more information
	                     about why the function failed, see the warning below for two
						 exceptions (mftypes_error_code)

	\return true if successful, false if fail.

	\warning This function does not dynamically allocate memory for the pOverallStats
			 array.  Sufficient memory for pOverallStats must be allocated by the
			 calling program.

			 The results reported in paOverallStats are only valid if...
				QLIB_MFLO_GetPER_PhyMAC return value is true		AND
				Requested system state(s) == ACTIVE_STATE			AND
			    peErrorCode == NOT_AVAILABLE.

			 If at some point during the measurement, the system state is not ACTIVE_STATE,
	         the function will return but not fail.  The current system state will be reported
			 through peWideAreaSystemState and peLocalAreaSystemState.  At this point
			 QLIB_MFLO_Stop_PhyMAC should be called.

			 If no log packets are received after the number of seconds specified by
			 iNoLogPktsTimeout have elapsed, the function will return but not fail and
			 peErrorCode will be set to NO_LOG_PACKETS. At this point QLIB_MFLO_Stop_PhyMAC
			 should be called.

			The time period that is used when checking for status is controlled by the
			timing index QMSL_Timeout_Delay_MediaFLO_StatusCheck, to be used with the functions
			QLIB_ConfigureTimeOut() and QLIB_GetTimeOut().


			 This function depends on receiving all packets for all requested Flow IDs in
			 an expected order.  If any expected log packets are not received, the function
			 will return but not fail and peErrorCode will be set to MISSING_LOG_PACKETS.
			 At this point QLIB_MFLO_Stop_PhyMAC should be called.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_GetPER_PhyMAC( HANDLE hResourceContext, unsigned short iNoLogPktsTimeout,
													unsigned char ePerToMeas, unsigned long iMinPLPs,
													unsigned char eSystem, unsigned char eErasureIndicator,
													void* paOverallStats, unsigned char* peWideAreaSystemState,
													unsigned char* peLocalAreaSystemState, unsigned char* peErrorCode );

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls one of the MediaFLO Diagnostic ICD
	API's to perform a specialized task.

	This function stops the current Physical layer + MAC layer packet error rate
	measurement.  It disables FTAP PLP Data Logging Mode, clears all log codes for
	LOG_EQUIP_ID_1X, and clears the log queue.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()

	\return true if successful, false if fail.

	\warning This function should be called at the end of a packet error rate
			 measurement after all calls to QLIB_MFLO_GetPER_PhyMAC for the current
			 measurement are complete. See QLIB_MFLO_GetPER_PhyMAC for usage examples.
 	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_Stop_PhyMAC( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls one of the MediaFLO Diagnostic ICD
	API's to perform a specialized task.

	This function performs final cleanup for Physical layer + MAC layer packet error
	rate measurements.  This function only needs to be called once at the end of a
	test session after all packet error rate measurements to be made with the current
	TAP Message content that was initialized by QLIB_MFLO_InitTAPMsgContent_PhyMAC
	are complete.  This function disables FTAP PLP Data Logging Mode clears all log
	codes for LOG_EQUIP_ID_1X, and clears the log queue.  It also frees up any memory
	that was dynamically allocated by QLIB_MFLO_InitTAPMsgContent_PhyMAC and
	QLIB_MFLO_Start_PhyMAC.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()

	\return true if successful, false if fail.

	\warning To prevent memory leaks, this function must be called once at the end
			 of testing when no more packet error rate measurements are to be made
			 with the current TAP Message Content.  See QLIB_MFLO_GetPER_PhyMAC for
			 a usage example.
 	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FinalCleanup_PhyMAC( HANDLE hResourceContext );

	/******************************************************************************/
	/**
	This function measures the Physical layer packet error rate.  This type of packet
	error rate measurement does not require a known nor finite sequence of FTAP packets
	from the FLO Tx Waveform.  The measurement is made by querying the accumulated PLP
	statistics for all requested Flow IDs.  Accumulated statistics continue to be
	queried until the minimum number of PLPs have been recorded.  Accumulated PLP
	statistics are queried through the MFLO_FTM_NS_GET_MLC_DYN_PARAMS function.

	After calling MFLO_FTM_NS_RESET_ALL_PLP_STATS to reset the accumulated statistics for all
	MLCs, this function may be called repeatedly until the desired level of confidence
	is achieved. To measure the packet error rate again, call MFLO_FTM_NS_RESET_ALL_PLP_STATS again
	before calling this function.

	Usage examples:

		MFLO_FTM_NS_RESET_ALL_PLP_STATS
		MFLO_FTM_NS_GetPER_Phy		--------------	Measure PER for first test


		MFLO_FTM_NS_RESET_ALL_PLP_STATS	---------
		MFLO_FTM_NS_GetPER_Phy					 |
		MFLO_FTM_NS_GetPER_Phy					 |-----  Measure PER for second test
		MFLO_FTM_NS_GetPER_Phy					 |		Note: Example shows measurement ran longer
		MFLO_FTM_NS_GetPER_Phy			---------		      to achieve desired level of confidence

	This function reports the packet error rate statistics for all requested Flow IDs,
	the current system state, and an error code.

	\param iNumberOfFlowIDs = the number of FlowIDs in aiFlowIDs
	\param aiFlowIDs = array of Flow IDs for which to get accumulated PLP statistics
	\param aiMlcIDs = array of MLC IDs that correspond to the Flow IDs in aiFlowIDs,
	                  this is required because MFLO_FTM_GET_MLC_PLP_STAT_DYN_PARAMS requires
					  the MLC ID not Flow ID
	\param aeSystem = array of mftypes_system_type with elements that correspond to the
	                  Flow IDs in aiFlowIDs, the System for each Flow ID is required by
					  QLIB_MFLO_FTM_GET_MLC_PLP_STAT_DYN_PARAMS
	\param iNoStatsTimeout = time in seconds to wait for statistics to update, max of 5
							 seconds recommended
	\param ePerToMeas = which packet error rate to measure, statistics for both Base and
	                    Enhancement layers will be reported but the determination of
						whether or not iMinPLPs have been measured depends on what this
						variable has been set to (mftypes_per_to_measure)
	\param iMinPLPs = the minimum number of PLPs to measure for all Flow IDs
	\param eRS = which statistics to report, Pre or Post Reed Solomon (mftypes_reed_solomon)
	\param paOverallStats = an array of type mftypes_per_statistics with length
							iNumberOfFlowIDs to store the packet error rate statistics for
							all requested Flow IDs
	\param peWideAreaSystemState = the current wide area system state if one of the
								   elements in aeSystem is WIDE (mftypes_state_type)
	\param peLocalAreaSystemState = the current local area system state if one of the
	                                elements in aeSystem is LOCAL (mftypes_state_type)
	\param peErrorCode = an error code used whenever possible to provide more information
	                     about why the function failed, see the warning below for one
						 exception (mftypes_error_code)

	\return true if successful, false if fail.

	\warning This function does not dynamically allocate memory for the pOverallStats
			 array.  Sufficient memory for pOverallStats must be allocated by the
			 calling program.

			 The results reported in paOverallStats are only valid if...
				MFLO_FTM_NS_GetPER_Phy return value is true		AND
				Requested system state(s) == ACTIVE_STATE	AND
			    peErrorCode == NOT_AVAILABLE.

			 If at some point during the measurement, the requested system state is not
			 ACTIVE_STATE,  the function will return but not fail.  The current system
			 state will be reported through peWideAreaSystemState and peLocalAreaSystemState.

			 If the statistics for one or more of the MLC IDs in aiMlcIDs have not updated
			 after the number of seconds specified by iNoStatsTimeout have elapsed, the
			 function will return but not fail. peErrorCode will be set to PLP_STATS_NOT_UPDATING.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_GetPER_Phy( HANDLE hResourceContext,
														unsigned char iNumberOfFlowIDs,
														unsigned long* aiFlowIDs,
														unsigned char* aiMlcIDs,
														unsigned long* aeSystem,
														unsigned short iNoStatsTimeout,
														unsigned long ePerToMeas,
														unsigned long iMinPLPs,
														unsigned long eRS,
														void* paOverallStats,
														unsigned long* peWideAreaSystemState,
														unsigned long* peLocalAreaSystemState,
														unsigned long* peErrorCode );

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls several of the MediaFLO FTM
	API's to perform a specialized task.

	This function performs initialization steps required before making a new
	Physical layer + MAC layer packet error rate measurement.  This type of packet
	error rate measurement requires a known and finite sequence of FTAP packets from
	the FLO Tx Waveform.  This function resets the overall packet error rate statistics,
	updates data structures used in the packet error rate measurement, clears the log
	queue, registers the following log codes:

			LOG_MFLO_FTAP_PACKETRECORD_HEADER_PARAMS_C	0x120C
			LOG_MFLO_FTAP_PACKETRECORD_PARAMS_C			0x120D

	and enables FTAP PLP Data Logging Mode by through QLIB_FTM_MFLO_NS_ENABLE_FTAP_PLP_DATA.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iNumberOfFlowIDs = the number of FlowIDs in aiFlowIDs, must match the actual
							  number of active FlowIDs or this funtion will fail
	\param aiFlowIDs = array of Flow IDs for which to measure the packet error rate
	\param paOverallStats = an array of type mftypes_per_statistics with length
							iNumberOfFlowIDs to store the packet error rate
							statistics for all requested Flow IDs
	\param peErrorCode = an error code used whenever possible to provide more
						 information about why the function failed (mftypes_error_code)

	\return true if successful, false if fail.

	\warning This function does not dynamically allocate memory for the pOverallStats
			 array. Sufficient memory for pOverallStats must be allocated by the
			 calling program.

			 QLIB_MFLO_InitTAPMsgContent_PhyMAC must be called once before the first
			 time this function is called.

			 This function must be called once before calling QLIB_FTM_MFLO_NS_GetPER_PhyMAC.
			 The function QLIB_FTM_MFLO_NS_Stop_PhyMAC should be called at the end of the packet
			 error rate measurement. To make a new packet error rate measurement,
			 this function must be called again before calling QLIB_FTM_MFLO_NS_GetPER_PhyMAC.
			 See QLIB_FTM_MFLO_NS_GetPER_PhyMAC for usage examples.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_Start_PhyMAC( HANDLE hResourceContext,
														  unsigned char iNumberOfFlowIDs,
														  unsigned long* aiFlowIDs,
														  void* paOverallStats,
														  unsigned long* peErrorCode );

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls one of the MediaFLO Diagnostic ICD
	API's to perform a specialized task.

	This function measures the Physical layer + MAC layer packet error rate. This
	type of packet error rate measurement requires a known and finite sequence of
	FTAP packets from the FLO Tx Waveform.

	The measurement is made by getting erasure and FTAP Sequence Number /
	FTAP Test Signature information from log packets with the following log codes:

		LOG_MFLO_FTAP_PACKETRECORD_HEADER_PARAMS_C	0x120C
		LOG_MFLO_FTAP_PACKETRECORD_PARAMS_C			0x120D

	FTAP Sequence Number / FTAP Test Signature errors are determined by comparing
	the values reported in the log packets to the expected values that were set
	by QLIB_MFLO_InitTAPMsgContent_PhyMAC. Missing or mismatching pairs in each
	superframe are counted as errors.

	Total errors include erasures and FTAP Sequence Number / FTAP Test Signature errors.

	This function continues parsing log packets and keeping track of overall packet
	error rate statistics until the minimum number of PLPs have been measured for all
	requested Flow IDs.

	After calling QLIB_MFLO_Start_PhyMAC, this function may be called repeatedly until
	desired level of confidence is achieved. Once the current measurement is complete,
	call QLIB_MFLO_Stop_PhyMAC.  To measure the packet error rate again, call
	QLIB_MFLO_Start_PhyMAC again before calling this function.

	Usage example:

		QLIB_MFLO_InitTAPMsgContent_PhyMAC	-------- Called once at start of session

		QLIB_FTM_MFLO_NS_Start_PhyMAC		---------
		QLIB_FTM_MFLO_NS_GetPER_PhyMAC				|-----	Measure PER for first test
		QLIB_FTM_MFLO_NS_Stop_PhyMAC		---------

		QLIB_FTM_MFLO_NS_Start_PhyMAC		---------
		QLIB_FTM_MFLO_NS_GetPER_PhyMAC				|
		QLIB_FTM_MFLO_NS_GetPER_PhyMAC				|-----  Measure PER for second test
		QLIB_FTM_MFLO_NS_GetPER_PhyMAC				|		Note: Example shows measurement
		QLIB_FTM_MFLO_NS_GetPER_PhyMAC				|		      ran longer to achieve
		QLIB_FTM_MFLO_NS_Stop_PhyMAC		---------             desired confidence

		QLIB_MFLO_FinalCleanup_PhyMAC		-------- Called once at end of session

	This function reports the packet error rate statistics for all requested Flow IDs,
	the current system state, and an error code.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iNoLogPktsTimeout = time in seconds to wait for log packets
	\param ePerToMeas = which packet error rate to measure, statistics for both Base
						and Enhancement layers will be reported but the determination of
						whether or not iMinPLPs have been measured depends on what this
						variable has been set to (mftypes_per_to_measure)
	\param iMinPLPs = the minimum number of PLPs to measure for all Flow IDs
	\param eSystem = the system, required for getting the system state (mftypes_system_type)
	\param eErasureIndicator = which erasure indicator to use when counting erasures
	                           (mftypes_reed_solomon)
	\param paOverallStats = an array of type mftypes_per_statistics to store the packet
							error rate statistics for all requested Flow IDs
	\param peWideAreaSystemState = the current wide area system state if eSystem was set to
	                               WIDE or WIDE_AND_LOCAL (mftypes_state_type)
	\param peLocalAreaSystemState = the current local area system state if eSystem was set to
	                                LOCAL or WIDE_AND_LOCAL (mftypes_state_type)
	\param peErrorCode = an error code used whenever possible to provide more information
						 about why the function failed, see the warning below for two
						 exceptions (mftypes_error_code)

	\return true if successful, false if fail.

	\warning This function does not dynamically allocate memory for the pOverallStats
			 array. Sufficient memory for pOverallStats must be allocated by the
			 calling program.

			 The results reported in paOverallStats are only valid if
				QLIB_FTM_MFLO_NS_GetPER_PhyMAC return value is true		AND
				Requested system state(s) == ACTIVE_STATE				AND
				peErrorCode == NOT_AVAILABLE.

			 If at some point during the measurement, the system state is not ACTIVE_STATE,
			 the function will return but not fail. The current system state will be reported
			 through peWideAreaSystemState and peLocalAreaSystemState. At this point
			 QLIB_FTM_MFLO_NS_Stop_PhyMAC should be called.

			 If no log packets are received after the number of seconds specified by
			 iNoLogPktsTimeout have elapsed, the function will return but not fail and
			 peErrorCode will be set to NO_LOG_PACKETS. At this point QLIB_FTM_MFLO_NS_Stop_PhyMAC
			 should be called.

			The time period that is used when checking for status is controlled by the
			timing index QMSL_Timeout_Delay_MediaFLO_StatusCheck, to be used with the functions
			QLIB_ConfigureTimeOut() and QLIB_GetTimeOut().

			 This function depends on receiving all packets for all requested Flow IDs in
			 an expected order. If any expected log packets are not received, the function
			 will return but not fail and peErrorCode will be set to MISSING_LOG_PACKETS.
			 At this point QLIB_FTM_MFLO_NS_Stop_PhyMAC should be called.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_GetPER_PhyMAC( HANDLE hResourceContext,
														   unsigned short iNoLogPktsTimeout,
														   unsigned long ePerToMeas,
														   unsigned long iMinPLPs,
														   unsigned long eSystem,
														   unsigned long eErasureIndicator,
														   void* paOverallStats,
														   unsigned long* peWideAreaSystemState,
														   unsigned long* peLocalAreaSystemState,
														   unsigned long* peErrorCode );

	/******************************************************************************/
	/**
	This is a MediaFLO "helper function" which calls one of the MediaFLO Diagnostic ICD
	API's to perform a specialized task.

	This function stops the current Physical layer + MAC layer packet error rate
	measurement. It disables FTAP PLP Data Logging Mode, clears all log codes for
	LOG_EQUIP_ID_1X, and clears the log queue.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()

	\return true if successful, false if fail.

	\warning This function should be called at the end of a packet error rate
			 measurement after all calls to QLIB_FTM_MFLO_NS_GetPER_PhyMAC for the current
			 measurement are complete. See QLIB_FTM_MFLO_NS_GetPER_PhyMAC for usage examples.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_MFLO_FTM_NS_Stop_PhyMAC( HANDLE hResourceContext );

/******************************************************************************
						CGPS DIAG
*******************************************************************************/

	/******************************************************************************/
	/**
	This function instructs the CGPS engine to enter "Standalone RF verification" mode.


	This command will check the status field and return false if the command was rejected.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iFlag = input
	\code
        0 = GPS_SA_RF_VERIF_MODE_SWITCH_ENTER_MODE = Enter SA-RF Verif Mode,
		1 = GPS_SA_RF_VERIF_MODE_SWITCH_EXIT_MODE  = Exit SA-RF Verif Mode
			Refer to the enumeration below for bit mask definitions:

            typedef enum
            {
               GPS_SA_RF_VERIF_MODE_SWITCH_ENTER_MODE	      = 0x00, // Enter Standalone RF verification mode
               GPS_SA_RF_VERIF_MODE_SWITCH_EXIT_MODE          = 0x01  // Exit Standalone RF verification mode
            } gps_sa_rf_verif_mode_switch_enum_type;
	\endcode

	\param piStatus = output, 0=Command Accepted, 1=Command Rejected

	\return true if successful, false if fail.

	\warning This version of the function does not wait for the associated event.
	         Use QLIB_DIAG_GPS_SA_RF_VERIF_MODE_SWITCH_WithWait() to wait for the event.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GPS_SA_RF_VERIF_MODE_SWITCH(
									HANDLE hResourceContext,
									unsigned char iFlag,
									unsigned char* piStatus
									);

	/******************************************************************************/
	/**
	This function instructs the CGPS engine to enter "Standalone RF verification" mode
	and waits for the associated event, EVENT_GPS_LM_ENTER_SA_RF_VERIF #1247

	The timeout value for waiting for the event can be set using QLIB_ConfigureTimeOut() and the
	timeout type of QMSL_Timeout_CGPS_Event.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iFlag = input
	\code
        0 = GPS_SA_RF_VERIF_MODE_SWITCH_ENTER_MODE = Enter SA-RF Verif Mode,
		1 = GPS_SA_RF_VERIF_MODE_SWITCH_EXIT_MODE  = Exit SA-RF Verif Mode
			Refer to the enumeration below for bit mask definitions:

            typedef enum
            {
               GPS_SA_RF_VERIF_MODE_SWITCH_ENTER_MODE	      = 0x00, // Enter Standalone RF verification mode
               GPS_SA_RF_VERIF_MODE_SWITCH_EXIT_MODE          = 0x01  // Exit Standalone RF verification mode
            } gps_sa_rf_verif_mode_switch_enum_type;
	\endcode
	\param piStatus = output, 0=Command Accepted, 1=Command Rejected

	\return true if successful, false if fail.

	\warning The asynchronous message queue will be cleared in the course of executing this function

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GPS_SA_RF_VERIF_MODE_SWITCH_WithWait(
									HANDLE hResourceContext,
									unsigned char iFlag,
									unsigned char* piStatus
									);

	/******************************************************************************/
	/**
	This function instructs the CGPS engine to perform one dwell on one channel.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iFlags			= input, Enables different functionalities
							  Refer to these enumerations for bit mask definitions:
		\code
            typedef enum
            {
               GPS_PRESCRIBED_DWELL_NO_RESULTS	          = 0x00, // Do not send dwell results
               GPS_PRESCRIBED_DWELL_SEND_RESULTS          = 0x01  // Send dwell results
            } gps_prescribed_dwell_results_enum_type;	//Bit 0

            typedef enum
            {
               GPS_PRESCRIBED_DWELL_CHIPX1                = 0x00, // Chipx1
               GPS_PRESCRIBED_DWELL_CHIPX2                = 0x02  // Chipx2
            } gps_prescribed_dwell_chip_rate_enum_type;	//Bit 1

            typedef enum
			{
                GPS_PRESCRIBED_DWELL_NO_INCOHER_SUMS     = 0x00, // Do not report incoherent sums
                GPS_PRESCRIBED_DWELL_REPORT_INCOHER_SUMS  = 0x04  // Report incoherent sums
            } gps_prescribed_dwell_incoher_sums_enum_type; //Bit 2

            typedef enum
            {
                GPS_PRESCRIBED_DWELL_NO_COHER_SUMS       = 0x00, // Do not report coherent sums
                GPS_PRESCRIBED_DWELL_REPORT_COHER_SUMS    = 0x08  // Report coherent sums
            } gps_prescribed_dwell_coher_sums_enum_type; //Bit 3

            typedef enum
			{
                GPS_PRESCRIBED_DWELL_START_NOW           = 0x00, // Start now
                GPS_PRESCRIBED_DWELL_USE_TOA              = 0x0A  // Use TOA
            } gps_prescribed_dwell_start_time_enum_type; //Bit[5:4]

            typedef enum
            {
                GPS_PRESCRIBED_DWELL_USE_RF              = 0x00, // Use RF
                GPS_PRESCRIBED_DWELL_USE_TS               = 0x40  // Use TS
            } gps_prescribed_dwell_source_enum_type; //Bit 6

            typedef enum
            {
                GPS_PRESCRIBED_DWELL_NO_INIT             = 0x00, // Do not initialize TS and BC at starte of dwell
                GPS_PRESCRIBED_DWELL_INIT_TS_AND_BC       = 0x80  // Initialize TS and BC at start of dwell
            } gps_prescribed_dwell_source_init_type; //Bit 7
		\endcode
	\param iTOA				= input, Time of Applicability. GPS_RTC time at which dwell must start.
	\param iSV				= input, Satellite PRN [0..32]. If zero, correlation is codeless.
	\param iSearchMode		= input, Pre-Detection Mode.
	\param iPOST_DET_N		= input, Number of Post-Detection.
	\param iTASK_MASK1		= input, Bit31:Bit0 - Task32:Task1. A set bit implies that that task must be selected.
	\param iTASK_MASK2		= input, Bit7:Bit0 - Task40:Task33. A set bit implies that that task must be selected.
	\param iDOPP_FREQ		= input, Signed (1000/65536 Hz/Bit). Range: -32768000 to +32768000 Hz.
	\param iDOPP_FREQ_RATE	= input, Signed (1000/65536 Hz/sec/Bit). Range: -32768000 to +32768000 Hz/sec.
	\param iSUB_MS			= input, Unsigned (1/256 Chips/Bit). Range: 0 to 1023 chips.
	\param iCNO_Threshold	= input, Used for declaring dwell as a detection. Dwell result DM packet.
							  will be send only if CNo exceeds this threshold. Unsigned (0.1 dB/bit). Range: 0 to 6553.5dB.
	\param iJammerThreshold	= input, Unsigned (0.1 dB/bit). Range: 0 to 6553.5dB.

	\param piStatus			= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning This version of the function does not wait for the response event. To wait for
	         the event use QLIB_DIAG_GPS_PRESCRIBED_DWELL_WithWait

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GPS_PRESCRIBED_DWELL(
									HANDLE hResourceContext,
									unsigned short iFlags,
									unsigned long iTOA,
									unsigned char iSV,
									unsigned char iSearchMode,
									unsigned short iPOST_DET_N,
									unsigned long iTASK_MASK1,
									unsigned char iTASK_MASK2,
									unsigned long iDOPP_FREQ,
									unsigned long iDOPP_FREQ_RATE,
									unsigned long iSUB_MS,
									unsigned short iCNO_Threshold,
									unsigned short iJammerThreshold,
									unsigned char* piStatus
									);

	/******************************************************************************/
	/**
	This function instructs the CGPS engine to perform one dwell on one channel, then
	wait for the corresponding event, EVENT_GPS_LM_PD_COMPLETE, #1250.

	The timeout value for waiting for the event can be set using QLIB_ConfigureTimeOut() and the
	timeout type of QMSL_Timeout_CGPS_Event.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param iFlags			= input, Enables different functionalities
							  Refer to these enumerations for bit mask definitions:
		\code
            typedef enum
            {
               GPS_PRESCRIBED_DWELL_NO_RESULTS	          = 0x00, // Do not send dwell results
               GPS_PRESCRIBED_DWELL_SEND_RESULTS          = 0x01  // Send dwell results
            } gps_prescribed_dwell_results_enum_type;	//Bit 0

            typedef enum
            {
               GPS_PRESCRIBED_DWELL_CHIPX1                = 0x00, // Chipx1
               GPS_PRESCRIBED_DWELL_CHIPX2                = 0x02  // Chipx2
            } gps_prescribed_dwell_chip_rate_enum_type;	//Bit 1

            typedef enum
			{
                GPS_PRESCRIBED_DWELL_NO_INCOHER_SUMS     = 0x00, // Do not report incoherent sums
                GPS_PRESCRIBED_DWELL_REPORT_INCOHER_SUMS  = 0x04  // Report incoherent sums
            } gps_prescribed_dwell_incoher_sums_enum_type; //Bit 2

            typedef enum
            {
                GPS_PRESCRIBED_DWELL_NO_COHER_SUMS       = 0x00, // Do not report coherent sums
                GPS_PRESCRIBED_DWELL_REPORT_COHER_SUMS    = 0x08  // Report coherent sums
            } gps_prescribed_dwell_coher_sums_enum_type; //Bit 3

            typedef enum
			{
                GPS_PRESCRIBED_DWELL_START_NOW           = 0x00, // Start now
                GPS_PRESCRIBED_DWELL_USE_TOA              = 0x0A  // Use TOA
            } gps_prescribed_dwell_start_time_enum_type; //Bit[5:4]

            typedef enum
            {
                GPS_PRESCRIBED_DWELL_USE_RF              = 0x00, // Use RF
                GPS_PRESCRIBED_DWELL_USE_TS               = 0x40  // Use TS
            } gps_prescribed_dwell_source_enum_type; //Bit 6

            typedef enum
            {
                GPS_PRESCRIBED_DWELL_NO_INIT             = 0x00, // Do not initialize TS and BC at starte of dwell
                GPS_PRESCRIBED_DWELL_INIT_TS_AND_BC       = 0x80  // Initialize TS and BC at start of dwell
            } gps_prescribed_dwell_source_init_type; //Bit 7
		\endcode
	\param iTOA				= input, Time of Applicability. GPS_RTC time at which dwell must start.
	\param iSV				= input, Satellite PRN [0..32]. If zero, correlation is codeless.
	\param iSearchMode		= input, Pre-Detection Mode.
	\param iPOST_DET_N		= input, Number of Post-Detection.
	\param iTASK_MASK1		= input, Bit31:Bit0 - Task32:Task1. A set bit implies that that task must be selected.
	\param iTASK_MASK2		= input, Bit7:Bit0 - Task40:Task33. A set bit implies that that task must be selected.
	\param iDOPP_FREQ		= input, Signed (1000/65536 Hz/Bit). Range: -32768000 to +32768000 Hz.
	\param iDOPP_FREQ_RATE	= input, Signed (1000/65536 Hz/sec/Bit). Range: -32768000 to +32768000 Hz/sec.
	\param iSUB_MS			= input, Unsigned (1/256 Chips/Bit). Range: 0 to 1023 chips.
	\param iCNO_Threshold	= input, Used for declaring dwell as a detection. Dwell result DM packet.
							  will be send only if CNo exceeds this threshold. Unsigned (0.1 dB/bit). Range: 0 to 6553.5dB.
	\param iJammerThreshold	= input, Unsigned (0.1 dB/bit). Range: 0 to 6553.5dB.

	\param piStatus			= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning The asynchronous message queue will be cleared in the course of executing this function
	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GPS_PRESCRIBED_DWELL_WithWait(
									HANDLE hResourceContext,
									unsigned short iFlags,
									unsigned long iTOA,
									unsigned char iSV,
									unsigned char iSearchMode,
									unsigned short iPOST_DET_N,
									unsigned long iTASK_MASK1,
									unsigned char iTASK_MASK2,
									unsigned long iDOPP_FREQ,
									unsigned long iDOPP_FREQ_RATE,
									unsigned long iSUB_MS,
									unsigned short iCNO_Threshold,
									unsigned short iJammerThreshold,
									unsigned char* piStatus
									);

	  /******************************************************************************/
		  /**
		  This function instructs the CGPS engine to perform one dwell on one channel.
		  It first enables the log code mask _EVENT_GPS_LM_PD_COMPLETE, enables event control,
		  clears event queue/log queue, and existing status for CGPS_Dwell_Complete, then starts a prescribed dwell.

	  	  Use QLIB_DIAG_GPS_PRESCRIBED_DWELL_CHECK_STATUS	to check completion.

		  This command will check the status field and return false if the command was rejected.

		  \param hResourceContext = Resource context that was returned from the call to ConnectServer()
		  \param iFlags 		  = input, Enables different functionalities
									Refer to these enumerations for bit mask definitions:
			  \code
				  typedef enum
				  {
					 GPS_PRESCRIBED_DWELL_NO_RESULTS			= 0x00, // Do not send dwell results
					 GPS_PRESCRIBED_DWELL_SEND_RESULTS			= 0x01	// Send dwell results
				  } gps_prescribed_dwell_results_enum_type;   //Bit 0

				  typedef enum
				  {
					 GPS_PRESCRIBED_DWELL_CHIPX1				= 0x00, // Chipx1
					 GPS_PRESCRIBED_DWELL_CHIPX2				= 0x02	// Chipx2
				  } gps_prescribed_dwell_chip_rate_enum_type; //Bit 1

				  typedef enum
				  {
					  GPS_PRESCRIBED_DWELL_NO_INCOHER_SUMS	   = 0x00, // Do not report incoherent sums
					  GPS_PRESCRIBED_DWELL_REPORT_INCOHER_SUMS	= 0x04	// Report incoherent sums
				  } gps_prescribed_dwell_incoher_sums_enum_type; //Bit 2

				  typedef enum
				  {
					  GPS_PRESCRIBED_DWELL_NO_COHER_SUMS	   = 0x00, // Do not report coherent sums
					  GPS_PRESCRIBED_DWELL_REPORT_COHER_SUMS	= 0x08	// Report coherent sums
				  } gps_prescribed_dwell_coher_sums_enum_type; //Bit 3

				  typedef enum
				  {
					  GPS_PRESCRIBED_DWELL_START_NOW		   = 0x00, // Start now
					  GPS_PRESCRIBED_DWELL_USE_TOA				= 0x0A	// Use TOA
				  } gps_prescribed_dwell_start_time_enum_type; //Bit[5:4]

				  typedef enum
				  {
					  GPS_PRESCRIBED_DWELL_USE_RF			   = 0x00, // Use RF
					  GPS_PRESCRIBED_DWELL_USE_TS				= 0x40	// Use TS
				  } gps_prescribed_dwell_source_enum_type; //Bit 6

				  typedef enum
				  {
					  GPS_PRESCRIBED_DWELL_NO_INIT			   = 0x00, // Do not initialize TS and BC at starte of dwell
					  GPS_PRESCRIBED_DWELL_INIT_TS_AND_BC		= 0x80	// Initialize TS and BC at start of dwell
				  } gps_prescribed_dwell_source_init_type; //Bit 7
			  \endcode
		  \param iTOA			  = input, Time of Applicability. GPS_RTC time at which dwell must start.
		  \param iSV			  = input, Satellite PRN [0..32]. If zero, correlation is codeless.
		  \param iSearchMode	  = input, Pre-Detection Mode.
		  \param iPOST_DET_N	  = input, Number of Post-Detection.
		  \param iTASK_MASK1	  = input, Bit31:Bit0 - Task32:Task1. A set bit implies that that task must be selected.
		  \param iTASK_MASK2	  = input, Bit7:Bit0 - Task40:Task33. A set bit implies that that task must be selected.
		  \param iDOPP_FREQ 	  = input, Signed (1000/65536 Hz/Bit). Range: -32768000 to +32768000 Hz.
		  \param iDOPP_FREQ_RATE  = input, Signed (1000/65536 Hz/sec/Bit). Range: -32768000 to +32768000 Hz/sec.
		  \param iSUB_MS		  = input, Unsigned (1/256 Chips/Bit). Range: 0 to 1023 chips.
		  \param iCNO_Threshold   = input, Used for declaring dwell as a detection. Dwell result DM packet.
									will be send only if CNo exceeds this threshold. Unsigned (0.1 dB/bit). Range: 0 to 6553.5dB.
		  \param iJammerThreshold = input, Unsigned (0.1 dB/bit). Range: 0 to 6553.5dB.

		  \param piStatus		  = output, 0=Command Accepted, 1=Command Rejected.

		  \return true if successful, false if fail.

		  \warning The asynchronous message queue will be cleared in the course of executing this function
		  *******************************************************************************/
		  QLIB_API unsigned char QLIB_DIAG_GPS_PRESCRIBED_DWELL_START(
										  HANDLE hResourceContext,
										  unsigned short iFlags,
										  unsigned long iTOA,
										  unsigned char iSV,
										  unsigned char iSearchMode,
										  unsigned short iPOST_DET_N,
										  unsigned long iTASK_MASK1,
										  unsigned char iTASK_MASK2,
										  unsigned long iDOPP_FREQ,
										  unsigned long iDOPP_FREQ_RATE,
										  unsigned long iSUB_MS,
										  unsigned short iCNO_Threshold,
										  unsigned short iJammerThreshold,
										  unsigned char* piStatus
										  );

    /******************************************************************************/
	/**
	   This function checks to see if an CGPS_Dwell_Complete event has been received.

	   \param hResourceContext			   = Resource context that was returned from the call to ConnectServer().
	   \param iOverrideTimeout_ms		= new timeout value to override the one configured using ConfigureTimeout().
	   								if iOverrideTimeout_ms < 0 or unspecified, use general timeout from ConfigureTimeout.
	   								if iOverrideTimeout_ms ==0, return immediately.
	   								if iOverrideTimeout_ms>0, it will override the one from ConfigureTimeout().

	   \return true if successful, false if fail.

	   ******************************************************************************/


	QLIB_API unsigned char QLIB_DIAG_GPS_PRESCRIBED_DWELL_CHECK_STATUS(
										HANDLE hResourceContext,
										long iOverrideTimeout_ms
										);



    /******************************************************************************/
	/**
	This function instructs the CGPS engine to start an IQ collect at a given point along
	the GPS and AFLT signal paths, and performs FFT if requested. Raw IQ values and/or
	FFT powers are output in MGP DM log packets.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext				= Resource context that was returned from the call to ConnectServer().
	\param pGPS_StartIQ_TestParams		= structure of type gps_start_iq_test_struct_type, which contains
										  all input parameters.

	\param piStatus						= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning This funciton does not collect the results using in the log message.  To do
	         so, use QLIB_DIAG_GPS_START_IQ_TEST_CollectResults()

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GPS_START_IQ_TEST(
									HANDLE hResourceContext,
									void* pGPS_StartIQ_TestParams,
									unsigned char* piStatus
									);

    /******************************************************************************/
	/**
	This function instructs the CGPS engine to start an IQ collect at a given point along
	the GPS and AFLT signal paths, and performs FFT if requested. Raw IQ values and/or
	FFT powers are output in MGP DM log packets.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext				= Resource context that was returned from the call to ConnectServer().
	\param pGPS_StartIQ_TestParams		= structure of type gps_start_iq_test_struct_type, which contains
										  all input parameters.

	\param sIQ_FileName					= File name to store IQ data.  File format is compatible with Qualcomm CGPS MatLab files.
										  If NULL or empty string, then no data will be stored to file.

	\param sFFT_FileName				= File name to store FFT data.  File format is compatible with Qualcomm CGPS MatLab files.
										  If NULL or empty string, then no data will be stored to file.

	\param piStatus						= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning The asynchronous message queue will be cleared in the course of executing this function

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GPS_START_IQ_TEST_CollectResults(
									HANDLE hResourceContext,
									void* pGPS_StartIQ_TestParams,
									char* sIQ_FileName,
									char* sFFT_FileName,
									unsigned char* piStatus
									);

	/******************************************************************************/
    /**

	This function instructs the CGPS engine to start a 60 second IQ test.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext				= Resource context that was returned from the call to ConnectServer().
	\param pGPS_StartIQ_TestParams		= structure of type gps_start_iq_test_struct_type, which contains
										  all input parameters.

	\param sIQ_FileName					= File name to store IQ data.  File format is compatible with Qualcomm CGPS MatLab files.
										  If NULL or empty string, then no data will be stored to file.

	\param sFFT_FileName				= File name to store FFT data.  File format is compatible with Qualcomm CGPS MatLab files.
										  If NULL or empty string, then no data will be stored to file.

	\param piStatus						= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	******************************************************************************/

	QLIB_API unsigned char QLIB_DIAG_GPS_START_IQ_TEST_60sec(
								HANDLE hResourceContext,
								void* pGPS_StartIQ_TestParams,
								char* sIQ_FileName,
								char* sFFT_FileName,
								unsigned char* piStatus
								);



	/******************************************************************************/
    /**

	This function checks to see if an CGPS_IQ_Test_Complete event has been received.

	\param hResourceContext				= Resource context that was returned from the call to ConnectServer().

	\return true if successful, false if fail.

	******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GPS_Check_IQ_TEST_Status( HANDLE hResourceContext );

	/******************************************************************************/
    /**

	This function closes IQ test related files if they have been opened.

	\param hResourceContext				= Resource context that was returned from the call to ConnectServer().

	******************************************************************************/
	QLIB_API void QLIB_DIAG_GPS_Close_IQ_TEST_Files( HANDLE hResourceContext );


	/******************************************************************************/
	/**
		Returns the IQ data for the last IQ Capture. This is the data reported by the mobile,
		via the IQ Data Log, ( CGPS_IQ_DATA_LOG, 0x138A)

		\param hResourceContext	= Resource context that was returned from the call to ConnectServer().

		\param pI_Samples = INPUT, pointer to buffer to store I samples, the size of the array should be size CGPS_MAX_IQ_SAMPLES_PER_CAPTURE
		\param pQ_Samples = INPUT, pointer to buffer to store Q samples, the size of the array should be size CGPS_MAX_IQ_SAMPLES_PER_CAPTURE
		\param pNumSamples = OUTPUT, returns the number of samples that were written into the pI_Samples and pQ_Samples arrays.

		\warning QLIB_DIAG_GPS_START_IQ_TEST_CollectResults() must be called first.

		\return Returns true if successful, false if fail or number of IQ samples = 0

	*******************************************************************************/
	QLIB_API unsigned char QLIB_CGPS_GetIQ_Data(
			HANDLE hResourceContext,
			char* pI_Samples,
			char* pQ_Samples,
			unsigned long* pNumSamples
			);


	/******************************************************************************/
	/**
		Returns the processed IQ data for the last IQ Capture. The processing includes adding 0.5
		to the I and Q samples and replacing each 2046th and each 20487h sample with 0.

		\param hResourceContext	= Resource context that was returned from the call to ConnectServer().

		\param hResourceContext = INPUT, pointer to buffer to store processed I samples, the size of the array should be size CGPS_MAX_IQ_SAMPLES_PER_CAPTURE
		\param pQ_ProcessedSamples = INPUT, pointer to buffer to store processed Q samples, the size of the array should be size CGPS_MAX_IQ_SAMPLES_PER_CAPTURE
		\param pNumProcessedSamples = OUTPUT, returns the number of processed samples that were written into the pI_ProcessedSamples and pQ_ProcessedSamples arrays.

		\warning QLIB_DIAG_GPS_START_IQ_TEST_CollectResults() must be called first.

		\return Returns true if successful, false if fail or number of IQ samples = 0

	*******************************************************************************/
		QLIB_API unsigned char QLIB_CGPS_GetProcessedIQ_Data(
			HANDLE hResourceContext,
			double* pI_ProcessedSamples,
			double* pQ_ProcessedSamples,
			unsigned long* pNumProcessedSamples
			);


	/******************************************************************************/
	/**
		Returns the FFT Measured data from the last IQ Capture.  Measured means that this is
		the data reported by the mobile, via the IQ Data Log, ( CGPS_IQ_DATA_LOG, 0x138A)

		\param hResourceContext	= Resource context that was returned from the call to ConnectServer().

		\param pFFT_Samples = INPUT, pointer to buffer to store FFT samples, the size of the array should be size CGPS_MAX_FFT_SAMPLES_PER_CAPTURE
		\param pNumSamples = OUTPUT, returns the number of samples that were written into the pFFT_Samples array

		\warning QLIB_DIAG_GPS_START_IQ_TEST_CollectResults() must be called first.

		\return Returns true if successful, false if fail or number of FFT samples = 0

	*******************************************************************************/
	QLIB_API unsigned char QLIB_CGPS_GetFFT_MeasuredData(
			HANDLE hResourceContext,
			unsigned short* pFFT_Samples,
			unsigned long* pNumSamples
			);

	/******************************************************************************/
	/**
		Calculate FFT based on the IQ data.

		Call QLIB_CGPS_GetFFT_CalculatedData to get the results

		\param hResourceContext	= Resource context that was returned from the call to ConnectServer().

		\warning QLIB_DIAG_GPS_START_IQ_TEST_CollectResults() must be called first.

		\return Returns true if successful, false if fail or number of FFT samples = 0

	*******************************************************************************/
	QLIB_API unsigned char QLIB_CGPS_CalculateFFT_Data( HANDLE hResourceContext );


	/******************************************************************************/
	/**
		Returns the FFT Calculated data from the last IQ Capture.  Measured means that this is
		the data reported by the mobile, via the IQ Data Log, ( CGPS_IQ_DATA_LOG, 0x138A)

		\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
		\param pFFT_Amplitude = OUTPUT, pointer to buffer to store FFT samples, the size of the array should be size CGPS_MAX_FFT_SAMPLES_PER_CAPTURE
		\param pFFT_Frequency = OUTPUT, frequency associated with each element in the pFFT_Amplitude array should be size CGPS_MAX_FFT_SAMPLES_PER_CAPTURE
		\param iNumSamples = OUTPUT, returns the number of samples that were written into the pFFT_Samples array

		\warning QLIB_DIAG_GPS_START_IQ_TEST_CollectResults() and QLIB_CGPS_CalculateFFT_Data() must be called first.

		\return Returns true if successful, false if fail or number of FFT samples = 0

	*******************************************************************************/
	QLIB_API unsigned char QLIB_CGPS_GetFFT_CalculatedData(
			HANDLE hResourceContext,
			double* pFFT_Amplitude,
			double* pFFT_Frequency,
			unsigned long* iNumSamples
			);

	/******************************************************************************/
	/**
			Clear the IQ data for the last IQ Capture to release memory.

			\param hResourceContext = Resource context that was returned from the call to ConnectServer().
			\warning QLIB_CGPS_GetIQ_Data
					/QLIB_CGPS_GetProcessedIQ_Data
					/QLIB_CGPS_GetFFT_MeasuredData
					QLIB_CGPS_CalculateFFT_Data cannot be called after this function as the memory is cleared.

			\return Returns true if successful, false if fail or number of IQ samples = 0

		*******************************************************************************/
		QLIB_API unsigned char QLIB_CGPS_ClearIQ_Data(
				HANDLE hResourceContext	);

	/******************************************************************************/
	/**
	This function instructs the CGPS engine to track the specified SV or all the SVs depending on the input command. The test can be stopped
	using appropriate command parameters (see below).

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext				= Resource context that was returned from the call to ConnectServer().
	\param iSV							= input.	Satellite PRN [0:32]. If zero (GPS_SV_TRACK_ALL), operation is track all SVs.
	\param iCommand						= input.	defined by gps_sv_track_command_enum_type:
		\code
           GPS_SV_TRACK_START_CLEAR_ALL	= 0
           GPS_SV_TRACK_START_NO_CLEAR	= 1
           GPS_SV_TRACK_STOP_CLEAR_ALL	= 2
           GPS_SV_TRACK_STOP_NO_CLEAR	= 3
           GPS_SV_TRACK_START_CLEAR_ALL_NO_BITEDGE_DETECTION = 5
           GPS_SV_TRACK_START_NO_CLEAR_NO_BITEDGE_DETECTION = 6

        \endcode

	\param piStatus						= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GPS_SV_TRACK(
									HANDLE hResourceContext,
									unsigned char iSV,
									unsigned char iCommand,
									unsigned char* piStatus
									);



	/******************************************************************************/
    /**

    This function instructs the CGPS GEN8 engine to track GNSS SV's as specified
	by SvTrackParams input parameters. The test can also be stopped using appropriate
    command parameters.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param SvTrackParams	= input. A structure containing Multi-Channel Tracking Test parameters.  Please refer to CGPS_Gen8_SvTrack_Struct_type in QLib_Defines.h
    \endcode

	\param piStatus						= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GPS_GEN8_SV_TRACK(
								HANDLE hResourceContext,
								void *SvTrackParams,
								unsigned char* piStatus
								);

	/******************************************************************************/
    /**

    This function sends the CGPS GEN8 engine HW Configure command to the phone.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param HwConfigParams	= input. A structure containing HW Configure command parameters.  Please refer to CGPS_Gen8_HwConfig_Struct_type in QLib_Defins.h
    \endcode

	\param piStatus			= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GPS_GEN8_HW_CONFIG(
								HANDLE hResourceContext,
								void* HwConfigParams,
								unsigned char* piStatus
								);

    /******************************************************************************/
    /**

    This function sends the CGPS GEN8 engine PRx RF Mode DM command to the phone.

    This command will check the status field and return false if the command was rejected.

    \param hResourceContext	= Resource context that was returned from the call to ConnectServer().
    \param PRx_Mode	= input. A CGPS_Gen8_Rx_RfMode_Struct_type structure containing PRx RF Mode command parameters.  Please refer to
	CGPS_Gen8_Rx_RfMode_Struct_type in QLib_Defines.h

	\endcode

    \return true if successful, false if fail.

    \warning

    *******************************************************************************/

    QLIB_API unsigned char QLIB_GPS_GEN8_PRx_Mode_Config (
                        HANDLE hResourceContext,
                        void *PRx_Mode
                        );

    /******************************************************************************/
    /**

    This function sends the CGPS GEN8 engine RF Linearity Config DM command to the phone.

    This command will check the status field and return false if the command was rejected.

    \param hResourceContext	= Resource context that was returned from the call to ConnectServer().
    \param DRx_On_Off_Config = input. A CGPS_Gen8_Rf_Linearity_Config_Struct_type structure containing RF Linearity Config command parameters .
    \endcode

    \return true if successful, false if fail.

    \warning

    *******************************************************************************/
    QLIB_API unsigned char QLIB_GPS_GEN8_RF_Linearity_Config(
                        HANDLE hResourceContext,
                        void *RF_Linearity_Config
                        );


	/******************************************************************************/
    /**

    This function Initilizes a specific GPS PDAPI client.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param FixCollectionParams	= input. A structure containing GPS PD Configuration parameters .

	\param iStatus			= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_PDAPI_INITIALIZE(
								HANDLE hResourceContext,
								void* FixCollectionParams,
								unsigned char* piStatus
								);

	/******************************************************************************/
    /**

    This function registers or deregisters GPS PD related callbacks and events.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param FixCollectionParams	= input. A structure containing GPS PD Configuration parameters .

	\param iStatus			= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_PDAPI_REGISTER_PD(
								HANDLE hResourceContext,
								void* FixCollectionParams,
								unsigned char* piStatus
								);

	/******************************************************************************/
    /**

    This function activates a specific PDAPI client, so that it will be notified of Session Manager
    events for which it is registered.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param FixCollectionParams	= input. A structure containing GPS PD Configuration parameters .

	\param iStatus			= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_PDAPI_ACTIVATE (
								HANDLE hResourceContext,
								void* FixCollectionParams,
								unsigned char* piStatus
								);

	/******************************************************************************/
    /**

    This function deactivates a particular PDAPI client, so that it will not be notified of
    Session Manager events for which it is registered.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param FixCollectionParams	= input. A structure containing GPS PD Configuration parameters .

	\param iStatus			= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_PDAPI_DEACTIVATE (
								HANDLE hResourceContext,
								void* FixCollectionParams,
								unsigned char* piStatus
								);

	/******************************************************************************/
    /**

    This function releases a specific PDAPI client when it no longer needs the Session Manager.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param FixCollectionParams	= input. A structure containing GPS PD Configuration parameters .

	\param iStatus			= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_PDAPI_RELEASE(
								HANDLE hResourceContext,
								void* FixCollectionParams,
								unsigned char* piStatus
								);

	/******************************************************************************/
    /**

    This function requests the target to start a CGPS session with the specified parameters.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param FixCollectionParams	= input. A structure containing GPS PD Configuration parameters .

	\param iStatus			= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_PDAPI_START(
								HANDLE hResourceContext,
								void* FixCollectionParams,
								unsigned char* piStatus
								);

    /******************************************************************************/
    /**

    This function requests the target to end an ongoing CGPS session with the specified parameters.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param FixCollectionParams	= input. A structure containing GPS PD Configuration parameters .

	\param iStatus			= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_PDAPI_END(
								HANDLE hResourceContext,
								void* FixCollectionParams,
								unsigned char* piStatus
								);

	/******************************************************************************/
    /**

    This function requests the target to set configuration parameters in either the NV or
    Session Manager.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param FixCollectionParams	= input. A structure containing GPS PD Configuration parameters .

	\param iStatus			= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_PDAPI_SET_PARAM(
								HANDLE hResourceContext,
								void* FixCollectionParams,
								unsigned char* piStatus
								);

	/******************************************************************************/
	/**
	This function instructs the CGPS GEN 8 engine to start an IQ collect, performs FFT
	if requested. Raw IQ values and/or FFT powers are output in MGP DM log packets.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext				= Resource context that was returned from the call to ConnectServer().
	\param pGPS_StartIQ_TestParams		= structure of type CGPS_Gen8_StartIqTest_struct_type, which contains
										  all input parameters.

	\param piStatus						= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning This funciton does not collect the results using in the log message.  To do
	         so, use QLIB_DIAG_GPS_START_IQ_TEST_CollectResults()

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GPS_GEN8_START_IQ_TEST(
								HANDLE hResourceContext,
								void* pGPS_StartIQ_TestParams,
								unsigned char* piStatus);

    /******************************************************************************/
	/**
	This function instructs the CGPS Gen 8 engine to start an IQ collect and performs
	FFT if requested. Raw IQ values and/or FFT powers are output in MGP DM log packets.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext				= Resource context that was returned from the call to ConnectServer().
	\param pGPS_StartIQ_TestParams		= structure of type CGPS_Gen8_StartIqTest_struct_type, which contains
	 									  all input parameters.	Supportted collect modes include:

											1  WBIQ LBW-GPS (2.046 MHz sample rate)
											3  WBIQ GLO     (1.022 MHz sample rate)
											4  FBIQ HBW-GPS (20.46 MHz sample rate)

	\param sIQ_FileName					= File name to store IQ data.  File format is compatible with Qualcomm CGPS MatLab files.
										  If NULL or empty string, then no data will be stored to file.

	\param sFFT_FileName				= File name to store FFT data.  File format is compatible with Qualcomm CGPS MatLab files.
										  If NULL or empty string, then no data will be stored to file.

	\param piStatus						= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning The asynchronous message queue will be cleared in the course of executing this function

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GPS_GEN8_START_IQ_TEST_CollectResults(
								HANDLE hResourceContext,
								void* pGPS_StartIQ_TestParams,
								char* sIQ_FileName,
								char* sFFT_FileName,
								unsigned char* piStatus);



	/******************************************************************************/
    /**

	This function instructs the CGPS engine to start a 60 second IQ test.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext				= Resource context that was returned from the call to ConnectServer().
	\param pGPS_StartIQ_TestParams		= structure of type CGPS_Gen8_StartIqTest_struct_type, which contains
										  all input parameters.

	\param sIQ_FileName					= File name to store IQ data.  File format is compatible with Qualcomm CGPS MatLab files.
										  If NULL or empty string, then no data will be stored to file.

	\param sFFT_FileName				= File name to store FFT data.  File format is compatible with Qualcomm CGPS MatLab files.
										  If NULL or empty string, then no data will be stored to file.

	\param piStatus						= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	******************************************************************************/

	QLIB_API unsigned char QLIB_DIAG_GPS_Gen8_START_IQ_TEST_60sec(
								HANDLE hResourceContext,
								void* pGPS_StartIQ_TestParams,
								char* sIQ_FileName,
								char* sFFT_FileName,
								unsigned char* piStatus
								);

	/******************************************************************************/
	/**
	This function instructs the CGPS engine to perform one dwell on one channel.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param PrescribedDwellParams= Pointer to a structure containing the Prescribed Dwell command paramters.
	Please refer to CGPS_Gen8_PrescribedDwell_struct_type in QLib_Defines.h


	\param piStatus			= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning This version of the function does not wait for the response event. To wait for
	         the event use QLIB_DIAG_GPS_PRESCRIBED_DWELL_WithWait

	*******************************************************************************/

	QLIB_API unsigned char QLIB_DIAG_GPS_GEN8_PRESCRIBED_DWELL(
								HANDLE hResourceContext,
								void * PrescribedDwellParams,
								unsigned char* piStatus
								);

	/******************************************************************************/
	/**
	This function instructs the CGPS engine to perform one dwell on one channel, then
	wait for the corresponding event, EVENT_GPS_LM_PD_COMPLETE, #1250.

	The timeout value for waiting for the event can be set using QLIB_ConfigureTimeOut() and the
	timeout type of QMSL_Timeout_CGPS_Event.

	This command will check the status field and return false if the command was rejected.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer()
	\param PrescribedDwellParams = input, A structure containing the prescrbed dwell
		                           command parameters.  Please refer to CGPS_Gen8_PrescribedDwell_struct_type in QLib_Defines.h

	\param piStatus			= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning The asynchronous message queue will be cleared in the course of executing this function
	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GPS_GEN8_PRESCRIBED_DWELL_WithWait(
								HANDLE hResourceContext,
								void * PrescribedDwellParams,
								unsigned char* piStatus
								);


	/******************************************************************************/
	/**
		Clear the status of the entire CGPS status object
		\param hResourceContext	= Resource context that was returned from the call to ConnectServer().

		\return Returns true if successful, false if fail

	*******************************************************************************/
	QLIB_API unsigned char QLIB_CGPS_ClearStatus( HANDLE hResourceContext );

	/******************************************************************************/
	/**
		Clear a specific status element of the CGPS status

		\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
		\param eStat = the type of status to clear, type is QMSL_CGPS_Event_Enum from QLibDefines.h
		\return Returns true if successful, false if fail

	*******************************************************************************/
	QLIB_API unsigned char QLIB_CGPS_ClearStatus_Specific( HANDLE hResourceContext, unsigned long eStat );

	/******************************************************************************/
	/**
		Copy the status into the user supplied GSM BER Status structure

		\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
		\param pCGPS_Status is a structure of type "CGPS_Status_Struct*"

		\return Returns true if successful, false if fail

	*******************************************************************************/
	QLIB_API unsigned char QLIB_CGPS_GetStatus( HANDLE hResourceContext, void* pCGPS_Status );

	/******************************************************************************/
	/**
	Starts the async messages (logs and events) associated with CGPS.  These logs are:
	\code
         CGPS_IQ_DATA_LOG = 0x138A
		 CGPS_RF_STATUS_REPORT_LOG 0x1372

	\endcode

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param bEnableEvents = true to enable CGPS events, false to disable.  The events that will be enabled are:
	\code
       _EVENT_GPS_PD_COMM_FAILURE      = 1241,
       _EVENT_GPS_PD_COMM_DONE         = 1242,
       _EVENT_GPS_PD_EVENT_END         = 1243,
       _EVENT_GPS_PA_EVENT_CALLBACK    = 1244,
       _EVENT_GPS_PD_CMD_ERR_CALLBACK  = 1245,
       _EVENT_GPS_PA_CMD_ERR_CALLBACK  = 1246,
       _EVENT_GPS_LM_ENTER_SA_RF_VERIF = 1247,
       -EVENT_GPS_LM_EXIT_SA_RF_VERIF  = 1248,
       _EVENT_GPS_LM_ERROR_SA_RF_VERIF = 1249,
       _EVENT_GPS_LM_PD_COMPLETE       = 1250,
       _EVENT_GPS_LM_IQ_TEST_COMPLETE  = 1251,
       _EVENT_GNSS_PRESC_DWELL_COMPLETE = 1717

	\endcode

	\param piStatus						= output, 0=Command Accepted, 1=Command Rejected.

	\return true if successful, false if fail.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_GPS_StartCGPS_AsyncMessages(
									HANDLE hResourceContext,
									unsigned char bEnableEvents
									);

	/******************************************************************************/
	/**
	Performs a CW SNR measurment by using other CGPS functions:
		- Optionally activates/deactivates CGPS test mode using QLIB_DIAG_GPS_SA_RF_VERIF_MODE_SWITCH_WithWait()
		- Captures Wideband IQ data using QLIB_DIAG_GPS_START_IQ_TEST()
		- Calculates FFT using QLIB_CGPS_CalculateFFT_Data()
		- Gets the FFT results using QLIB_CGPS_GetFFT_CalculatedData()
		- Peforms a peak search and C/N calculation using the FFT data

	This function is designed to be used for factory testing, for quick verification of the GPS path.
	It replaces functionality that is not longer available in QLIB_FTM_GET_CTON()

	The input signal needs to be a CW that is offset from the center frequency by at least 100kHz and is between
	-120dBm and -100dBm.  -110dBm is suggested.

	For troubleshooting, it is possible to enable a text file to log the IQ data in a format that a Matlab script
	will be able to parse.  To use the Matlab script:
	\code
		cgps_IqTest_IqFileProc( 6.0, 100, -120, 'c:\CGPS_SNR_IQ_Capture.txt' )

		For this case,
		RF_NoiseFigure = 6.0dB
		SigFreqKhz = 100kHz
		SigLevelDbm = -120.0dBm
		FileName = c:\CGPS_SNR_IQ_Capture.txt

	\endcode

	The SNR calculation is exactly as found the CGPS Matlab script named, ""

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param iCaptureSize_kSamples = input, capture size in kilo samples. 1 to 32, in powers of 2 (1,2,4,8, etc.)
	\param iAutoSetGPS_VerificationMode = input, true to set the GPS Verification mode ON before the capture and OFF after the capture
											if true, the CGPS timeout will automatically be set to 15 seconds using the function QLIB_ConfigureTimeOut()
	\param sIQ_FileName = input, file name to store a text file which can be used by the MatLab script, cgps_IqTest_FftFileProc.m
							if NULL, then no file will be created.
	\param iNumberOfIntegrations = number of integrations (separate embedded IQ captures) to use.  The higher the number of integrations,
	                               the more the noise will be reduced by the averaging affect.  The minimum number of integrations is 1.
								   The maximum number of integrations is 10.
	\param pdSNR = output, pointer to storage for the output results


	\return true if successful, false if fail.

	\warning if iAutoSetGPS_VerificationMode==1 then this function will increase the CGPS timeout to 15 seconds:
	\code
       QLIB_ConfigureTimeOut(g_hResourceContext, QMSL_Timeout_CGPS_Event, 15000 )
	\endcode

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_CGPS_SNR(
									HANDLE hResourceContext,
									unsigned short iCaptureSize_kSamples,
									unsigned char  iAutoSetGPS_VerificationMode,
									unsigned short iNumberOfIntegrations,
									char* sIQ_FileName,
									double* pdSNR
									);
   /******************************************************************************/
	/**
	Commands the mobile to start a WB I/Q capature and returns C/N calculated by mobile

		- Optionally activates/deactivates CGPS test mode using QLIB_DIAG_GPS_SA_RF_VERIF_MODE_SWITCH_WithWait()
		- Captures Wideband IQ data using QLIB_DIAG_GPS_START_IQ_TEST()
	    - Returns the C/N and frequency bin calculated by embedded side

    Note: Please note that C/N or SNR returned is expected to be different from the one returned by QLIB_DIAG_CGPS_SNR.
	It is because the two functions use different alogorithm to compute SNR.

	This function is designed to be used for factory testing, for quick verification of the GPS path.
	It replaces functionality that is not longer available in QLIB_FTM_GET_CTON()

	The function requires that embedded side to be able to return C/N via LOG_CGPS_WB_FFT_STATS_C (0x1487).

	The input signal needs to be a CW that is offset from the center frequency by at least 100kHz and is between
	-120dBm and -100dBm.  -110dBm is suggested.

	For more information, please refer to 80-VR679-1 (C/N0 Measurement Method for GPS Testing on Production Line)

	For troubleshooting, it is possible to enable a text file to log the IQ data in a format that a Matlab script
	will be able to parse.  To use the Matlab script:
	\code
		cgps_IqTest_IqFileProc( 6.0, 100, -120, 'c:\CGPS_SNR_IQ_Capture.txt' )

		For this case,
		RF_NoiseFigure = 6.0dB
		SigFreqKhz = 100kHz
		SigLevelDbm = -120.0dBm
		FileName = c:\CGPS_SNR_IQ_Capture.txt

	\endcode

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param iCaptureSize_kSamples = input, capture size in kilo samples. 1 to 32, in powers of 2 (1,2,4,8, etc.)
	\param iAutoSetGPS_VerificationMode = input, true to set the GPS Verification mode ON before the capture and OFF after the capture
											if true, the CGPS timeout will automatically be set to 15 seconds using the function QLIB_ConfigureTimeOut()
	\param sIQ_FileName = input, file name to store a text file which can be used by the MatLab script, cgps_IqTest_FftFileProc.m
							if NULL, then no file will be created.
	\param iNumberOfIntegrations = number of integrations (separate embedded IQ captures) to use.  The higher the number of integrations,
	                               the more the noise will be reduced by the averaging affect.  The minimum number of integrations is 1.
								   The maximum number of integrations is 10.
	\param pdCNoDBHz = output, pointer to Signal strength calculated in dBHz as part of WBIQ test
	\param piFreqInHz = output, pointer to Frequency in Hz calculated as part of WBIQ test

	\return true if successful, false if fail.

	\warning if iAutoSetGPS_VerificationMode==1 then this function will increase the CGPS timeout to 15 seconds:
	\code
       QLIB_ConfigureTimeOut(g_hResourceContext, QMSL_Timeout_CGPS_Event, 15000 )
	\endcode

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_CGPS_GET_EMBEDDED_CALCULATED_CTON(
									HANDLE hResourceContext,
									unsigned short iCaptureSize_kSamples,
									unsigned char  iAutoSetGPS_VerificationMode,
									unsigned short iNumberOfIntegrations,
									char* sIQ_FileName,
									double* pdCNoDBHz,
									int*    piFreqInHz
									);

   /******************************************************************************/
	/**
    Requests the phone to return the GPS C/No(dB) and frequency offset(Hz) calculated by embedded side.
    For more information, please refer to "DM Command to get C/No for testing GEN8 GPS at Production Line", 80-VU919-1 A.

    This function is designed to be used for factory testing, for quick verification of the GPS path.
    It replaces functionality that is not longer available in QLIB_FTM_GET_CTON()

    The function requires that embedded side to be able to return C/No via LOG_CGPS_WB_FFT_STATS_C (0x1487).
    QLIB_DIAG_GPS_SA_RF_VERIF_MODE_SWITCH_WithWait(GPS_SA_RF_VERIF_MODE_SWITCH_ENTER_MODE) must be called first, with the RF signal disabled.

    The input signal needs to be a CW that is offset from the center frequency by at least 100kHz and is between
    -120dBm and -100dBm.  -110dBm is suggested.

	To configure the timeout, use QLIB_ConfigureTimeOut(QMSL_Timeout_CGPS_Event, timeout) to configure.

    \param hResourceContext	= Resource context that was returned from the call to ConnectServer().
    \param iCollectMode          = input, defines the collect point of I/Q samples, see the definition of gps_start_iq_test_collect_mode_gen8.
    \param iCaptureSize_kSamples = input, capture size in kilo samples. 1 to 32, in powers of 2 (1,2,4,8, etc.)
    \param iNumberOfIntegrations = number of integrations (separate embedded I/Q captures) to use.  The higher the number of integrations,
                                    the more the noise will be reduced by the averaging affect.  The minimum number of integrations is 1.
	                                The maximum number of integrations is 10.
    \param pdCNoDBHz = output, pointer to C/No calculated in dB.
    \param piFreqInHz = output, pointer to Frequency offset in Hz.

    \return true if successful, false if fail.
    *******************************************************************************/
    QLIB_API unsigned char QLIB_DIAG_GEN8_GET_EMBEDDED_CALCULATED_CTON(
                                    HANDLE hResourceContext,
                                    unsigned char iCollectMode,
                                    unsigned short iCaptureSize_kSamples,
                                    unsigned char iNumberOfIntegrations,
                                    double* pdCNoDBHz,
                                    int* piFreqInHz
                                    );

	/******************************************************************************/
	/**
	Execute binary form of the MATLAB script that is used for CGPS IQ processing.

	The MATLAB script name is: CGPS_IqTest_IqFileProc.m
	The compiled binary form of the MATLAB script is: CGPS_IqTest_IqFileProc.exe
	The "Component Technology File" is: CGPS_IqTest_IqFileProc.ctf

	Both the .EXE and .CTF must be in the same folder as the QMSL client executable file or
	those two files must be in the system path.

	The purpose of this function is to simplify the process for a C program to call the .EXE file.
	It is always possible to bypass this function and call the .EXE directly in your C program.

	This process will run in a blocking fashion, meaning that the function will not return until
	all of the MATLAB processing has been completed.

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param dRF_NoiseFigure_dB = input, expected noise figure, dB
	\param dSigFreq_kHz = input, CW offset from center frequency, kHz
	\param dSigLevel_dBm = input, CW power level at the mobile input, dBm
	\param sIQ_FileName = input, file name of text file that holds IQ data/.
							This is the same file passed as the sIQ_FileName paremter to
							QLIB_DIAG_GPS_START_IQ_TEST_CollectResults()
	\param sOutputFolder = folder where MATLAB output files should be stored
	\param bAutoClose = TRUE to close the MATLAB graph windows, FALSE to keep them open
						If set to TRUE then the MATLAB graph windows will not be shown.
	\param sStandardOutputFile = file name to store standard output into. If NULL then standard output will not be stored
	\param bWaitForCompletion = wait for the child process to complete before returning from this function
	\param iPhoneState = call state. 0 = OoS, 1 = WCDMA in-service OR GSM Idle, 2 = GSM Traffic, 3 = 1x
	\param sStdFolder = path name to store standard output into for Matlab. If NULL then standard output will not be stored


	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_CGPS_MATLAB_IQ_FILE_PROC(
									HANDLE hResourceContext,
									double dRF_NoiseFigure_dB,
									double dSigFreq_kHz,
									double dSigLevel_dBm,
									char* sIQ_FileName,
									char* sOutputFolder,
									unsigned char bAutoClose,
									char* sStandardOutputFile,
									unsigned char bWaitForCompletion,
									unsigned char iPhoneState,
									const char* sStdFolder
										);

	/******************************************************************************/
	/**
	Execute binary form of the MATLAB script that is used for CGPS IQ processing.

	The MATLAB binary is invoved using a COM object which requires a QMSL DLL to be
	registered using regsvr32

	File: QMSL_MATLAB_Interface.DLL
	uuid = 7EEA2D69-0CAE-40B8-B3A1-9D31F65FE46B
	interface name = QMSL_MATLAB Interface


	The MATLAB script name is: CGPS_IqTest_IqFileProc.m
	The compiled binary form of the MATLAB script is: QMSL_Matlab_Generic.dll
	The "Component Technology File" is: QMSL_Matlab_Generic.ctf

	Both the .DLL and .CTF must be in the same folder as the QMSL client executable file or
	those two files must be in the system path.

	This process will run in a blocking fashion, meaning that the function will not return until
	all of the MATLAB processing has been completed.

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
	\param dRF_NoiseFigure_dB = input, expected noise figure, dB
	\param dSigFreq_kHz = input, CW offset from center frequency, kHz
	\param dSigLevel_dBm = input, CW power level at the mobile input, dBm
	\param sIQ_FileName = input, file name of text file that holds IQ data/.
							This is the same file passed as the sIQ_FileName paremter to
							QLIB_DIAG_GPS_START_IQ_TEST_CollectResults()
	\param sOutputFolder = folder where MATLAB output files should be stored
	\param bAutoClose = TRUE to close the MATLAB graph windows, FALSE to keep them open
						WARNING: if autoclose is set to false, it is possible to receive MATLAB exception
						after the file processing is completed. The only supported setting is for bAutoClose = true
						If set to TRUE then the MATLAB graph windows will not be shown.

	\param iPhoneState = call state. 0 = OoS, 1 = WCDMA in-service OR GSM Idle, 2 = GSM Traffic, 3 = 1x
	\param sStdFolder = path name to store standard output into for COM interface and Matlab. If NULL then standard output will not be stored


	\return true if successful, false if fail.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_CGPS_MATLAB_IQ_FILE_PROC_COM(
									HANDLE hResourceContext,
									double dRF_NoiseFigure_dB,
									double dSigFreq_kHz,
									double dSigLevel_dBm,
									char* sIQ_FileName,
									char* sOutputFolder,
									unsigned char bAutoClose,
									unsigned char iPhoneState,
									const char* sStdFolder
									);

	/******************************************************************************/
	/**
	Execute binary form of the MATLAB script that is used for GNSS Gen8 (Callisto) IQ processing.

	The MATLAB script names are: gnss_IqTest_IqFileProc.m, gnss_IqTest_JammerProc.m
	The compiled binary form of the MATLAB script is: gnss_IqTest_IqFileProc.dll
	The "Component Technology File" is: gnss_IqTest_IqFileProc.ctf
	The MATLAB binary is invoked using a COM object which requires a QMSL DLL to be
	registered using regsvr32

	File: QMSL_MATLAB_Interface.DLL
	uuid = 7EEA2D69-0CAE-40B8-B3A1-9D31F65FE46B
	interface name = QMSL_MATLAB Interface

	The MATLAB script names are: gnss_IqTest_IqFileProc.m, gnss_IqTest_JammerProc.m
	The compiled binary form of the MATLAB script is: QMSL_Matlab_Generic.dll
	The "Component Technology File" is: QMSL_Matlab_Generic.ctf

	Both the .DLL and .CTF must be in the same folder as the QMSL client executable file or
	those two files must be in the system path.

	This process will run in a blocking fashion, meaning that the function will not return until
	all of the MATLAB processing has been completed.

	\param hResourceContext	= Resource context that was returned from the call to ConnectServer().
    \param iPhoneState = phone state.
        iPhoneState = 100*gnssSig + 10*nwType + nwCond
        gnssSig:(1) GPS / (2) GLO
        nwType: (1) 1X / (2) WCDMA / (3) GSM / (4) Unconnected
        nwCond: (1) OoS/UnConnected
                (2) Idle
                (3) Traffic
        Note: Multimode OoS should be tested with nwType = 2 or 3.
	\param dSigFreq_kHz = input, CW offset from center frequency, kHz
	\param dSigLevel_dBm = input, CW power level at the mobile input, dBm
	\param sIQ_FileName = input, file name of a .bin file that holds IQ data/.
	\param sOutputFolder = folder where MATLAB output files should be stored
	\param bAutoClose = TRUE to close the MATLAB graph windows, FALSE to keep them open
						WARNING: if autoclose is set to false, it is possible to receive MATLAB exception
						after the file processing is completed. The only supported setting is for bAutoClose = true
						If set to TRUE then the MATLAB graph windows will not be shown.
	\param sStdFolder = path name to store standard output into for COM interface and Matlab. If NULL then standard output will not be stored
	\return true if successful, false if fail.
	*******************************************************************************/
	QLIB_API unsigned char QLIB_GNSS_MATLAB_IQ_FILE_PROC_COM(
									HANDLE hResourceContext,
									unsigned long iPhoneState,
									double dSigFreq_kHz,
									double dSigLevel_dBm,
									char* sIQ_FileName,
									char* sOutputFolder,
									unsigned char bAutoClose,
									const char* sStdFolder
									);

	/******************************************************************************/
	/**
	Execute binary form of the MATLAB script that is used to plot a figure.

	The MATLAB binary is invoved using a COM object which requires a QMSL DLL to be
	registered using regsvr32

	File: QMSL_MATLAB_Interface.DLL
	uuid = 7EEA2D69-0CAE-40B8-B3A1-9D31F65FE46B
	interface name = QMSL_MATLAB Interface

	The MATLAB script name is: qmsl_matlab_plot.m, print_to_error.m, and remove_special_string.m
	The compiled binary form of the MATLAB script is: QMSL_Matlab_Generic.dll
	The "Component Technology File" is: QMSL_Matlab_Generic.ctf
	Both the .DLL and .CTF must be in the same folder as the QMSL client executable file or
	those two files must be in the system path.

	This process will run in a blocking fashion, meaning that the function will not return until
	all of the MATLAB processing has been completed.

	\param hResourceContext = Resource context that was returned from the call to ConnectServer().
	\param sFileName = input, name of file containing the data to plot. must follow the required format. see below note.
	\param sOutputPath = path (inc. file name) where MATLAB output files should be stored
	\param sStdFolder = path name to store standard output into. If NULL then standard output will not be stored
	\param bBackGround = TRUE, the MATLAB graph windows will not be shown.
	\return true if successful, false if fail.

	\IMPORTANT: Input file must follow format below:
	line 1: figure title = string.
	line 2: figure x-label = string.
	line 3: figure y-label = string.
	line 4: figure legend = string. If you have multiple lines to plot 	in same figure,
	          use legend to give each line a name. Use";" to delim them.
	line 5: user defined text to display to figure.
	line 6: figure style, default is "plot" options include "plot" and "bar" (must be lower case)
	line 7 - 10: reserved. user data file should fill with emtpy lines for future backward compatibility.
	begin of data: use a line starting with ***
	data format per line:x(1) [] y(1)\n. Note [] represents for space. you must make
	sure there are no extra spaces except the one separate x and y coordinates.
	If you have multiple lines to plot in figure, please use another *** to start another data
	section, immediately in the line following last data section.

	An Example of input file:
		line1: BP amplitude vs time. 											//title.
		line2: Time in seconds 												//x-label and unit
		line3: BP Amp [dB] 												//y-label and unit
		line4: BP Amp I data;BP Amp Q data 									//legend: totally two lines.
		line5: Technology=CDMA, band=CDMA 800,channel=18 					//user defined text, optional
		line6: plot														//optional, use lower case "plot" or "bar" (without quote)
		line 7- 10: empty.													//reserved
		line11: *** 														//indicator of starting of data section
		line12: 0.000 53.000
		line13: 2.094 58.500
		......
			    4.187 58.000
		line#: ***														//inication of another data section begin
			   10.469 58.500
			   12.562 59.500

	*******************************************************************************/

	QLIB_API unsigned char QLIB_MATLAB_GENERIC_PLOT_COM(
									HANDLE hResourceContext,
									char* sFileName,
									char* sOutputPath,
									char* sStdFolder,
									unsigned char bBackGround
									);

	/******************************************************************************/

	/******************************************************************************
						SHDR - SGPS Subsystem
*******************************************************************************/
	/**
	Enables measurement logs for the SHDR/ SGPS Testing.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param iLogMask = 	The logs can be enabled with a bit mask as defined by FTM_SHDR_MeasurementLogs_Enum.

		The mask values are as follows:
		\code
					0x01 = TRM Response (0x12E8)
					0x02 = 1x Paging MER Log
					0x04 = 1x FTM AGC log for Primary chain
					0x08 = 1x FTM AGC log for Secondary chain
					0x16 = EVDO FTM AGC log for Primary chain
					0x32 = EVDO FTM AGC log for Secondart chain
		\endcode

	\return true if successful, false if fail.

	\warning Will clear status of all the enabled logs

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SHDR_SGPS_EnableMeasurementLogs(
									HANDLE hResourceContext,
									unsigned char iLogMask );
/*******************************************************************************/
	/**
	Gets measurement logs for the SHDR/ SGPS Testing.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\param pSHDR_SGPS_MeasLogs

	\return true if successful, false if fail.

	\warning Will clear status of all the enabled logs

	*******************************************************************************/

	QLIB_API unsigned char QLIB_FTM_SHDR_SGPS_GetMeasurementLogs(
							HANDLE hResourceContext,
							void* pSHDR_SGPS_MeasLogs,
							long log_mask);

	/******************************************************************************/




/******************************************************************************
						ISDB-T DIAG
*******************************************************************************/

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.2 Subcommand 100

		This command tells ISDB-T L1 to acquire on the given frequency, mode and guard.
		ISDB-T L1 must be powered up via QLIB_DIAG_ISDB_UBM_L1_POWERUP_CMD() before this command is sent.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iFrequency = Frequency to acquire. Value in Hz/10

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning  Must call QLIB_DIAG_ISDB_UBM_L1_POWERUP_CMD() first.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_ACQ_CMD(HANDLE hResourceContext,
														 unsigned long iFrequency);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.3 Subcommand 101

		This command stops the DSP and puts ISDB layer state machine in reset

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_RESET_CMD(HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.4 Subcommand 102

		This function returns the acquisition state of ISDB-T L1

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piAcquisition_sucess = pointer to the location to store the acquestion status
								   0 indicates acquisition failed (mode and guard invalid)
								   1 indicates acquisition succeeded
	\param piMode = Pointer to location to store the mode of the acquired signal.
		Defined by ubm_isdb_mode in QLib_Defines.h:
		\code
		ISDB_UBM_L1_MODE_2 = 2
		ISDB_UBM_L1_MODE_3 = 3
		\endcode
	\param piGuard = Pointer to location to store the guard of the acquired signal.
		Defined by ubm_isdb_guard in QLib_Defines.h:
		\code
		ISDB_UBM_L1_GUARD_4		= 0
		ISDB_UBM_L1_GUARD_8		= 1
		ISDB_UBM_L1_GUARD_16	= 2
		\endcode

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_ACQ_STATUS (HANDLE hResourceContext,
															 unsigned char *piAcquisition_success,
															 unsigned char *piMode,
															 unsigned char *piGuard );

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.5 Subcommand 103

		This command powers up the MBP receiver and initializes ISDB-T L1.
		This command should be called before any other ISDB-T L1 non-signaling commands.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_POWERUP_CMD (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.6 Subcommand 104

		This command powers down L1.
		This command should be called when exiting ISDB-T non-signalling mode.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_POWERDOWN_CMD (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.7 Subcommand 105

		This command routes the Y1Y2 samples to the debug bus.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_ROUTE_Y1Y2_DEBUG_BUS (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.8 Subcommand 106

		This command collects packet counter statistics regarding tsif packets arrived.
		This command is preserved for compatibility - it is recommended to use
		UBM_L1_ISDB_RS1_PACKET_CNT_V2_CMD (140) instead.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iRs1PacketCount = pointer to store the RS1 packet counter
	\param iRs1TrashedPacketCount = pointer to store the RS1 trashed packet counter

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_RS1_PACKET_CNT_CMD (HANDLE hResourceContext,
																	 unsigned long* piRs1PacketCount,
																	 unsigned long* piRs1TrashedPacketCount);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.9 Subcommand 107

		This command records a given amount of tsif packets and saves them into a file in the efs
		(history of theses files is not save)

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iNumOfPackets = Number of tsif packets to record.

	\warning

	*******************************************************************************/
/////	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_RECORD_TSIF_PACKETS_CMD (HANDLE hResourceContext,
																		  unsigned short iNumOfPackets);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.10 Subcommand 108

		When CIR logging is enabled the CIR information is logged once every nth frame.
		This command configures n.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\warning This command is currently not supported.

	*******************************************************************************/
	//QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_CONFIGURE_CIR_LOG_PARAMS (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T DIAG, 5.3.11 Subcommand 109

		This command sets up the VBER one-bit error test.
		The test box is set up to transmit packets containing all 0 bits.
		The SW then counts the number of bits set to 1 in the tsif output for each packet.
		This count can be read back using the UBM_L1_ISDB_VBER_ONE_BIT_STATUS (Section 5.3.12) command.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iLength = Number of packets to run the test over
	\param iThreshold = Threshold for determining if the packet is considered good
	\param iPid = Only packets with this PID will be tested (this is done to filter any unwanted PIDs)

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_PRBS_ONE_BIT_CMD (HANDLE hResourceContext,
																   unsigned long iLength,
																   unsigned long iThreshold,
																   unsigned short iPid);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.12 Subcommand 110

		This command returns the number of 1 bits counted in the PRBS one-bit test (Section 5.3.11).

	\param hResourceContext		= Resource context that was returned from the call to QLIB_ConnectServer().
	\param piTestDone			= pointer to store test Status, 0 indicates the test is not finished 1 = test finished.
	\param piOnesCount			= pointer to store the total number of ones counted in the test.
	\param piGoodPacketCount	= pointer to store the number of packets used for this test (should be equal the length requested).
	\param piBadPacketCount		= pointer to store the number of invalid packets got
								  (that has more than the threshold number of ones in them).
	\param piError				= pointer to store the error flag.
								  0 - Success
								  1 - Too many unmatched Pids. Received more than a thousand consecutive unmatched PIDs found.

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_PRBS_ONE_BIT_STATUS (HANDLE hResourceContext,
																	  unsigned char *piTestDone,
																	  unsigned long *piOnesCount,
																	  unsigned long *piGoodPacketCount,
																	  unsigned long *piBadPacketCount,
																	  unsigned char *piError);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.13 Subcommand 111

		This command will enable the LNA update loop.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_ENABLE_LNA_UPDATE (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.14 Subcommand 112

		This command disables the LNA update loop.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_DISABLE_LNA_UPDATE (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.15 Subcommand 113

		This command changes pre-FFT jammer parameters. This command has to be sent prior to the acquisition command.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iNoOfJammers = Needs to be between 0 to 6
	\param piJammerGainBuffer = Pointer to buffer containing the jammer gains (one for each jammer)
	\param piNotchIBuffer = Pointer to buffer containing Notch I values (one for each jammer)
	\param piNotchQBuffer = Pointer to buffer containing Notch Q values (one for each jammer)

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_CFG_JAMMER_CMD (HANDLE hResourceContext,
																 unsigned char iNoOfJammers,
																 const unsigned char* piJammerGainBuffer,
																 const unsigned short* piNotchIBuffer,
																 const unsigned short* piNotchQBuffer);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.16 Subcommand 114

		This command triggers ISDB L1 to display and return the current RSSI information.

	\param hResourceContext	= Resource context that was returned from the call to QLIB_ConnectServer()
	\param pRssiQ6			= Pointer to location to store required Signal Strength Information in Q6 format
	\param pLnaState		= Pointer to location to store Low Noise Amplifier state
	\param pDbAdcFullScaleQ6= Pointer to location to store dbAdcFullScaleQ6 in Q6 format
	\param pLog2eeQ6		= Pointer to location to store Log2 of the normalized energy estimate in Q6 format.
	\param pAgcFiltStateQ12	= Pointer to location to store DVGA gain in Q12 log2 format

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning The system must be acquired.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_RSSI_STATUS (HANDLE hResourceContext,
															  short *pRssiQ6,
															  unsigned char *pLnaState,
															  short *pDbAdcFullScaleQ6,
															  short *pLog2eeQ6,
															  short *pAgcFiltStateQ12);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.17 Subcommand 115

		This command triggers ISDB L1 to enter the recovery state.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_RECOVERY_CMD (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.18 Subcommand 116

		This command configures RDSP data logging.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iLogItem = The log item that is being configured:
						0 = CPCE
						1 = CPCE Utilized Pathlist
						2 = CPCE Candidate Pathlist
						3 = CIR (ISDB-T only)
						4 = Acquisition Likelihood
						5 = Jammer FFT Output
						6 = RDSP periodic logging
						7 = TMCC info
						8 = Detailed Acquisition
						9 = Subcarrier Monitoring
	\param iFlag = For CIR:
					Byte 1: Set to 0.
					Bytes 2-3: Logging Interval in OFDM symbols. A value of 0 disables the CIR logging. A non-zero value enables the CIR logging.
					Byte 4: 0-Disable, 1-Enable
				   For RDSP Periodic:
					Byte 1: RDSP Log Item. (See Table 3-18).
					Bytes 2-3: Logging Interval in OFDM symbols.
					Byte 4: 0-Disable, 1-Enable
				   For TMCC:
					Byte 1: Set to 0.
					Bytes 2-3: Logging Interval in OFDM frames. A value of 0 disables the TMCC logging. A non-zero value enables the TMCC logging.
					Byte 4: Set to 0
				   For Sub-carrier Monitoring:
					Bytes 1-2: Sub-carrier index to log (Index according to ISDB-T standard).
					Byte 3: Mode of operation (2 or 3).
					Byte 4: 0-Disable, 1-Enable.
				   For Acquisition Likelihood, Jammer FFT output, Detailed Acquisition:
					Byte 1: 0-Disable, 1-Enable

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_CFG_RDSP_LOG_CMD (HANDLE hResourceContext,
																   unsigned char iLogItem,
																   unsigned long iFlag);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.19 Subcommand 117

		This command is used to configure post-FFT jammer parameters.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iMode = 1 - UBM_L1_MODE_1
				   2 - UBM_L1_MODE_2
				   3 - UBM_L1_MODE_3
	\param iThreshold = Post-FFT Threshold for iMode
	\param iGain = Post FFT Gain for iMode
	\param iRegion0Odd = Odd Value for Region 0
	\param iRegion0Even = Even Value for Region 0
	\param iRegion1Odd = Odd Value for Region 1
	\param iRegion1Even = Even Value for Region 1
	\param iRegion2Odd = Odd Value for Region 2
	\param iRegion2Even = Even Value for Region 2
	\param iRegion3Odd = Odd Value for Region 3
	\param iRegion3Even = Even Value for Region 3
	\param iRegion4Odd = Odd Value for Region 4
	\param iRegion4Even = Even Value for Region 4
	\param iRegion5Odd = Odd Value for Region 5
	\param iRegion5Even = Even Value for Region 5
	\param iRegion6Odd = Odd Value for Region 6
	\param iRegion6Even = Even Value for Region 6
	\param iRegion7Odd = Odd Value for Region 7
	\param iRegion7Even = Even Value for Region 7
	\param iRegionEnable = Region enable for iMode

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_CFG_POST_FFT_JAMMER_CMD (HANDLE hResourceContext,
																		  unsigned char iMode,
																		  unsigned char iThreshold,
																		  unsigned char iGain,
																		  unsigned short iRegion0Odd,
																		  unsigned short iRegion0Even,
																		  unsigned short iRegion1Odd,
																		  unsigned short iRegion1Even,
																		  unsigned short iRegion2Odd,
																		  unsigned short iRegion2Even,
																		  unsigned short iRegion3Odd,
																		  unsigned short iRegion3Even,
																		  unsigned short iRegion4Odd,
																		  unsigned short iRegion4Even,
																		  unsigned short iRegion5Odd,
																		  unsigned short iRegion5Even,
																		  unsigned short iRegion6Odd,
																		  unsigned short iRegion6Even,
																		  unsigned short iRegion7Odd,
																		  unsigned short iRegion7Even,
																		  unsigned short iRegionEnable);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.20 Subcommand 118

		This command enables/disables use of RSSI calibration information.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iUseRssiCal = TRUE if RSSI calibration data should be used, FALSE otherwise

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_USE_RSSI_CAL_CMD (HANDLE hResourceContext,
																   unsigned char iUseRssiCal);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.21 Subcommand 119

		This command sets the LNA state.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iLnaState = LNA state

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_SET_LNA_CMD (HANDLE hResourceContext,
															  unsigned char iLnaState);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.22 Subcommand 120

		This command sets the address for RDSP periodic logging dynamic items.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iDynamicItem = RSDP Periodic Logging Dynamic Item Number (0-7)
	\param iAddress = ARM address offset of the RDSP item to be logged

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_SET_PERIODIC_LOG_ADDR (HANDLE hResourceContext,
																		unsigned char iDynamicItem,
																		unsigned long iAddress);

	/******************************************************************************/
	/**
	ISDB-T DIAG, 5.3.24 Subcommand 122

		This command controls the antenna tune PDM pin.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iEnable = Enable/disable
	\param iPolarity = Polarity
	\param iInput = Density

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_ANT_TUNE_PDM_CONTROL_CMD (HANDLE hResourceContext,
																		   unsigned char iEnable,
																		   unsigned char iPolarity,
																		   unsigned short iInput);

	/******************************************************************************/
	/**
	ISDB-T DIAG, 5.3.24 Subcommand 123

		This command is used to write specific RDSP registers.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iItem = The RDSP item to write
	\param iOffset = Offset
	\param iValue = Value

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_RDSP_WRITE_CMD (HANDLE hResourceContext,
																 unsigned char iItem,
																 unsigned char iOffset,
																 unsigned long iValue);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.8 Subcommand 124

		This command gets the TMCC Frame information field of the TMCC.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piTmccRawData = pointer to store the TMCC Information field

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_GET_TMCC_FRAME_INFO_CMD (HANDLE hResourceContext,
																		  unsigned long* piTmccRawData);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.1 Subcommand 125

		This command can set or read a given L1 configuration item.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param  iGet_set_item = Get/Set the item. 0 sets item to a value. 1 to gets the item value.
	\param	iItem = configuration item to set/get.
		Defined by ubm_isdb_configuration_items in QLib_Defines.h
	\param iValue = value for configuration item.
	\param	piItem = pointer where the configuration item that was set is stored.
		Defined by ubm_isdb_configuration_items in QLib_Defines.h
	\param piValue = pointer to location to store the value of configuration item.

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_CFG_ITEM (HANDLE hResourceContext,
														   unsigned char iGet_set_item,
														   unsigned char iItem,
														   unsigned long iValue,
														   unsigned char *piItem,
														   unsigned long *piValue);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.1 Subcommand 126

		PEEK_POKE command allows the user to read/write registers values of the DSP/HW memory region.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iIfDsp = Registers Interface 0 - hw, 1  dsp
	\param iIfRead = operation type 0 - reading operation 1 - writing operation
	\param iValue = value for configuration item.
	\param iAddrOffset = Addr offset from BASE ADDRESS addr_offset is added to the BASE ADDRESS
		which is defined differently for HW/DSP.
		BOFDM_BASE : hold the HW base address
		MICRO_RDSP_BASE : hold the DSP base address
		The HW/DSP Bases address are defined differently for SURF and FFA.
	\param iValue = Value  Valid only for write operation.

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_PEEK_POKE_CMD (HANDLE hResourceContext,
																unsigned char iIfDsp,
																unsigned char iIfRead,
																unsigned long iAddrOffset,
																unsigned long iValue);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.1 Subcommand 127

		TBD.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_RESET_PKT_TRASH_COUNTERS_CMD (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.1 Subcommand 128

		TBD.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_HARD_RECOVERY_CMD (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.1 Subcommand 129

		SAMPSRV_DUMP command handles a sample server dump command from QXDM.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iStart = Start
	\param iSize = Size

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_SAMPSRV_DUMP_CMD (HANDLE hResourceContext,
																   unsigned long iStart,
																   unsigned long iSize);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.1 Subcommand 130

		ESR_RESET command resets the ESR counters.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_ESR_RESET_CMD (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.1 Subcommand 131

		PERF_CNTS_RESET command resets the counters.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_PERF_CNTS_RESET_CMD (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.1 Subcommand 132

		PERF_CNTS_SET_PRINT_MASK command sets the counters to be printed by sending mask value.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iMask = The print mask

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_PERF_CNTS_SET_PRINT_MASK_CMD (HANDLE hResourceContext,
																			   unsigned long iMask);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.1 Subcommand 133

		LOG_ACQ command handles request for acquisition status log.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_LOG_ACQ_CMD (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.8 Subcommand 134

		GET_TECHNOLOGY command returns and also print out the current working technology of the target and
		the supported technologies.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piCurrentTechnology = pointer to store the current technology field
	\param piSupportedTechnology = pointer to store the supported technologies field

	\warning This command is preserved for compatibility  use DIAG_ISDB_UBM_L1_GET_VERSION_INFO_CMD (139) instead.

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_GET_TECHNOLOGY_CMD (HANDLE hResourceContext,
																	 unsigned long* piCurrentTechnology,
																	 unsigned char* piSupportedTechnology);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.1 Subcommand 135

		RDSP_HALT command halts the RDSP.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_RDSP_HALT_CMD (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.1 Subcommand 136

		Retry the last acquisition.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning This command is currently not supported

	*******************************************************************************/
	//QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_RETRY_ACQ_CMD (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.8 Subcommand 137

		Returns the current state of the L1 state machine.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piCurrentState = pointer to store the current state

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_GET_CURRENT_STATE_CMD (HANDLE hResourceContext,
																		unsigned long* piCurrentState);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.1 Subcommand 138

		Restore all L1 SW configuration values to their defaults.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_RESTORE_DEFAULT_CFG_CMD (HANDLE hResourceContext);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.8 Subcommand 139

		Returns version information and supported technologies information.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piCurrentTechnology = pointer to store the current technology field
	\param piSupportedTechnology = pointer to store the supported technologies field
	\param piSWVersion = pointer to store the software version
	\param piSWRelease = pointer to store the software release
	\param piSWBuild = pointer to store the software build
	\param piFWVersion = pointer to store the firmware release
	\param piFWSubVersion = pointer to store the firmware sub-version
	\param piData = pointer to store the 30 byte data array
	\param piTime = pointer to store the 30 byte time array

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_GET_VERSION_INFO_CMD (HANDLE hResourceContext,
																	   unsigned char* piCurrentTechnology,
																	   unsigned char* piSupportedTechnology,
																	   unsigned long* piSWVersion,
																	   unsigned long* piSWRelease,
																	   unsigned long* piSWBuild,
																	   unsigned short* piFWVersion,
																	   unsigned short* piFWSubVersion,
																	   char* piData,
																	   char* piTime);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.8 Subcommand 140

		Returns the RS1 (Reed Solomon) and ESR (Error Second Rate) cumulative counters.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piRS1PacketCount = pointer to store the RS1 packet count
	\param piRS1TrashCount = pointer to store the RS1 trash count
	\param piESRTotalSeconds = pointer to store the ESR total seconds
	\param piESRBadSeconds = pointer to store the ESR bad seconds

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_RS1_PACKET_CNT_RES_V2_CMD (HANDLE hResourceContext,
																			unsigned long* piRS1PacketCount,
																			unsigned long* piRS1TrashCount,
																			unsigned long* piESRTotalSeconds,
																			unsigned long* piESRBadSeconds);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, 5.3.8 Subcommand 141

		Returns various parameters used in the L1-L3 API. This command is used to debug the L1-L3 API.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iParameterID = the ID of the parameter to be queried
	\param piItemSize = pointer to store the size in bytes of the returned item data
	\param piStatus = pointer to store the status (0-success, 1-failure)
	\param piItemData = pointer to a buffer to store the item data
	\param iItemDataBufferSize = the amount of memory allocated by the caller for the item data buffer

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_GET_PARAM_VAL_CMD (HANDLE hResourceContext,
																	unsigned char iParameterID,
																	unsigned long* piItemSize,
																	unsigned char* piStatus,
																	unsigned char* piItemData,
																	unsigned long iItemDataBufferSize);

	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, Subcommand 143

		Configures UBM tracking loops.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iTrackingLoopId = The tracking loop ID: 0 - Time, 1 - Frequency, 2 - Coarse DC, 3 - Fine DC, 4 - AGC
	\param iOperation = 0 - Disable, 1 - Enable, 2 - Reset and disable (valid only for fine DC)

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_HANDLE_TRACK_LOOPS_CFG_CMD(HANDLE hResourceContext,
																		    unsigned char iTrackingLoopId,
																		    unsigned char iOperation);


	/******************************************************************************/
	/**
	ISDB-T L1 DIAG, Subcommand 144

		Gets UBM tracking loops status.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param piIsTrackingLoopEnabled = Bit 0 - Time, Bit 1 - Frequency, Bit 2 - Coarse DC, Bit 3 - Fine DC, Bit 4 - AGC.
									 1 means that the loop is enabled. 0 means that the loop is disabled.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_ISDB_UBM_L1_GET_TRACK_LOOPS_STATUS_CMD(HANDLE hResourceContext,
																			unsigned char* piIsTrackingLoopEnabled);


/******************************************************************************
						MBP RF DIAG
*******************************************************************************/

	/******************************************************************************/
	/**
	MBP RF DIAG, Subcommand 12

		This command sets a configuration item

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iItem = Defined by mbprftypes_cfg_item_type in QLib_Defines.h:
		\code
			MBP_RF_CFG_NB_JD_ENABLED = 31,	//"< ' Narrowband Jammer Detection Control (0=disable,1=enable)
			MBP_RF_CFG_WB_JD_ENABLED = 32	//"< ' Wideband Jammer Detection Control (0=disable,1=enable)
		\endcode
	\param iValue = Value to set.

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_MBP_RF_SET_CFG_ITEM_CMD(HANDLE hResourceContext,
															 unsigned char iItem,
															 unsigned long iValue);

	/******************************************************************************/
	/**
	MBP RF DIAG, Subcommand 21

	This command sets the Jammer Detect Operation Mode

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iMode = Defined by mbprftypes_jd_mode_type in QLib_Defines.h:
		\code
			MBP_RF_JD_MODE_AUTO = 0,
			MBP_RF_JD_MODE_1    = 1,
			MBP_RF_JD_MODE_2    = 2
		\endcode

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_MBP_RF_SET_OPERATION_MODE_CMD(HANDLE hResourceContext,
																   unsigned char iMode);

	/******************************************************************************/
	/**
	MBP RF DIAG, Subcommand 30
	This command can read values from RFIC / ADC registers.
	This command can write values to RFIC / ADC registers.

	\param hResourceContext = Resource context that was returned from the call to QLIB_ConnectServer()
	\param iHwBlock = 0 for RFIC, 1 for ADC
	\param iIsWrite = 0 for READ operation, 1 for WRITE operation
	\param iAddress = Register address
	\param piVal    = Value to write, in WRITE operation. The read value is returned in this
		field, for READ operations.

	\return 1 if response packet was successfully returned, 0 if it failed for any reason.

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_DIAG_MBP_RF_PEEK_POKE_CMD(HANDLE hResourceContext,
														  unsigned char iHwBlock,
														  unsigned char iIsWrite,
														  unsigned char iAddress,
														  unsigned char *piVal);

/******************************************************************************
						Calibration Data Manager
*******************************************************************************/


	/******************************************************************************/
	/**
	Set the system parameters used to calculate CDMA 1x related NV items.  If the function
	is not called, the default values will be used.

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param dMinRSSI [input] Minimum RSSI.  Default value is -115.0dBm

	\param dDynamicRange [input] Dynamic Range for CDMA 1x targets.  Default value is 102.4dB

	\param dWCDMADynamicRange [input] = Dynamic Range for UMTS target.  Default value is 85.3dB

	\return true if successful, false otherwise

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_CDMA_SystemParameters( HANDLE hResourceContext, double dMinRSSI, double dDynamicRange, double dWCDMADynamicRange );

   /******************************************************************************/
	/**
	Set the system parameters used to calculate WCDMA related NV items.  If the function
	is not called, the default values will be used.

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param dWCDMADynamicRange [input] = Dynamic Range for UMTS target.  Default value is 85.3dB

        \param dWCDMAMaxPower [input] = Max Power for UMTS target.  Default value is 28.3dB

	\return true if successful, false otherwise

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_WCDMA_SystemParameters_V2( HANDLE hResourceContext, double dWCDMADynamicRange, double dWCDMAMaxPower );

	/******************************************************************************/
	/**
	Generate Tx Linearizer, Tx AGC vs HDET, HDET offset and span NV items

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeID [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param aTx_LinMeasured [input] Pointer to QMSL_CDMA_TxLin_struct.  The data structure stores 1x Tx linearizer calibration results.  See QLib_Defines.h for definition

	\param aTx_Lin_NV_Result [output] Pointer to QMSL_CDMA_TxLin_Cal_Result_struct.  The data structure stores the generated 1x Tx Linearizer related NV items.  See QLib_Defines.h for definition

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called

	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_CDMA_Tx_LinCal_Results(	HANDLE hResourceContext,
																unsigned short iNVModeID,
																void* aTx_LinMeasured,
																void* aTx_Lin_NV_Result,
																unsigned char bCachedByNVManager);

	/******************************************************************************/
	/**
	Generate Tx Frequency Compensation (TX_COMP_n) NV items

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeID [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param aTx_Measured_Power [input] Pointer to QMSL_CDMA_TxLinVsFreq_struct.  The data structure stores Tx linearizer vs frequency results.  See QLib_Defines.h for definition

	\param aTx_MeasuredChannels [input] Pointer to QMSL_CDMA_MeasuredChannels.  The data structure stores the list of RF channels, which the measurement is made.  See QLib_Defines.h for definition
											This list must always contain 16 values. If fewer channels are desired to be used then
											the last valid channel (highest frequency) is to be filled into the end of the
											list, such that there are 16 items in the list.

	\param aTx_NV_Channels [input] Pointer to QMSL_CDMA_NVChannels_struct. The list of RF channels which NV generation is used.  See QLib_Defines.h for definition.

	\param aTx_LinVsFreq_NV_Result [output] Pointer to QMSL_CDMA_Tx_LinVsFreq_Cal_NV_Result_struct.  The data structure that stores the NV item values generated.  See QLib_Defines.h for definition

	\param iNV_Resolution [input]  The number of NV value counts per dB
									NV[chan] = ( measured-pwr[chan] - refChannelPwr ) * iNV_Resolution
									For targets with 102.4 dB dynamic range, use 10 (ie 1/10dB per count).
									For targets with 85.3 dB dynamic range, use 12 (ie 1/12dB per count).

	\param iNV_Tx_Comp_Type [input] 0 = QMSL_NV_TX_COMP, (NV_<bandclass>_TX_COMP_x NV items are generated)
									1 = QMSL_NV_TX_PWR_COMP, (NV_<bandclass>_TX_PWR_COMP_x NV items are generated)

	\param bWriteNVChList [input] Generate calibration channel list NV_Cx_BCy_TX_CAL_CHAN_I NV item based on channesl in aRX_NV_Channels.  Note that not all target supports this NV items.  Please
						          refer to the target RF NV items document

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called

	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_CDMA_Tx_LinVsFreq_Results	(	HANDLE	 hResourceContext,
																	unsigned short iNvModId,
																	void* aTx_Measured_Power,
																	void* aTx_MeasuredChannels,
																	void* aTx_NV_Channels,
																	int	  iNV_Resolution_Type,
																	int   iNV_Tx_Comp_Type,
																	void* aTx_LinVsFreq_NV_Result,
																	unsigned char bWriteNVChList,
																	unsigned char bCachedByNVManager);

	/******************************************************************************/
	/**
	Generate Tx Frequency Compensation (TX_COMP_n) NV items for the Div Tx

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeID [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param aTx_Measured_Power [input] Pointer to QMSL_CDMA_TxLinVsFreq_struct.  The data structure stores Tx linearizer vs frequency results.  See QLib_Defines.h for definition

	\param aTx_MeasuredChannels [input] Pointer to QMSL_CDMA_MeasuredChannels.  The data structure stores the list of RF channels, which the measurement is made.  See QLib_Defines.h for definition
											This list must always contain 16 values. If fewer channels are desired to be used then
											the last valid channel (highest frequency) is to be filled into the end of the
											list, such that there are 16 items in the list.

	\param aTx_NV_Channels [input] Pointer to QMSL_CDMA_NVChannels_struct. The list of RF channels which NV generation is used.  See QLib_Defines.h for definition.

	\param aTx_LinVsFreq_NV_Result [output] Pointer to QMSL_CDMA_Tx_LinVsFreq_Cal_NV_Result_struct.  The data structure that stores the NV item values generated.  See QLib_Defines.h for definition

	\param iNV_Resolution [input]  The number of NV value counts per dB
									NV[chan] = ( measured-pwr[chan] - refChannelPwr ) * iNV_Resolution
									For targets with 102.4 dB dynamic range, use 10 (ie 1/10dB per count).
									For targets with 85.3 dB dynamic range, use 12 (ie 1/12dB per count).

	\param iNV_Tx_Comp_Type [input] 0 = QMSL_NV_TX_COMP_MTD, (NV_<bandclass>_TX_COMP_x NV items are generated)
									1 = QMSL_NV_TX_PWR_COMP, (NV_<bandclass>_TX_PWR_COMP_x NV items are generated)

	\param bWriteNVChList [input] Generate calibration channel list NV_Cx_BCy_TX_CAL_CHAN_I NV item based on channesl in aRX_NV_Channels.  Note that not all target supports this NV items.  Please
						          refer to the target RF NV items document

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called

	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_CDMA_Tx_LinVsFreq_Results_MTD	(	HANDLE	 hResourceContext,
																	unsigned short iNvModId,
																	void* aTx_Measured_Power,
																	void* aTx_MeasuredChannels,
																	void* aTx_NV_Channels,
																	int	  iNV_Resolution_Type,
																	int   iNV_Tx_Comp_Type,
																	void* aTx_LinVsFreq_NV_Result,
																	unsigned char bWriteNVChList,
																	unsigned char bCachedByNVManager);

	/******************************************************************************/
	/**
	Generate Tx Lim vs freq (TX_LIM_VS_FREQ) NV items.  Calcuations are based on the
	WCDMA NV Document 80-V6968-12 Rev H, section 4.3.3.11.


	The same calculations are used for CDMA2000 and WCDMA, this document is just a reference point.

	As for Feb 2008, certain CDMA2000 documents had a different formula.  The formula will
	be changed to match 80-V6968-12 after the following versions:
	\code
		80-V8891-11 Rev C for MSM6800
		80-VC467-11 Rev C for RTR6500
	\endcode


	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param dDesiredMaxPower [input] Desired maximum output power in dBm

	\param aTx_LimVsFreqMeasured [input] Pointer to QMSL_CDMA_TxLimVsFreq_struct.  The data structure stores Tx Lim vs Freq measurement.  See QLib_Defines.h for definition

	\param aTx_MeasuredChannels [input] Pointer to QMSL_CDMA_MeasuredChannels_struct.  The data structure stores the list of RF channels, which the measurement is made.  See QLib_Defines.h for definition

	\param aTx_NV_Channels [input] Pointer to QMSL_CDMA_NVChannels_struct. The list of RF channels which NV generation is used.  See QLib_Defines.h for definition.
											This list must always contain 16 values. If fewer channels are desired to be used then
											the last valid channel (highest frequency) is to be filled into the end of the
											list, such that there are 16 items in the list.

	\param aTx_LimVsFreq_NV_Result [output] Pointer to QMSL_CDMA_Tx_LimVsFreq_NV_struct.  The data structure that stores the
	                                        NV item values generated.  See QLib_Defines.h for definition.
											This list must always contain 16 values. If fewer channels are desired to be used then
											the last valid channel (highest frequency) is to be filled into the end of the
											list, such that there are 16 items in the list.

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called

	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_CDMA_Tx_LimVsFreq_Results(	HANDLE hResourceContext,
																	unsigned short iNvModeId,
																	double dDesiredMaxPower,
																	void* aTx_LimVsFreqMeasured,
																	void* aTx_MeasuredChannels,
																	void* aTx_NV_Channels,
																	void* aTx_LimVsFreq_NV_Result,
																	unsigned char bCachedByNVManager);
	/******************************************************************************/
	/**
	Generate Tx Lim vs freq (TX_LIM_VS_FREQ) NV items for the Div Tx.  Calcuations are based on the
	WCDMA NV Document 80-V6968-12 Rev H, section 4.3.3.11.


	The same calculations are used for CDMA2000 and WCDMA, this document is just a reference point.

	As for Feb 2008, certain CDMA2000 documents had a different formula.  The formula will
	be changed to match 80-V6968-12 after the following versions:
	\code
		80-V8891-11 Rev C for MSM6800
		80-VC467-11 Rev C for RTR6500
	\endcode


	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param dDesiredMaxPower [input] Desired maximum output power in dBm

	\param aTx_LimVsFreqMeasured [input] Pointer to QMSL_CDMA_TxLimVsFreq_struct.  The data structure stores Tx Lim vs Freq measurement.  See QLib_Defines.h for definition
	\param aTx_MeasuredChannels [input] Pointer to QMSL_CDMA_MeasuredChannels_struct.  The data structure stores the list of RF channels, which the measurement is made.  See QLib_Defines.h for definition

	\param aTx_NV_Channels [input] Pointer to QMSL_CDMA_NVChannels_struct. The list of RF channels which NV generation is used.  See QLib_Defines.h for definition.
											This list must always contain 16 values. If fewer channels are desired to be used then
											the last valid channel (highest frequency) is to be filled into the end of the
											list, such that there are 16 items in the list.

	\param aTx_LimVsFreq_NV_Result [output] Pointer to QMSL_CDMA_Tx_LimVsFreq_NV_struct.  The data structure that stores the
	                                        NV item values generated.  See QLib_Defines.h for definition.
											This list must always contain 16 values. If fewer channels are desired to be used then
											the last valid channel (highest frequency) is to be filled into the end of the
											list, such that there are 16 items in the list.

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called

	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_CDMA_Tx_LimVsFreq_Results_MTD(	HANDLE hResourceContext,
																	unsigned short iNvModeId,
																	double dDesiredMaxPower,
																	void* aTx_LimVsFreqMeasured,
																	void* aTx_LimVsFreqMeasured_Pri,
																	void* aTx_MeasuredChannels,
																	void* aTx_NV_Channels,
																	void* aTx_LimVsFreq_NV_Result,
																	unsigned char bCachedByNVManager);


	/******************************************************************************/
	/**
	Generate DVGA and LNA related NV item values

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNv_Mode_ID [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param iIntelliceiver [input] Is it Intelliceiver? 1 == Yes, 0 == No

	\param dDVGAOffsetScalingFactor [input]  The scaling factor to calculate the DVGAvsFreq offset.  DVGAvsFreq[_ch] = (DVGA[_ch] - refDVGA) / dDVGAOffsetScalingFactor

	For CDMA targets(MSM6K/7K,QSC6010/20/30), the scaling factor is 12
	For WCDMA targets, the scaling factor is 1
	For QSC6055/65/75/85 targets, the scaling factor is 1

	Consult the RF NV document for the proper scaling factor.

	\param aRX_Measured [input] Pointer to QMSL_CDMA_RxFreq_Measurement_struct.  The data structure that stores receiver calibration results.  See QLib_Defines.h for definition

	\param aRX_MeasuredChannels [input] Pointer to QMSL_CDMA_MeasuredChannels_struct.  The list of RF channels which the receiver calibration runs.  See QLib_Defines.h for definition

	\param aRX_NV_Channels	[input]  Pointer to QMSL_CDMA_NVChannels_struct. The list of RF channels which NV generation is used.
											This list must always contain 16 values. If fewer channels are desired to be used then
											the last valid channel (highest frequency) is to be filled into the end of the
											list, such that there are 16 items in the list.

        \param aRX_DVGA_LNA_Cal_NV [output] Pointer to QMSL_CDMA_Rx_DVGA_LNA_Cal_NV_Result. The data structure stores the NV item values generated.

	\param bWriteNVChList [input] Generate calibration channel list NV_Cx_BCy_RX_CAL_CHAN_I NV item based on channesl in aRX_NV_Channels.  Note that not all targets supports this NV items.  Please
						          refer to the target RF NV items document

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
	\return

	\warning

   *******************************************************************************/
   QLIB_API unsigned char QLIB_RFCAL_CDMA_RxCal_Results(
      HANDLE hResourceContext,
      unsigned short iNV_Mode_ID,
      unsigned char iIsIntelliceiver,
      double dDVGAOffsetScalingFactor,
      void* aRX_Measured,
      void* aRX_MeasuredChannels,
      void* aRX_NV_Channels,
      void* aRX_DVGA_LNA_Cal_NV,
      unsigned char bWriteNVChList,
      unsigned char bCachedByNVManager);

   /******************************************************************************/
   /**
   Generate DVGA and LNA related NV item values for multicarrier WCDMA RF calibration

   \param hResourceContext	Resource context that was returned from the call to ConnectServer().

   \param iBand [input] Enumeration of the WCDMA band

   \param iNv_Mode_ID [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

   \param iIntelliceiver [input] Is it Intelliceiver? 1 == Yes, 0 == No

   \param dDVGAOffsetScalingFactor [input]  The scaling factor to calculate the DVGAvsFreq offset.  DVGAvsFreq[_ch] = (DVGA[_ch] - refDVGA) / dDVGAOffsetScalingFactor

   For CDMA targets(MSM6K/7K,QSC6010/20/30), the scaling factor is 12
   For WCDMA targets, the scaling factor is 1
   For QSC6055/65/75/85 targets, the scaling factor is 1

   Consult the RF NV document for the proper scaling factor.

   \param aRX_Measured [input] Pointer to QMSL_CDMA_RxFreq_Measurement_struct.  The data structure that stores receiver calibration results.  See QLib_Defines.h for definition

   \param aRX_MeasuredChannels [input] Pointer to QMSL_CDMA_MeasuredChannels_struct.  The list of RF channels which the receiver calibration runs.  See QLib_Defines.h for definition

   \param aRX_NV_Channels	[input]  Pointer to QMSL_CDMA_NVChannels_struct. The list of RF channels which NV generation is used.
   This list must always contain 16 values. If fewer channels are desired to be used then
   the last valid channel (highest frequency) is to be filled into the end of the
   list, such that there are 16 items in the list.

   \param aRX_DVGA_LNA_Cal_NV [output] Pointer to QMSL_CDMA_Rx_DVGA_LNA_Cal_NV_Result. The data structure stores the NV item values generated.

   \param bWriteNVChList [input] Generate calibration channel list NV_Cx_BCy_RX_CAL_CHAN_I NV item based on channesl in aRX_NV_Channels.  Note that not all targets supports this NV items.  Please
   refer to the target RF NV items document

   \param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
   bCachedByNVManager == 1: Store NV items
   bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
   \return

   \warning

   *******************************************************************************/
   QLIB_API unsigned char QLIB_RFCAL_WCDMA_MultiCarrier_RxCal_Results(
      HANDLE hResourceContext,
      unsigned int iBand,
      unsigned short iNV_Mode_ID,
      unsigned char iIsIntelliceiver,
      double dDVGAOffsetScalingFactor,
      void* aRX_Measured,
      void* aRX_MeasuredChannels,
      void* aRX_NV_Channels,
      void* aRX_DVGA_LNA_Cal_NV,
      unsigned char bWriteNVChList,
      unsigned char bCachedByNVManager);

	/******************************************************************************/
	/**
	Generate CDMA Rx IM2 calibration NV items

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeIe [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param aRX_IM2_Result [input] Pointer to QMSL_CDMA_RxIM2_Measurement_struct.  The data structure stores IM2 calibration measurement.  See QLib_Defines.h for definition

	\param aRX_IM2_NV [output] Pointer to QMSL_CDMA_RxIM2_NV_struct.  The data structure stores the generated IM2 NV items.  See QLib_Defines.h for definition

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called

	*******************************************************************************/


	QLIB_API unsigned char QLIB_RFCAL_Rx_IM2_Results(	HANDLE hResourceContext,
														unsigned short iNvModeId,
														void*aRX_IM2_Result,
														void*aRX_IM2_NV,
														unsigned char bCachedByNVManager);



	/******************************************************************************/
	/**
	Generate CDMA Rx Intelliceiver calibration NV item

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param aIntelliceiverValue [input] Pointer to QMSL_CDMA_Intelliceiver_Value.  The data structure stores CDMA Intelliceiver calibration value.  See QLib_Defines.h for definition

	\param aIntelliceiver_NV [output] Pointer to QMSL_RFCAL_NV_Item.  The data structure stores the generated NV Item.  See QLib_Defines.h for definition.

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called

	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_Rx_Intelliceiver_Cal_Results(	HANDLE hResourceContext,
																		unsigned short iNvModeId,
																		void* aIntelliceiverValue,
																		void* aIntelliceiver_NV,
																		unsigned char bCachedByNVManager);

	/******************************************************************************/
	/**
	Generate Tx Linearizer (Beta Scaling), Tx AGC vs HDET, HDET offset and span NV items

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeID [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param aTx_Measured [input] Pointer to QMSL_CDMA_TxLin_BetaScaling_struct.  The data structure stores 1x Tx linearizer calibration results.  See QLib_Defines.h for definition

	\param aTx_Result [output] Pointer to QMSL_CDMA_TxLinCal_BetaScaling_Result_struct.  The data structure stores the generated 1x Tx Linearizer related NV items.  See QLib_Defines.h for definition

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called

	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_CDMA_TxLinCal_BetaScaling_Results(
																		HANDLE hResourceContext,
																		unsigned short iNvModeId,
																		void* aTx_Measured,
																		void* aTx_Result,
																		unsigned char bCachedByNVManager
																		);


	/******************************************************************************/
	/**
	Generate Tx Linearizer (RTR6500) NV_BCx_TX_PDM_y_I and NV_BCx_TX_LIN_y, Tx AGC vs HDET, HDET offset and span NV items

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeID [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param aTx_LinMeasured [input] Pointer to QMSL_CDMA_TxLin_struct.  The data structure stores 1x Tx linearizer calibration results.  See QLib_Defines.h for definition

	\param aTx_Lin_NV_Result [output] Pointer to QMSL_CDMA_TxLin_RTR6500_Result_struct.  The data structure stores the generated 1x Tx Linearizer related NV items.  See QLib_Defines.h for definition

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called

	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_CDMA_TxLinCal_RTR6500_Results(
																		HANDLE hResourceContext,
																		unsigned short iNvModeId,
																		void* aTx_Measured,
																		void* aTx_Result,
																		unsigned char bCachedByNVManager
																		);

	/******************************************************************************/
	/**
	Implement "ProcessTxSwep" function for Polar Calibration.
	See app note: MSM6275 External Polar Calibration with equipment(80-V9774-11).
	The output (aGSM_Polar_Cal_Processed) can be used as input to QLIB_RFCAL_GSM_Tx_Polar_Cal_Results

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param aGSM_Polar_Cal_Measurement [input] Pointer to struct QMSL_GSM_Polar_Cal_Measurement in QLIB_Defines.h.  Polar calibration raw measurement data (including trigger and reference DAC segments).

	\param aGSM_Polar_Cal_Processed [output]  Pointer to struct QMSL_GSM_Polar_Cal_Measurement in QLIB_Defines.h   Polar calibration processed data (trigger and ref DAC segements removed.  Phase data are unwrapped)

	\return true if operation is successful, false otherwise

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_GSM_Tx_Polar_ProcessTxSweep(HANDLE hResourceContext,
																  void* aGSM_Polar_Cal_Measurement,
																  void* aGSM_Polar_Cal_Processed);


	/******************************************************************************/
	/**
	Generate the NV items associated with GSM Tx external polar clibration.  The NV items include NV_GSM_AMAM_MASTER_TBL_SEGx_Fn_I,
	NV_GSM_AMPM_MASTER_TBL_SEGx_Fn_I, NV_GSM_AMAM_ARFCH_Fn_I, NV_GSM_AMAM_DYNAMIC_RANGE__I

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param aGSM_Polar_Cal [input] Pointer to QMSL_GSM_Polar_Cal_Result.  Polar calibration processed data (Trigger and ref segments removed, phase unwrapped).  The data can come from QLIB_RFCAL_GSM_Tx_Polar_ProcessTxSweep

	\param aGSM_Polar_Cal_NV [output] Pointer to QMSL_GSM_Polar_Cal_NV_struct.  NV items generated by smoothing algorithm

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_GSM_Tx_Polar_Cal_Results(	HANDLE hResourceContext,
													unsigned short iNvModeId,
													void* aGSM_Polar_Cal,
													void *aGSM_Polar_Cal_NV,
													unsigned char bCachedByNVManager);

	/******************************************************************************/
	/**
	Generate the NV items associated with GSM Tx external DA clibration.  The NV items include QMSL_GSM_RGI_Fn,
	QMSL_GSM_PMEAS_Fn, NV_GSM_AMAM_ARFCH_Fn_I

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param aGSM_DA_Cal [input] DA calibration sweep raw measurement

	\param aGSM_DA_Cal_NV [output] NV items generated.

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_GSM_Tx_DA_Cal_Results(	HANDLE hResourceContext,
													unsigned short iNvModeId,
													void* aGSM_DA_Cal,
													void *aGSM_DA_Cal_NV,
													unsigned char bCachedByNVManager);

	/******************************************************************************/
	/**
	Generate the NV items associated with GSM Tx external Linear clibration.  The NV items include NV_GSM_<band>_AMAM_LINEAR_PA_RANGEA_F<n>_SEG<n>_I,
	NV_GSM_<band>_AMPM_LINEAR_PA_RANGEA_F<n>_SEG<n>_I, , NV_GSM_AMAM_DYNAMIC_RANGE__I, NV_GSM_<band>_TX_AGC_SETTING_FOR_PRED_I

	NV_GSM_AMAM_ARFCH_Fn_I is populated as part of DA calibration (QLIB_RFCAL_GSM_Tx_DA_Cal_Results)

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param aGSM_PreDist_Cal [input] PreDist calibration data. Raw Phase and Amplitude in degrees and dBm.

	\param aGSM_PreDist_Cal_NV [output] NV items generated.

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_GSM_Tx_Linear_Process_PreDist_Cal_Results(	HANDLE hResourceContext,
													unsigned short iNvModeId,
													void* aGSM_PreDist_Cal,
													void *aGSM_PreDist_Cal_NV,
													unsigned char bCachedByNVManager);

    /******************************************************************************/
      /**
      Generate the NV items associated with GSM Tx external Linear clibration.  The NV items include NV_GSM_<band>_AMAM_LINEAR_PA_RANGEA_F<n>_SEG<n>_I,
      NV_GSM_<band>_AMPM_LINEAR_PA_RANGEA_F<n>_SEG<n>_I, , NV_GSM_AMAM_DYNAMIC_RANGE__I, NV_GSM_<band>_TX_AGC_SETTING_FOR_PRED_I

      NV_GSM_AMAM_ARFCH_Fn_I is populated as part of DA calibration (QLIB_RFCAL_GSM_Tx_DA_Cal_Results)

      \param hResourceContext	Resource context that was returned from the call to ConnectServer().

      \param aGSM_PreDist_Cal [input] PreDist calibration data. Raw Phase and Amplitude in degrees and dBm.

      \param aGSM_PreDist_Cal_NV [output] NV items generated.

      \param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
                                          bCachedByNVManager == 1: Store NV items
                                          bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

      \return true if operation is successful, false otherwise

      \warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
      *******************************************************************************/
      QLIB_API unsigned char QLIB_RFCAL_GSM_Tx_Linear_Process_NonIQ_PreDist_Cal_Results(	HANDLE hResourceContext,
                                                      unsigned short iNvModeId,
                                                      void* aGSM_PreDist_Cal,
                                                      void *aGSM_PreDist_Cal_NV,
                                                      unsigned char bCachedByNVManager);


    /******************************************************************************/
	/**
	Generate the NV items associated with GSM Tx external Linear clibration.  The NV items include NV_GSM_<band>_AMAM_LINEAR_PA_RANGEA_F<n>_SEG<n>_I,
	NV_GSM_<band>_AMPM_LINEAR_PA_RANGEA_F<n>_SEG<n>_I, , NV_GSM_AMAM_DYNAMIC_RANGE__I, NV_GSM_<band>_TX_AGC_SETTING_FOR_PRED_I

        This API is used when the calibration waveform is EDGE_DC instead of DC_EDGE

	NV_GSM_AMAM_ARFCH_Fn_I is populated as part of DA calibration (QLIB_RFCAL_GSM_Tx_DA_Cal_Results)

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param aGSM_PreDist_Cal [input] PreDist calibration data. Raw Phase and Amplitude in degrees and dBm.

	\param aGSM_PreDist_Cal_NV [output] NV items generated.

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_GSM_Tx_Linear_Process_Swapped_PreDist_Cal_Results(	HANDLE hResourceContext,
													unsigned short iNvModeId,
													void* aGSM_PreDist_Cal,
													void *aGSM_PreDist_Cal_NV,
													unsigned char bCachedByNVManager);
	/******************************************************************************/
	/**
	Generate the NV items associated with GSM Linear Envelope DC Cal .  The NV items include NV_<band>_LINEAR_ENVDC_CAL_VAL

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param iEnvDCVal [input] Env DC Cal calibration value

	\param pEnvDCValItem [output] Pointer to QMSL_RFCAL_NV_Item.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_GSM_Tx_Linear_Env_DC_Cal_Results(HANDLE hResourceContext, unsigned short iNvModeId, unsigned short iEnvDCVal, void * pEnvDCValItem, unsigned char bCachedByNVManager);

   /******************************************************************************/
	/**
	Generate the NV items associated with GSM Delay calibration.  The NV items include NV_<band>_POLAR_PATH_DELAY

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param iPolarDelayPathValue [input] Polar delay path calibration value

	\param pDelay_Cal_NVItem [output] Pointer to QMSL_RFCAL_NV_Item.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_GSM_Tx_Delay_Cal_Results(HANDLE hResourceContext, unsigned short iNvModeId, unsigned short iPolarDelayPathValue, void * pDelay_Cal_NVItem, unsigned char bCachedByNVManager);

	/******************************************************************************/
	/**
	Generate the NV items associated with GSM Tx RSB calibration.  The NV items include NV_<band>_TX_RSB_CORR_I

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param aRSB [input] Pointer to QMSL_GSM_Rx_RSB_struct.  See QLib_Defines.h for details

	\param pRSB_NVItem [output] Pointer to QMSL_RFCAL_NV_Item.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_GSM_Tx_RSB_Cal_Results(HANDLE hResourceContext,
																unsigned short iNvModeId,
																void* aRSB,
																void * pRSB_NVItem,
																unsigned char bCachedByNVManager
															);

	/******************************************************************************/
	/**
	Generate the NV items associated with GSM Tx 4xFMod calibration.  The NV items includes NV_<band>_PA_TEMP_COMP_INDEX_11

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param i4xFModValue [input] 4xFMod Calibration result

	\param p4xFModNVItem [output] Pointer to QMSL_RFCAL_NV_Item.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_GSM_Tx_4xFMod_Cal_Results( HANDLE hResourceContext,
																unsigned short iNvModeId,
																unsigned char i4xFModValue,
																void * p4xFModNVItem,
																unsigned char bCachedByNVManager
															);

	/******************************************************************************/
	/**
	Generate the NV items associated with GSM Tx DC DC PDM calibration.  The NV items includes NV_GSM_<band>_SMPS_PDM_TBL_I

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param aGSM_DC_DC_PDM_Cal [input] DC DC PDM cal measurements and parameters. See QLib_Defines.h for details

	\param aGSM_DC_DC_PDM_Cal_NV [output] Pointer to QMSL_RFCAL_NV_Item.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_GSM_Tx_DC_DC_PDM_Cal_Results(	HANDLE hResourceContext,
													unsigned short iNvModeId,
													void* aGSM_DC_DC_PDM_Cal,
													void*aGSM_DC_DC_PDM_Cal_NV,
													unsigned char bCachedByNVManager);
	/******************************************************************************/
	/**
	Generate the NV items associated with GSM Tx PA DAC calibration.  The NV items includes NV_GSM_<band>_PADAC_DC_OFFSET_I

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param aGSM_PA_DAC_Cal [input] DC DC PDM cal measurements and parameters. See QLib_Defines.h for details

	\param aGSM_PA_DAC_Cal_NV [output] Pointer to QMSL_RFCAL_NV_Item.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_GSM_Tx_PA_DAC_Cal_Results(	HANDLE hResourceContext,
													unsigned short iNvModeId,
													void* aGSM_PA_DAC_Cal,
													void*aGSM_DPA_DAC_Cal_NV,
													unsigned char bCachedByNVManager);

	/******************************************************************************/
	/**
	Generate the NV items associated with GSM Tx Pout calibration.  The NV items includes NV_<band>_PA_TEMP_COMP_INDEX_10

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param iVgaOut [input] Pout calibration value

	\param pPout_NVItem [output] Pointer to QMSL_RFCAL_NV_Item.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_GSM_Tx_Pout_Cal_Results(
														HANDLE hResourceContext,
														unsigned short iNvModeId,
														unsigned char iVgaOut,
														void * pPout_NVItem,
														unsigned char bCachedByNVManager
														);

	/******************************************************************************/
	/**
	Generate the NV items associated with OPLL calibration.  The NV items includes NV_<band>_OPLL_BW_VAL

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param iOPLLValue [input] OPLL calibration value

	\param pOPLL_NVItem [output] Pointer to QMSL_RFCAL_NV_Item.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_GSM_Tx_OPLL_Cal_Results(
														HANDLE hResourceContext,
														unsigned short iNvModeId,
														unsigned char iOPLLValue,
														void * pOPLL_NVItem,
														unsigned char bCachedByNVManager
														);

	/******************************************************************************/
	/**
	Generate the NV items associated with GSM IM2 calibration.  The NV items includes NV_GSM_IM2_<band>

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param aGSM_IM2_Cal_Result [input] Pointer to QMSL_GSM_IM2_struct, GSM IM2 calibration result.  See QLib_Defines.h for details

	\param pGSM_IM2_NVItem [output] Pointer to QMSL_RFCAL_NV_Item.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_GSM_Rx_IM2_Cal_Results(
													HANDLE hResourceContext,
													unsigned short iNvModeId,
													void* aGSM_IM2_Cal_Result,
													void * pGSM_IM2_NVItem,
													unsigned char bCachedByNVManager
													);

	/******************************************************************************/
	/**
	Generate the NV items associated with GSM LNA gain range calibration.  The NV items includes NV_<band>_RX_GAIN_RANGE_<n>_FREQ_COMP

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param aGSM_Rx_Gain_Range_Result [input] Pointer to QMSL_GSM_Rx_Gain_Range_struct, GSM LNA range gain calibration values.  See QLib_Defines.h for details

	\param aGSM_Rx_Gain_Range_NV [output] Pointer to QMSL_GSM_Rx_Gain_Range_NV_struct.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_GSM_Rx_Gain_Range_Results(
													HANDLE hResourceContext,
													unsigned short iNvModeId,
													void* aGSM_Rx_Gain_Range_Result,
													void* aGSM_Rx_Gain_Range_NV,
													unsigned char bCachedByNVManager
													);

	/******************************************************************************/
	/**
	Generate GSM calibrationa channel list item (NV_GSM_CAL_ARFCN NV) items.

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param aGSM_Cal_ARFCN_List [input] Pointer to an array of GSM calbrtation channel

	\param iNumOfChannel [input] Number of channel in aGSM_Cal_ARFCN_List

	\param pGSM_Cal_ARFCN_NV [output] Pointer to QMSL_RFCAL_NV_Item.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_GSM_CAL_ARFCN(HANDLE hResourceContext,
													unsigned short iNvModeId,
													unsigned short* aGSM_Cal_ARFCN_List,
													unsigned char iNumOfChannel,
													void * pGSM_Cal_ARFCN_NV,
													unsigned char bCachedByNVManager);


	/******************************************************************************/
	/**
	Generate NV items related to internal thermistor calibration.  The NV Items include (NV_THERM, NV_THERM_TEMP_MAX, NV_THERM_TEMP_MIN)

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param nIdc = optimized Idc value found using the procedure that involves multiple sweeps using QLIB_FTM_TX_CS_SWEEP()

	\param nQdc = optimized Qdc value found using the procedure that involves multiple sweeps using QLIB_FTM_TX_CS_SWEEP()

	\param pGSM_Carrier_Suppression_NV = output, structure of type QMSL_RFCAL_NV_Item, the result of the NV will be stored here.  No action
	                                     is required on this data, it is provided for troubleshooting purposes.

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_GSM_CARRIER_SUPRRESSION(	HANDLE hResourceContext,
																unsigned short iNvModeId,
																short iIdc,
																short iQdc,
																void * pGSM_Carrier_Suppression_NV,
																unsigned char bCachedByNVManager);



	/******************************************************************************/
	/**
	Generate NV items related to internal thermistor calibration.  The NV Items include (NV_THERM, NV_THERM_TEMP_MAX, NV_THERM_TEMP_MIN)

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param pInt_Therm_Cal_Meas [input] Pointer to QMSL_Internal_Thermistor_Cal_Meas_struct.  See QLib_Defines.h for details

	\param pInt_Therm_Cal_NV [input] Pointer to QMSL_Internal_Thermistor_Cal_NV_struct.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_Internal_Thermistor_Calibration_Results(	HANDLE hResourceContext,
																				void *pInt_Therm_Cal_Meas,
																				void *pInt_Therm_Cal_NV,
																				unsigned char bCachedByNVManager);

	/******************************************************************************/
	/**
	Generate NV items related to GPS RFIC IM2 calibration.  The NV Items include (NV_GPS1_GPS_RFIC_IM2CAL_IM2DAC_I_CHANNEL_I, NV_GPS1_GPS_RFIC_IM2CAL_IM2DAC_Q_CHANNEL_I)

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param pGPS_IM2_Cal_Results [input] Pointer to QMSL_GPS_IM2_Cal_Results_struct.  See QLib_Defines.h for details

	\param pGPS_IM2_Cal_NV [input] Pointer to QMSL_GPS_IM2_Cal_NV_struct.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_GPS_IM2_Calibration_Results(	HANDLE hResourceContext,
																				void *pGPS_IM2_Cal_Results,
																				void *pGPS_IM2_Cal_NV,
                                                            unsigned char bCachedByNVManager);

	/******************************************************************************/
	/**
	Generate NV items related to receiver IQ mismatch calibration.  The NV Items include

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param pRx_IQMismatch_Cal_Meas [input] Pointer to QMSL_RxIQMismatch_Cal_Meas_struct.  See QLib_Defines.h for details

	\param pRx_IQMismatch_Cal_NV [input] Pointer to QMSL_RxIQMismatch_Cal_NV_struct.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_Rx_IQMismatch_Calibration_Results(	HANDLE hResourceContext,
																								unsigned short iNvModeId,
																								void *pRx_IQMismatch_Cal_Meas,
																								void *pRx_IQMismatch_Cal_NV,
																								unsigned char bCachedByNVManager);
	/******************************************************************************/
	/**
	Run the ICI calibration algorithm on the given input data, and provide the raw ICI coefficients.

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param pRx_ICI_Cal_Meas [input] Pointer to QMSL_Rx_ICI_Cal_Meas_struct.  See QLib_Defines.h for details

	\return true if operation is successful, false otherwise

	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_Rx_ICI_Calibration_Algorithm( HANDLE hResourceContext, void *pRx_ICI_Cal_Meas );

	/******************************************************************************/
	/**
	Generate NV items related to receiver ICI calibration.  The NV Items include

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param pRx_ICI_Cal_Meas [input] Pointer to QMSL_Rx_ICI_Cal_Meas_struct.  See QLib_Defines.h for details

	\param pRx_ICI_Cal_NV [input] Pointer to QMSL_Rx_ICI_Cal_NV_struct.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_Rx_ICI_Calibration_Results(	HANDLE hResourceContext,
																						unsigned short iNvModeId,
																						void *pRx_ICI_Cal_Meas,
																						void *pRx_ICI_Cal_NV,
																						unsigned char bCachedByNVManager);

	/******************************************************************************/
	/**
	Generate NV items related to CDMA/WCDMA Calibration Channels (NV_TX_CAL_CHAN, NV_RX_CAL_CHAN, NV_RX1_CAL_CHAN)

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNvModeId [input] Enumeration of nv_mode_id_type.  The NV mode ID determines the set of NV items to be generated.  See QLib_Defines.h for definition

	\param iChannelTypeEnum [input] Enumeration of QMSL_RFCAL_Channel_Type

	\param pChannel_List [input] The pointer to channel list

	\param iNumOfChannel [input] Number of channel in the list

	\param pRFCal_Chan_NV [output] Pointer to QMSL_RFCAL_NV_Item.  See QLib_Defines.h for details

	\param bCachedByNVManager [input]  Store generated NV items in NV Manager.  NV items stored in NV Manager will be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.
										bCachedByNVManager == 1: Store NV items
										bCachedByNVManager == 0: Do not store NV items.  Generated NV items will not be written to mobile when QLIB_RFCAL_NV_Manager_WriteToPhone is called.

	\return true if operation is successful, false otherwise

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called
	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_CAL_CHAN(	HANDLE hResourceContext,
												unsigned short iNvModeId,
												unsigned short iChannelTypeEnum,
												unsigned short* pChannel_List,
												unsigned short iNumOfChannel,
												void *pRFCal_Chan_NV,
												unsigned char bCachedByNVManager);


	/******************************************************************************/
	/**
	Utility function.  Do linear interpolation/extrapolation for raw measurement data.

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param adRawX [input] An array of raw measurement data(double) on X axis

	\param adRawY [input] An array of raw measurement data(int) on Y axis.

	\param iNumRawData[input] Number of raw measurment data point.

	\param aInputX [input] An array of data on X axis to be intrepolated.

	\param aOutputY [output] An array of exterpolated/intrepolated data on Y axis.

	\param iNumDataPoint[input].  The number of data point to be intrepolated/extrapolated.

	\param iMinValue[input].  The lower bound of extrepolated/intrepolated data

	\param iMaxValue[input].  The upper bound of extrepolated/intrepolated data

	\return true if operation is successful, false otherwise

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_LinearInterpolation(	HANDLE hResourceContext,
															double * adRawX,
															int *aiRawY,
															int iNumRawData,
															double* aInputX,
															int* aOutputY,
															int iNumDataPoint,
															int iMinValue,
															int iMaxValue);

	/******************************************************************************/
	/**
	Utility function.  Do linear interpolation/extrapolation for raw measurement data.

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param adRawX [input] An array of raw measurement data(double) on X axis.  The data on X axis must be sorted.

	\param adRawY [input] An array of raw measurement data(double) on Y axis.

	\param iNumRawData[input] Number of raw measurment data point.

	\param aInputX [input] An array of data on X axis to be interpolated.

	\param aOutputY [output] An array of extrapolated/intrepolated data on Y axis.

	\param iNumDataPoint[input].  The number of data point to be intrepolated/extrapolated.

	\param iNumOfPtsToAverageSlope[input].  The number of points on each side of the data series used to calculate the slope for data extrapolation

	\param iMinValue[input].  The lower bound of extrepolated/intrepolated data

	\param iMaxValue[input].  The upper bound of extrepolated/intrepolated data

	\return true if operation is successful, false otherwise

	\warning

	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_LinearInterpolation_SlopeAveragingExtrapolation
														(	HANDLE hResourceContext,
															double * adRawX,
															double *aiRawY,
															int iNumRawData,
															double* aInputX,
															double* aOutputY,
															int iNumDataPoint,
															int iNumOfPtsToAverageSlope,
															double iMinValue,
															double iMaxValue);



	/******************************************************************************/
	/**
	Add a NV item to NV Manager's cache.  The NV item must be managed by NV Manager.  Use QLIB_RFCAL_NV_Manager_IsNVItemManaged to
	check whether the NV item is managed.

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param pNVitem[input].  Pointer to QMSL_RFCAL_NV_Item.

	\return false if the NV item is managed by NV Manager

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called

	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_NV_Manager_AddNVItem(	HANDLE hResourceContext,
															void* pNVItem);


	/******************************************************************************/
	/**
	The NV Manager has a built in list of RF NV items.  The function checks whether the NV item is in the list

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNVEnum[input] NV Item Enuermation

	\return true if the NV item is managed by NV Manager, false otherwise.

	\warning

	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_NV_Manager_IsNVItemManaged(	HANDLE hResourceContext,
																	unsigned short iNVEnum);


	/******************************************************************************/
	/**
	Get the number of NV items stored in NV Manager's cache.  The number includes both items generated by
	QLIB_RFCAL_xxx_Results functions and QLIB_RFCAL_NV_Manager_Add_OEM_NVItem.

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNumOfItemInCache[input] number of NV items stored in NV Manager's cache

	\return true

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_NV_Manager_GetNumItemInCache(	HANDLE hResourceContext,
																	unsigned short* iNumOfItemInCache);


	/******************************************************************************/
	/**
	Add an OEM NV item to NV Manager's cache.

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param pNVitem[input].  Pointer to QMSL_RFCAL_NV_Item.

	\return

	\warning NV items are not written to the mobile station until QLIB_RFCAL_NV_Manager_WriteToPhone is called

	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_NV_Manager_Add_OEM_NVItem(	HANDLE hResourceContext,
																	void* pNVItem);





	/******************************************************************************/
	/**
	Get a NV item stored in NV Manager.  Call this function after QLIB_RFCAL_xxx_Results

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param iNVEnum[input] NV Item Enuermation

	\param iStatus[output] The status bit in NV Manager.  1 if the item has data, 0 if the item is clear.

	\param pNVitem[output].  Pointer to QMSL_RFCAL_NV_Item.  The function will fill up this data struture if the item has data.

	\return false if the NV item is not managed by NV Manager

	\warning

	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_NV_Manager_GetNVItem(	HANDLE hResourceContext,
															unsigned short iNVEnum,
															unsigned char* iStatus,
															void* pNVItem);

	/******************************************************************************/
	/**
	Write NV items stored in NV Manager to mobile station.  The NV items are generated by previous QLIB_RFCAL_xxx_Results calls

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param pWriteToPhoneStatus Pointer to QMSL_RFCal_WriteToPhone_Status.  This structure return the ID and status of NV items written to mobile.  This pointer can be NULL.

	\return true if operation is successful, false otherwise

	\warning

	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_NV_Manager_WriteToPhone( HANDLE hResourceContext, void *pWriteToPhoneStatus );

	/******************************************************************************/
	/**
	Generate a QCN file of NV items generated.  This function has not been implemented

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param sFileName [input] File name path

	\return false

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_NV_Manager_Create_QCN( HANDLE hResourceContext, char* sQCNPath  );

	/******************************************************************************/
	/**
	Generate a HTML file of NV items generated

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param sFileName [input] File name path

	\return true if operation is successful, false otherwise

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_NV_Manager_Create_HTML( HANDLE hResourceContext, char* sHTMLReportFile  );

	/******************************************************************************/
	/**
	Generate a text file of NV items stored in NV manager

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param sFileName [input] File name path

	\return true if operation is successful, false otherwise

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_NV_Manager_Create_Text( HANDLE hResourceContext, char* sTextOutputFile  );

	/******************************************************************************/
	/**
	Generate a XML file of NV items generated.  The XML file can be used by QRCT to load NV to mobile station.

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param sFileName [input] File name path

	\return true if operation is successful, false otherwise

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_NV_Manager_Create_XML ( HANDLE hResourceContext, char* sXMLOutputFile  );


	/******************************************************************************/
	/**
	Generate a HTML file of NV items generated in byte (HEX) view.

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\param sFileName [input] File name path

	\return true if operation is successful, false otherwise

	\warning
	*******************************************************************************/

	QLIB_API unsigned char QLIB_RFCAL_NV_Manager_Create_HTML_ByteStream ( HANDLE hResourceContext, char* sHTMLOutputFile  );


	/******************************************************************************/

	/**
	Clear all NV items stored in NV Manager.  The NV Items are generated by previous QLIB_RFCAL_xxx_Results calls or
	QLIB_RFCAL_NV_Manager_Add_OEM_NVItem.

	\param hResourceContext	Resource context that was returned from the call to ConnectServer().

	\return true if operation is successful, false otherwise

	\warning

	*******************************************************************************/
	QLIB_API unsigned char QLIB_RFCAL_NV_Manager_Clear_Data( HANDLE hResourceContext );


/******************************************************************************
						NVTool
*******************************************************************************/

	/******************************************************************************/

	/**
	*******************************************************************************/
	QLIB_API void QLIB_NV_ConfigureCallBack( HANDLE hResourceContext, nvToolCB pNvToolCallback);

	/******************************************************************************/

	/**
		Remove all the NV definitions.  The associated values are also removed.

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\return true
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_ClearNVDefinition(HANDLE hResourceContext);

	/******************************************************************************/
	/**
		Clear all NV Items values.  All NV items will not have any values.  The NV items definition are not removed.

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\return true
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_ClearNVValues(HANDLE hResourceContext);

	/******************************************************************************/
	/**
		Get the number of NV definition loaded

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iNumOfDefs, the number of NV definition loaded

		\return true
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_GetNumOfNVDefinition(HANDLE hResourceContext, int * iNumOfNVDefs);

	/******************************************************************************/
	/**
		Load a NV definition xml to NVTool
		This function can be called multiple times to load different set of NV items.  (for example, one from AMSS, one from OEM)
		A NV item is uniquely identified by ID. A NV item definition will override any previous definition loaded by QLIB_NV_LoadNVDefinitionFile

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param sNV_Def_XML_Path, NV definition xml file path

		\param piResultCode, Result code

		\param piNumNVDefLoaded, the number of NV item definition added to NVTool

		\return true if result code is 0
	*******************************************************************************/

	/******************************************************************************/
	QLIB_API unsigned char QLIB_NV_LoadNVDefinitionFile(HANDLE hResourceContext, const char * sNV_Def_XML_Path,  int* piNumNVDefLoaded, int * piResultCode);
	/**

		Load NV values from source file.  QLIB_NV_LoadNVDefinition must be called before this function.
		If an NV item has 128 data elements and wasn't been defined through QLIB_NV_LoadNVDefinition,  a generic NV item definition will be automatically created.

		For example, An NV item with id 9999 will be created even if its definition hasn't been defined
		<NvItem id="9999" name="XXXX" mapping="direct" encoding="dec">
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
		</NvItem>

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param sNV_Src_XML_Path, NV source xml file path

		\param piNumOfNVItemValuesLoaded, the number of NV item values loaded

		\param piResultCode, Result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_LoadNVsFromSource(HANDLE hResourceContext, const char * sNV_Src_XML_Path, int* piNumOfNVItemValuesLoaded, int* piResultCode);
	/**
		Read NV items from QCN file
		QLIB_NV_LoadNVDefiniton should be called first.
		Any NV items in QCN file that has not loaded by QLIB_NV_LoadNVDefinition will be treated as a byte stream.  A NV item definition as a byte stream will be automatically created

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param sQCN_Path, QCN File path

		\param iNumOfNVitemValuesLoaded, the number of NV items loaded

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/

	QLIB_API unsigned char QLIB_NV_LoadNVsFromQCN(HANDLE hResourceContext, const char *sQCN_Path, int * iNumOfNVItemValuesLoaded, int *iResultCode);
	/**
		QLIB_NV_LoadNVDefinition should be called first
		Read NV values from mobile.  The NV items to be read are from the definition list(s) loaded by QLIB_NV_LoadNVDefinition

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param  iNumOfNVItemValuesLoaded, the number of NV item values loaded from the mobile

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_LoadNVsFromMobile(HANDLE hResourceContext, int* iNumOfNVItemValuesLoaded, int* iResultCode);
	/**
		Write NV items to QCN file

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param sQCN_Path, QCN file path

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_WriteNVsToQCN(HANDLE hResourceContext, const char *sQCN_Path, int *iResultCode);

	/******************************************************************************/
	/**
		Write NV items to source file

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param sQCN_Path, NV source file path

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/

	QLIB_API unsigned char QLIB_NV_WriteNVsToSource(HANDLE hResourceContext, const char *sNV_Src_Xml, int *iResultCode);

	/******************************************************************************/
	/**
		Write NV items to mobile

		WARNING:

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iResultCode, the result code

		\return true if result code is 0

		\warning If service provisioning NV items are to be written,
		QLIB_DIAG_SPC_F() should be called first to send service provisioning code(SPC) to mobile.
	*******************************************************************************/

	QLIB_API unsigned char QLIB_NV_WriteNVsToMobile(HANDLE hResourceContext, int *iResultCode);

	/******************************************************************************/
 /**
		Write one  NV item to mobile

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()
		\param iIndex, should be between 0 to  GetNumOfNVDefinition() - 1

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/

	QLIB_API unsigned char QLIB_NV_WriteNVItemToMobileByIndex(HANDLE hResourceContext, int iIndex, int *iResultCode);

	/******************************************************************************/
	 /**
		Write one  NV item to mobile

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()
		\param iNVId NV enumeration

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/

	QLIB_API unsigned char QLIB_NV_WriteNVItemToMobileByNVID(HANDLE hResourceContext, int iNVId, int *iResultCode);

	/******************************************************************************/
	/**
		Get the NV defintion string by index.  A NV definition string is defined as <NV item name>:<id>:<format>

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iIndex, should be between 0 to  GetNumOfNVDefinition() - 1

		\param sNVDefintion, the NV definition string buffer

		\param iSizeOfNVDef, the size of NV definition string buffer

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_GetNVDefinitionByIndex(HANDLE hResourceContext, int iIndex, char* sNVDefinition, int iSizeOfNVDef, int *iResultCode);

	/******************************************************************************/
	/**
		Get the NV value byte stream by index

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iIndex, should be between 0 to  GetNumOfNVDefinition() - 1

		\param iNVValueBuffer, the NV value buffer

		\param iSzOfBuffer, size of iNVValueBuffer, the actual size of byte stream is returned

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_GetNVValueByteStreamByIndex(HANDLE hResourceContext, int iIndex , unsigned char *iNVValueBuffer, int* iSzOfBuffer, int *iResultCode);

	/******************************************************************************/
	/**
		Get the NV value string by index

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iIndex, should be between 0 to  GetNumOfNVDefinition() - 1

		\param iNVValueStrBuffer, the NV value buffer

		\param iSzOfStrBuffer, size of iNVValueStrBuffer

		\param iMapping (direct = 0, byteStream = 1)

		\param iEncoding (dec = 0, hex = 1)

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_GetNVValueStringByIndex(HANDLE hResourceContext, int iIndex , char *iNVValueStrBuffer, int* iSzOfStrBuffer, int iMapping, int iEncoding, int *iResultCode);

	/******************************************************************************/
	/**
		Get the NV value byte stream by NV ID

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iNVId NV enumeration

		\param iNVValueBuffer, the NV value buffer

		\param iSzOfBuffer, size of iNVValueBuffer, the actual size of byte stream is returned

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_GetNVValueByteStreamByNVID(HANDLE hResourceContext, int iNVId, unsigned char *iNVValueBuffer, int* iSzOfBuffer, int *iResultCode);

	/******************************************************************************/
	/**
		Get the NV value string by NV ID

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iNVId NV enumeration

		\param iNVValueStrBuffer, the NV value buffer

		\param iSzOfStrBuffer, size of iNVValueStrBuffer

		\param iMapping (direct = 0, byteStream = 1)

		\param iEncoding (dec = 0, hex = 1)

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_GetNVValueStringByNVID(HANDLE hResourceContext, int iNVId , char *iNVValueStrBuffer, int* iSzOfStrBuffer, int iMapping, int iEncoding, int *iResultCode);

	/******************************************************************************/
	/**
		Set the NV value stored in a byte array by index

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iIndex, should be between 0 to  GetNumOfNVDefinition() - 1

		\param iNVValueBuffer, the NV value buffer

		\param iSzOfBuffer, size of iNVValueBuffer

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_SetNVValueByteStreamByIndex(HANDLE hResourceContext, int iIndex , unsigned char *iNVValueBuffer, int iSzOfBuffer, int *iResultCode);

	/******************************************************************************/
	/**
		Set the NV value stored in a string by index.  The NULL character terminated string should be in direct mapping and dec encoding

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iIndex, should be between 0 to  GetNumOfNVDefinition() - 1

		\param iNVValueStr, the NV value string

		\param iMapping (direct = 0, byteStream = 1)

		\param iEncoding (dec = 0, hex = 1)

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_SetNVValueStringByIndex(HANDLE hResourceContext, int iIndex , char *iNVValueStr, int iMapping, int iEncoding, int *iResultCode);

	/******************************************************************************/
	/**
		Set the NV value stored in a byte array by NV ID.

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iNVId, NV enumeration

		\param iNVValueBuffer, the NV value byte array

		\param iSzOfBuffer, the number of byte in iNVValueBuffer

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_SetNVValueByteStreamByNVID(HANDLE hResourceContext, int iNVId , unsigned char *iNVValueBuffer, int  iSzOfBuffer, int *iResultCode);

	/******************************************************************************/
	/**
		Set the NV value stored in a string by NV ID.

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iNVId, NV enumeration

		\param iNVValueStr, the NULL character terminated value string

		\param iMapping (direct = 0, byteStream = 1)

		\param iEncoding (dec = 0, hex = 1)

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_SetNVValueStringByNVID(HANDLE hResourceContext, int iNVId , char *iNVValueStr, int iMapping, int iEncoding, int *iResultCode);


	/******************************************************************************/
	/**
		Clear NV value by index

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iIndex, should be between 0 to GetNumOfNVDefinition() - 1

		\param iResultCode, Result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_ClearNVValueByIndex(HANDLE hResourceContext, int iIndex, int* iResultCode);

	/******************************************************************************/
	/**
		Clear NV value by NV ID

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iNVId, NV enumeration

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_ClearNVValueByNVID(HANDLE hResourceContext, int iNVId, int* iResultCode);

	/******************************************************************************/
	/**
		Clear the write filter

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_ClearWriteFilters(HANDLE hResourceContext);

	/******************************************************************************/
	/**
		Load write filter.  The write filter controls the NV items that can be written to XML, QCN or mobile

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param sFilter_XML_Path, Write filter definition (XML) file path

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_LoadWriteFilter(HANDLE hResourceContext, const char * sFilter_XML_Path,  int* iResultCode);

	/******************************************************************************/
	/**
		Clear the read filter.  All the defined NV items (loaded from QLIB_NV_LoadNVDefinitionFile) will be read from mobile

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_ClearReadFilters(HANDLE hResourceContext);


	/******************************************************************************/
	/**
		Load read filter.  The read filter controls the NV items that can be read from XML, QCN or mobile

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param sFilter_XML_Path, read filter definition (XML) file path

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_LoadReadFilter(HANDLE hResourceContext, const char * sFilter_XML_Path,  int* iResultCode);

	/******************************************************************************/
	/**
		Compare the two QCN files.   For NV items with multiple entries/indices, such as NAM based NV items, the function will
		only compare the data at Index 0

		It cannot compare EFS, PRL content in the QCN.

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param sQCN1Path, 1st QCN file path

		\param sQCN2Path, 2nd QCN file path

		\param sHTMLPath, diff result path.  The diff output is stored in a HTML file.

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_QCN_Diff(HANDLE hResourceContext, const char *sQCN1Path, const char *sQCN2Path, const char *sHTMLPath, int *iResultCode);

	/******************************************************************************/
	/**
		Generate a QDF formatted file.  A QDF file(text) contains NV item definitions.  The QDF is used by RF NV Manager to manage NV items.
		The NV items definition must be loaded by QLIB_NV_LoadNVDefinitionFile().
		Call QLIB_NV_LoadReadFilter prior to this function to filter the NV definition generated.

		This is a typical sequence to call QLIB_NV_GenerateQDF

		QLIB_NV_LoadNVDefinition
		QLIB_NV_LoadReadFilter (optional)
		QLIB_NV_Generate QDF

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param sQDFPath, QDF file path

		\param iResultCode, the result code

		\return true if result code is 0
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_GenerateQDF(HANDLE hResourceContext, const char *sQDFPath, int *iResultCode);

	/******************************************************************************/
	/**
		Generate a NV filter based on the NV ID loaded by QLIB_NV_LoadNVDefinition API

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param sFilterPath, Filter file to be created

		\param iResultCode, the result code

		\return true if result code is 0

		\warining QLIB_NV_LoadDefintion should be called first
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_CreateNVFilter(HANDLE hResourceContext, const char *sFilterPath, int *iResultCode);

	/******************************************************************************/
	/**
		Generate a NV filter based on the NV ID NOT loaded by QLIB_NV_LoadNVDefinition API

		For example, if NV item 0 to 3000 is loaded by QLIB_NV_LoadNVDefinition.  A filter file
		with NV ID between 3001 to iMaxNVId will be created

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param sCompFilterPath, Filter file to be created

		\param iMaxNVId, The maximum NV enuemration for the filter

		\param iResultCode, the result code

		\return true if result code is 0

		\warining QLIB_NV_LoadDefintion should be called first
	*******************************************************************************/
	QLIB_API unsigned char QLIB_NV_CreateComplementNVFilter(HANDLE hResourceContext, unsigned short iMaxNVId, const char *sCompFilterPath, int *iResultCode);

/******************************************************************************
						FTM Sequencer
*******************************************************************************/

	/******************************************************************************/
	/**
		Activate the sequenceing engine, either on PC or AMSS.  Subsequent QMSL calls will cache the diag command
		either on sequencing engine inside QMSL or AMSS

		The cached diag commands will only be executed or processed when QLIB_FTM_SEQ_EXECUTE_QUEUE() is called.

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\return true if the opreation is successful

		\warning this function does not send any diag commands to mobile

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SEQ_ActivateBatchMode(HANDLE hResourceContext);
	/******************************************************************************/
	/**
		Deactivate the sequencing engine, either on PC or AMSS.  Subsequent QMSL calls will send the diag command
		to mobile. The diag command will be executed immediately.

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\return true if the opreation is successful

		\warning this function does not send any diag commands to mobile

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SEQ_DeactivateBatchMode(HANDLE hResourceContext);
	/******************************************************************************/
	/**
		Set the to use the sequencer inside QMSL or embedded side.

		QMSL, by default, runs sequencer on AMSS side.

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param bSequencerRunningOnPC = 1 (use the sequencer engine inside QMSL)
		                             = 0 (DEFAULT: use the sequencer engine on embedded side)

		\return true if the opreation is successful

		\warning this function does not send any diag commands to mobile
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SEQ_SetSequencerMode(HANDLE hResourceContext, unsigned char bSequencerRunningOnPC);
	/******************************************************************************/
	/**
		Adds a wait relative to the last wait that was received.

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iWaitTimeInus, wait time in micro seconds(us)

		\return true if the opreation is successful

		\warning QLIB_FTM_SEQ_ActivateBatchMode should be called first

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SEQ_ADD_WAIT(HANDLE hResourceContext, unsigned long iWaitTimeInus, unsigned short* iFTM_Error_Code);


	/******************************************************************************/
	/**
		Controls capturing of commands. When capturing is turned on, all request traffic that is routed
		through the FTM Sequencer will be stored in the command queue for later execution.

		This API has no effect when sequenceing engine runs inside QMSL.

		This API will only work when sequencing engine runs on AMSS.

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iCaptureOn, 1 == Turn on the capturing
		                   0 == Turn off the capturing

		\return true if the opreation is successful

		\warning QLIB_FTM_SEQ_ActivateBatchMode should be called first
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SEQ_CAPTURE_CONTROL(HANDLE hResourceContext, unsigned char iCaptureOn, unsigned short* iFTM_Error_Code);
	/******************************************************************************/
	/**
		This command sets a timing marker at the execution time, so that the next wait, created by FTM_SEQ_ADD_WAIT, will be relative to this point in time.

		This command can be used when the sequence contains some commands of variable duration and it is not necessary to use a fixed wait time. 
		For example, if the commands occur before an equipment trigger

		This API has no effect when sequenceing engine runs inside QMSL.

		This API will only work when sequencing engine runs on AMSS.

		\param iFTM_Error_Code 0 = Success
		                       1 = Failure

		\return true if the opreation is successful

		\warning QLIB_FTM_SEQ_ActivateBatchMode should be called first

	*******************************************************************************/
    QLIB_API unsigned char QLIB_FTM_SEQ_ADD_TIMING_MARKER(HANDLE hResourceContext, unsigned short* iFTM_Error);
	/******************************************************************************/
	/**
		Flush the commands buffered in QMSL to embedded (AMSS) sequencer.

		QMSL has 1k buffer.  The buffer will be flushed automatically to embedded sequencer when it is full.

		This API should be called prior to QLIB_FTM_SEQ_EXECUTE_QUEUE

		// embedded sequencer
		QLIB_FTM_SEQ_SetSequencerMode( g_hResourceContext, 0);
		QLIB_FTM_SEQ_ActivateBatchMode( g_hResourceContext );

		for(k = 0; k < 30; k ++)
		{
			QLIB_FTM_SET_PDM(g_hResourceContext, 2, 85 - k  );
			QLIB_FTM_SEQ_ADD_WAIT(g_hResourceContext, 20*ms, &iFTM_Error_Code);
		}
		
		QLIB_FTM_SEQ_Flush_Command_Buffer();

		QLIB_FTM_SEQ_STATUS( g_hResourceContext, & iFTM_Error_Code, & iQueue_Item_Count, &bIsEexcuting, &iNext_ID_Number, & iTimeRef);
		// iQueue_Item_Count = 60 (30*2)
		// if QLIB_FTM_SEQ_Flush_Command_Buffer is not called, iQueue_Item_Count will be less than 60 as some commands
		// are still buffered up in QMSL

		QLIB_FTM_SEQ_EXECUTE_QUEUE( g_hResourceContext, &iFTM_Error_Code );


		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SEQ_Flush_Command_Buffer(HANDLE hResourceContext);

	/******************************************************************************/
	/**
		Resize QMSL local queued command buffer. The default size is defined as FTM_Sequencer_Command_Queue_Buffer_Size in QLib_Defines.h
		
		This function should be called when local queued command buffer is empty.  The command buffer is empty.

		The command buffer is empty either 1) after queue is executed or 2) no commands has been added to the queue.
	
		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iNewSize.  New size of the buffer.  It should be less than or equal to MAX_FTM_Sequencer_Command_Queue_Buffer_Size in QLib_Defines.h
						  It should never exceed the maximum diagnostic packet size handled by AMSS.
		                  
		\return true if the opreation is successful

		\warning QLIB_FTM_SEQ_ActivateBatchMode should be called first
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SEQ_Resize_Commnad_Buffer(HANDLE hResourceContext, unsigned short iNewSize);
	/******************************************************************************/
	/**
		Executes the existing FTM Sequencer queue of FTM messages.

		This is a blocking function.  The function will return after the last command has been executed.

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iFTM_Error_Code, FTM Error Code returned by embedded side

		\param iSequenceCompleted, 1 = Sequence completed before timeout
		                           0 = Sequence did not complete before timeout

		\note Use QLIB_ConfigureTimeOut(hQMSL, QMSL_Timeout_Embedded_Sequencer_Execution) to configure the time out value

		\return true if the opreation is successful

		\warning QLIB_FTM_SEQ_ActivateBatchMode should be called first
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SEQ_EXECUTE_QUEUE(HANDLE hResourceContext, unsigned short* iFTM_Error_Code, unsigned char *iSequenceCompleted);


	/******************************************************************************/
	/**
		Erases all messages in the FTM Sequencer queue. Resets the FTM Sequencer state machine to be not executing

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\return true if the opreation is successful

		\warning QLIB_FTM_SEQ_ActivateBatchMode should be called first
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SEQ_CLEAR_QUEUE(HANDLE hResourceContext, unsigned short* iFTM_Error_Code);

	/******************************************************************************/
	/**
		Return the status of the command queue

		This API has no effect when sequenceing engine runs inside QMSL.

		This API will only work when sequencing engine runs on AMSS.

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iFTM_Error_Code, 1 == Error
								0 == Success

		\param iQueue_Item_Count, the number of items in the FTM Sequencer queue

		\param bIsExecutring,	0  Not currently executing the queue commands
								1  Currently executing the queue commands

		\param iNext_ID_Number,		If IS_EXECUTING==0  ID_NUMBER of the first item in the FTM Sequencer queue
									If IS_EXECUTING==1  ID_NUMBER of current item being executed

		\param iTimeRef, TIme value is micro second, relative to the initial time

		\return true if the opreation is successful

		\warning QLIB_FTM_SEQ_ActivateBatchMode should be called first
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SEQ_STATUS(HANDLE hResourceContext, unsigned short* iFTM_Error_Code, unsigned long* iQueue_Item_Count, unsigned char *bIsEexcuting, unsigned long *iNext_ID_Number, unsigned long* iTimeRef);

	/******************************************************************************/
	/**
		Get the diag command response.  The respond corresponds the command identified by tcommand sequence ID

		\param hResourceContext	Resource context that was returned from the call to QLIB_ConnectServer()

		\param iSeqID, the command sequence ID

		\param pData, a user provided data buffer to store the response

		\return true if the opreation is successful

		\warning QLIB_FTM_SEQ_ActivateBatchMode should be called first
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SEQ_GET_RESPONSE(HANDLE hResourceContext, unsigned long iSeqID, unsigned char *pData);

/******************************************************************************
						Band Class Helper
*******************************************************************************/

	/******************************************************************************/
	/**
		Calculate the downlink (forward) frequency
		
		\param iBand, Band class enumeration.  See BAND_CLASS_ENUM in QLib_Defines.h

		\param iChannel, downlink channel number

		\return frequencey in MHz.  0 is returned for invalid band class or channel number

	*******************************************************************************/
	QLIB_API double QLIB_Band_Helper_CalculateDLFrequency(unsigned short iBand, unsigned long iChannel);

	/******************************************************************************/
	/**
		Calculate the uplink (reverse) frequency
		
		\param iBand, Band class enumeration.  See BAND_CLASS_ENUM in QLib_Defines.h

		\param iChannel, uplink channel number

		\return frequencey in MHz.  0 is returned for invalid band class or channel number

	*******************************************************************************/
	QLIB_API double QLIB_Band_Helper_CalculateULFrequency(unsigned short iBand, unsigned long iChannel);

/******************************************************************************/
	/**

	Sets the enhanced calibration action for

	\Param ienhCalAction	= 0 - No Action
							= 1 - APT
	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_SET_TX_ENH_CAL_ACTION( HANDLE hResourceContext, unsigned char ienhCalAction );

    /******************************************************************************/
	/**

	Loads the Tx linearizer calibration data to the embedded side data structures. Used when
	FTM_SET_TX_ENH_CAL_ACTION is used to set calAction > 0

	\Param pFTM_Tx_Lin_CalData_Req[input] , pointer to FTM_Load_Tx_Linearizer_Cal_Data_Request defined in Qlib_Defines.h
	\Param pFTM_Tx_Lin_CalData_Res[input], pointer to FTM_Load_Tx_Cal_Data_Response defined in QLib_Defines.h
	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char QLIB_FTM_LOAD_TX_LINEARIZER_CAL_DATA( HANDLE hResourceContext, void * pFTM_Tx_Lin_CalData_Req, void * pFTM_Tx_Lin_CalData_Res );


    /******************************************************************************/
	/**

	Loads the Tx freq comp calibration data to the embedded side data structures. Used when
	FTM_SET_TX_ENH_CAL_ACTION is used to set calAction > 0

	\Param pFTM_Tx_Freqcomp_CalData_Req[input] , pointer to FTM_Load_Tx_FreqComp_Cal_Data_Request defined in QLib_Defines.h
	\Param pFTM_Tx_Freqcomp_CalData_Res[input], pointer to FTM_Load_Tx_Cal_Data_Response defined in Qlib_Defines.h
	\return true if successful, false if fail.

	\warning
	*******************************************************************************/
	QLIB_API unsigned char  QLIB_FTM_LOAD_TX_FREQCOMP_CAL_DATA( HANDLE hResourceContext, void * pFTM_Tx_Freqcomp_CalData_Req, void * pFTM_Tx_FreqComp_CalData_Res);

   /******************************************************************************/
   /**

   Sets the power optimization mode for QPOET programming

   \Param iPwrOptMode	= 0 - POET SLEEP
                        = 1 - POET BYPASS
                        = 2 - POET APT
                        = 3 - POET ET
   \return true if successful, false if fail.

   \warning
   *******************************************************************************/
   QLIB_API unsigned char QLIB_FTM_SET_PWR_OPTIMIZATION_MODE( HANDLE hResourceContext, unsigned char iPwrOptMode );


#ifdef __cplusplus
}	// extern "C"
#endif

#endif	// defined(_QLIB_H)
